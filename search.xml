<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GRE 备考篇</title>
    <url>/2021/10/13/zh-CN/GRE-%E5%A4%87%E8%80%83%E7%AF%87/</url>
    <content><![CDATA[<p>考完九天出分，作文不太高吧。但也不想再考这个了，应该做点更有用的东西，不能魔怔。学
GRE
给我最有用的帮助，无外乎词汇量大大增加了，看文章稍微快一点了。但实际上，不会的单词还是得查，也许和我不懂很多汉语成语的意义是一个道理吧。报个
GRE 确实还是有帮助的，否则自己的嘤语水平怎么提升呢（笑）</p>
<figure>
<img src="/images/greprep/GREScore.png" alt="GREScore" />
<figcaption aria-hidden="true">GREScore</figcaption>
</figure>
<p>看看这备考的一个半月我都在干什么</p>
<h2 id="section">2021.10.13</h2>
<p>上个月十八号脑子一热，报了这个月底 GRE，1665 RMB
比托福雅思还是便宜一点。当时兴致勃勃说别人准备三个月那我自学一个半月应该没什么问题，现在一个月快过去了，我觉得很有问题。</p>
<p>这一个月中间有十一假期，但是我这个月也做了不少别的事（花了很多时间写课程作业、报
BGA 和 IGSP），所以也不算用了很多时间。要你命三千小程序统计我背了 41
小时单词，算上别的做模拟、看书和用 Excel 背单词，满打满算也就准备了 70
个小时吧。但是 GRE 的标准准备时间差不多是 400 小时，笑死。</p>
<p>刷了快两遍 3000
了，还是有一半不认识，做题不认识词比较艰难。国庆做的模拟，Verbal 一个
Section 大概错 10/20 个，Quantitive
偶尔粗心（或者题没印好）错。作文看了范文，还没自己写过，我感觉半小时我没法有那么多
Development。</p>
<p>这两天又忙活了两天博客，修 <span
class="math inline">\(\LaTeX\)</span> 修炸脑袋。</p>
<p>感觉这些东西还是很有用的：</p>
<ul>
<li><a href="https://www.ets.org/gre/revised_general/prepare/">ETS
官网</a>，上面有 Math Conventions；</li>
<li>Official
Guide，这本大书今年大早就买了，看来只有报了才能促进你学习；（后来我找到电子版，书感觉就不会变旧了）</li>
<li><a href="https://library.koolearn.com">新东方在线</a>，交大 IP
的话可以白嫖数年前的线上课程；</li>
<li>各种模考网站：<a
href="https://11gre.com/paper/view?type=0">11gre</a>，<a
href="http://gwc.weichenedu.cn/products/">微臣</a>，<a
href="https://www.gre.vip/home">皇冠gre</a>，但我一分钱也没交，题够刷了；</li>
<li><a href="http://www.dicts.cn/">词根词缀词典</a>，以及它的安卓、IOS
App，它们的开发者看起来有血有肉的，很有意思；</li>
<li><em>The Economist</em> 表达水平这真的高，可惜政治立场有点对立；</li>
<li>3000 核心词的 Excel 表，我放在博客里吧，感觉有用：<a
href="/files/GRE3000Essential.xls">GRE3000Essential.xls</a>（<em>upd.</em>
这有不少错的释义，谨慎）。</li>
</ul>
<p>要努力背单词！</p>
<p><em>upd.</em> <a
href="https://github.com/liurui39660/3000">Excel版再要你命3000</a>
这个分享在 Github 上的 Excel
版似乎要更加不错一点，但我已经用了个好多错的，就无所谓了。</p>
<h2 id="section-1">2021.10.17</h2>
<p>更新一下背单词情况：昨天刷完了第二遍 3k（APP 是第一遍，Excel
第二遍），把所有的词都标了认识程度，1 是不认识，4 是认识，结果有 1100
左右个 1，几百个 2，3 和 4 大约 1500
个。今天开始第三遍，刷了三百五十多个吧。虽然第三遍只背标 1
的，但也感觉背起来轻松一点了，除了几个老顽固都能记住。</p>
<p>列一下我用过的背单词的方法吧：</p>
<ul>
<li>日常背单词的软件（墨墨/不背/百词斩/扇贝）没法短时大量高次数，备考就算了；</li>
<li>再要你命三千的小程序，里面的搭配可以背一背，也就三百多个，背词的
part 结算是看中文选英文，感觉非常不合适，反过来就好了；</li>
<li>Excel
词表，感觉还是不错，左右留空白把词和意思隔开，然后标熟练度，排序；今天发明了滑动窗口背词加随机抽样复习，感觉十分有效；</li>
<li>等价词总，有总结的我觉得不错，背完 3000 试试。</li>
</ul>
<p>今天还做了点模拟，不太多，感到 11gre
上的题有点捏造，界面也有点不友好，皇冠还行。正确率依然拉跨。</p>
<p>看了看网上说的算分标准，什么错六个以内进 Hard，然后 Hard
的话是分数做对题数加三什么的......</p>
<h2 id="section-2">2021.10.19</h2>
<p>其实现在是十九号凌晨，刚过去的是 18 号。18 早上把 17 号背的 370
词复习了一遍，很好，只忘了五十个。</p>
<p>下午处理计算机网络作业又上了复杂网络课，感觉复杂网络考前突击一下就好了。</p>
<p>晚上继续背词，背词背的没兴致了就开始刷词汇题机经，发现题对我而言看起来没那么难了，但是更难的题还是容易错。机经有些词里
Excel 没有，我把它们记到 Excel 了。</p>
<p>索性不睡了，第二天都是课，正适合刷夜。要是第二天没课还刷夜，白天指不定睡过去。于是点了一大碗咖啡，双份浓缩。</p>
<figure>
<img src="/images/greprep/10.19.21coffee.jpg"
alt="图书馆咖啡厅的大碗咖啡" />
<figcaption aria-hidden="true">图书馆咖啡厅的大碗咖啡</figcaption>
</figure>
<p>还可以看个苹果发布会......新 MacBook......可能会有点想买。</p>
<p>刷机经，背单词，刷机经，背单词......</p>
<p>发布 Homepods 和 Airpods 的时候在背词，一上来就是 Mac，
刺激；就当练听力了（误）；这个三哥口音听起来真别扭...M1Pro...好怪的名字。但新的封装还挺好看。</p>
<p>M1Max???，神么玩意。疯了。草，越看越买不起。快给我看新模具啊。</p>
<p>还真有 Magsafe，HDMI，妈呀。</p>
<p>刘海，我*你**，我想回去刷机经。</p>
<p>还真有 Promotion......</p>
<p>看完了，1999$，回去刷机经吧。</p>
<p>三点多，机经刷了一百个填空，词还剩下五百要背，顶不住了，半途而废吧，回去睡一觉。</p>
<h2 id="section-3">2021.10.24</h2>
<p>离考试还剩七天。</p>
<p>早上做了一个官方的模拟，感觉不太行，状态太差了，前几天背完第三遍词不应该飘的。而且有些题目没有办法逻辑上理解，事后花了一些时间。</p>
<p>第一次写作文，时间果然不够，还有就是对字数的估计不足：写完觉得有 500
词，实际上分别只写了 310 和 350 词。还是要提高遣词造句速度！</p>
<figure>
<img src="\images\greprep\powerprep1result.png"
alt="Powerprep1 results" />
<figcaption aria-hidden="true">Powerprep1 results</figcaption>
</figure>
<p>今天白天整理完了《高分必备短语搭配》上不会的短语，准备继续背，但是我现在实在有点太困了，还有点流鼻涕。冲啊。</p>
<p><em>upd.</em> 晚上背词背得过于魔怔，回来看写作，直接被整破防了：</p>
<figure>
<img src="\images\greprep\RealismVSIdealism.png"
alt="RealismVSIdealism" />
<figcaption aria-hidden="true">RealismVSIdealism</figcaption>
</figure>
<p>少见如此以启发式的态度，将自己的人生经历与认识论和学生交流并引起共鸣的老师。</p>
<h2 id="section-4">2021.10.29</h2>
<p>除了 26 号上了一天课和做了凸优化作业，其他时间都在
GRE。感觉单词也差不多了、再背下去边际效应递减。但是又发现了好多 3000
之外的词值得掌握，于是 Excel 里的词越来越多。</p>
<p>周三（27 号）背完词做了 PowerPrep 2，328，非常难受。感觉 Verbal
时间十分不足。词汇、三空、逻辑单题啥的都还能把握，但长文章真的痛。</p>
<p>刷机经刷了六十多篇文章了，长文章题还是只有一半正确率，丧了。</p>
<p>今天下午和一起考的同学去做核酸检测，他给我推荐张巍的公众号（虽然我还是用的皇冠给的
1300 题和 300 题鸡精），还给我发了 Quantitive 的错题啥的，感谢。</p>
<h2 id="section-5">2021.10.30</h2>
<p>考试前一天（周六）。早上做了个微臣所谓的 PP3
模拟，体验实在是太差了：各种没高亮、选项不全。中午下午心态其实有点飘，因为感觉自己阅读正确率上来了，也没太多词不认识的了，考前一天就是刷题背词刷题背词。</p>
<p>感觉鸡精答案有不少错的，让我面对模棱两可的 GRE
题的时候有点不知所措了。</p>
<h2 id="section-6">2021.10.31</h2>
<p>考试日。前一天晚上也不算睡得很好，两点钟蚊帐掉下来砸头上，被蚊子咬醒了。起来修好蚊帐继续睡。</p>
<p>吃完早饭背了会标记的单词，就去考试了。GRE
是早上十点考试，九点半进场。可以带一点吃的放在考场隔壁教室，做完三个
Section
休息十分钟的时候去吃，但是任何东西都不能带进考场。进考试的教室之后就不能出去了，所以我安检存包之后就在厕所磨蹭了下，<del>顺了好多餐巾纸</del>。进考场之后给我分配了个最后排的考位，但那里整个桌面都在挡板的阴影里，灯照不到，加上屏幕刺眼，我感觉会影响发挥，所以要求换了个前排座位。</p>
<p>写作两个题都很常规，但是我这次考试系统右边编辑器的宽度比之前熟悉的宽一点，写的词数不好估计，Issue
敲一下，写了三个中间段，然后没有像之前写文章的习惯一样一直回看前面的行文，一直在狂敲。我也不知道质量咋样，但应该写满了
400 词。Argument 写的中途发挥的反而没有 Issue
好，但所幸剩十分钟的时候又发现了一个大洞，多写了一段，差不多能够了。</p>
<p>写作完了企图调整心态迎接 Verbal，但是发现我是
QVQVQ，突然开心了一下。QVQVQ 好在写完第一个 V 休息，不用那么急着回来写
Q。但是我休息完吃完东西回来，休息时间还有 1 min。</p>
<p>Q 照常很简单，但是三个 Q 有一两个题似乎很有趣，卡了一下。我写 Q
比较细致，一般只留一遍检查的时间，比较休闲。</p>
<p>第一个 V
感觉词都认识，写完剩三分钟检查一下标的题，感觉应该没错多少。</p>
<p>第二个 V
只有一两个词不认识，但是填空逻辑和文章逻辑都有点绕，最后不太有时间检查。</p>
<p>考完 Report
成绩，系统告诉了你分数，163+170，我本来期望还能高一点的。依照经验，应该是第一个
Medium 难度错了一两个，然后第二个 Hard 错了七八个，唉。</p>
<p>最后让你选本科的院校，结果只有交大管理学院，那我就是管院人了<del>（误）</del>。然后选四个免费寄送的学校，我就选了几个牛逼学校吧。</p>
]]></content>
      <tags>
        <tag>随想</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 统计代码行数</title>
    <url>/2021/12/22/zh-CN/Git-%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    <content><![CDATA[<p>花了一周多，用 Verilog 写完一个 CPU（<a
href="https://github.com/James-Hen/HeliumCPUv2-MIPS32">Github
Repository:
HeliumCPUv2-MIPS32</a>），想看看自己究竟写了多少行，但是居然没有什么简单的做法。Github
也没有相关统计，怎么办呢？</p>
<p>查了查 Stackoverflow：<a
href="https://stackoverflow.com/questions/4822471/count-number-of-lines-in-a-git-repository">Count
number of lines in a git repository</a>，确实给了一些做法。然后我学了学
Bash 的一些用法，采用了下面的方法。</p>
<p>首先，<code>git ls-files</code> 会给出仓库里没有 Ignore
的文件，我们把它用管道和 <code>xargs</code> 传给
<code>wc</code>。<code>wc</code> 即 "Word Count"，<code>-l</code>
选项可以打印出行数；<code>xargs</code>
相当于将管道进来的输入作为命令行参数传给调用的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-files | xargs wc -l</span><br></pre></td></tr></table></figure>
<p>那么就可以得到一些结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   6 .gitignore</span><br><span class="line">  21 LICENSE</span><br><span class="line">  43 Makefile</span><br><span class="line"> 111 README.md</span><br><span class="line">1058 assets/MulticycleCounter.png</span><br><span class="line">   0 assets/PipelineCtrlHazard.drawio</span><br><span class="line"> 381 assets/PipelineCtrlHazard.drawio.png</span><br><span class="line">   0 assets/PipelineDataHazard.drawio</span><br><span class="line"> 376 assets/PipelineDataHazard.drawio.png</span><br><span class="line">   0 assets/PipelineDataPath.drawio</span><br><span class="line"> 272 assets/PipelineDataPath.drawio.png</span><br><span class="line">1512 assets/PipelineHazards.png</span><br><span class="line">1143 assets/SingleCycleCounter.png</span><br><span class="line">   0 assets/SingleCycleDataPath.drawio</span><br><span class="line"> 212 assets/SingleCycleDataPath.drawio.png</span><br><span class="line">  52 common/dbg_mems/dbg_dmem.v</span><br><span class="line">  26 common/dbg_mems/dbg_imem.v</span><br><span class="line">  53 common/dbg_mems/dbg_mem.v</span><br><span class="line"> 112 common/ex/alu.v</span><br><span class="line"> 348 common/id/control.v</span><br><span class="line"> </span><br><span class="line"> ... # Many lines omitted</span><br><span class="line"></span><br><span class="line">1024 sim/dmem.data</span><br><span class="line">  16 sim/imem.text</span><br><span class="line">  34 sim/testbench.v</span><br><span class="line">  31 single_cycle/counter.v</span><br><span class="line"> 155 single_cycle/cpu.v</span><br><span class="line">  41 single_cycle/top.v</span><br><span class="line">9179 total</span><br></pre></td></tr></table></figure>
<p>它几乎把所有的行数都统计进来了，其中也包括一些没忽略的生成的文件（如数据段
<code>dmem.data</code>），并不能算写的代码，那么，可以把
<code>git ls-files</code> 出来的结果再正则一下，比如只统计
<code>.v</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-files | grep <span class="string">&quot;.*\.v&quot;</span> | xargs wc -l</span><br></pre></td></tr></table></figure>
<p>输出就干净多了，数的行数也正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  52 common/dbg_mems/dbg_dmem.v</span><br><span class="line">  26 common/dbg_mems/dbg_imem.v</span><br><span class="line">  53 common/dbg_mems/dbg_mem.v</span><br><span class="line"> 112 common/ex/alu.v</span><br><span class="line"> 348 common/id/control.v</span><br><span class="line"> 142 common/id/decoder.v</span><br><span class="line">  54 common/id/regfile.v</span><br><span class="line">  38 common/if/pc.v</span><br><span class="line">  86 common/mem/mem.v</span><br><span class="line">  33 common/wb/writeback.v</span><br><span class="line"> 168 includes/defines.v</span><br><span class="line"> 132 multicycle/counter.v</span><br><span class="line"> 162 multicycle/cpu.v</span><br><span class="line">  41 multicycle/top.v</span><br><span class="line">  26 pipeline/control_regs.v</span><br><span class="line"> 295 pipeline/cpu.v</span><br><span class="line">  97 pipeline/forward.v</span><br><span class="line">  76 pipeline/hazard.v</span><br><span class="line">  41 pipeline/if.v</span><br><span class="line">  40 pipeline/top.v</span><br><span class="line">  26 pipeline_bp/control_regs.v</span><br><span class="line"> 318 pipeline_bp/cpu.v</span><br><span class="line">  97 pipeline_bp/forward.v</span><br><span class="line"> 118 pipeline_bp/hazard.v</span><br><span class="line">  97 pipeline_bp/if.v</span><br><span class="line">  40 pipeline_bp/top.v</span><br><span class="line">  34 sim/testbench.v</span><br><span class="line">  31 single_cycle/counter.v</span><br><span class="line"> 155 single_cycle/cpu.v</span><br><span class="line">  41 single_cycle/top.v</span><br><span class="line">2979 total</span><br></pre></td></tr></table></figure>
<p>我在 MacOS 得到的如上结果，Linux 的各发行版几乎都行，Windows
就乖乖使用 WSL 吧。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>下一步</title>
    <url>/2022/11/21/zh-CN/%E4%B8%8B%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>好久好久没有更新博客了，大概是因为最近完全没有学习（恼）。今年大四，九月初还在字节实习的时候就已经弄完了夏令营，待
28 号填完推免系统，基本是确定了 PKU
直博，做系统虚拟化方向，算是一件喜事。接下来，直到大四上学期快结束，除了健身也没做什么有意义的事，那就在这里忏悔一下。</p>
<p>推免系统关了，当时除了整活居然没截图，所以我失去了一份重要时刻的证明，那就放一张夏令营的截图吧。</p>
<figure>
<img src="/images/NextStep/PKUAdmissionSite.png"
alt="PKUAdmissionSite" />
<figcaption aria-hidden="true">PKUAdmissionSite</figcaption>
</figure>
<p>希望接下来能不断推动自己进步。</p>
<figure>
<img src="/images/NextStep/ReferralSite.jpg" alt="ReferralSite" />
<figcaption aria-hidden="true">ReferralSite</figcaption>
</figure>
]]></content>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>修好了公式乱码的问题</title>
    <url>/2023/02/15/zh-CN/%E4%BF%AE%E5%A5%BD%E4%BA%86%E5%85%AC%E5%BC%8F%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>去年有人反应我的博客公式炸了，我看了看是因为 <a
href="cdn.jsdelivr.net">jsdelivr</a>
炸了，我觉得总会好的，就没管。没想到 2023 年了，jsdelivr
还是炸的。查了查，看到是因为它在大陆的 ICP
认证到期了。现在不得不修了。</p>
<figure>
<img src="/images/FixMathjaxCDN/NetworkDebug.png" alt="NetworkDebug" />
<figcaption aria-hidden="true">NetworkDebug</figcaption>
</figure>
<p>简略讲一讲原理。我的博客渲染公式用了 MathJax，这是一个浏览器上运行的
Javascript
库。自然，作为库，可以不用在博客服务器上存着，而是需要的时候从别的地方得到。这样大家的网站就可以共享实时更新的库，节省各自的服务器空间和流量了。</p>
<p>那 MathJax 从哪来呢，一般是由博客网站指定一个提供者，提供者一般用
CDN（Content Delivery Network）发布资源。CDN
是一种分布式的内容发布系统，相当于在世界各地都存了一份资源，有人需要的时候就就近送达。之前
Hexo-Next 主题默认用的 jsdelivr。</p>
<p>现在必须找个替代了，我找到了字节的免费 CDN，<a
href="https://cdn.bytedance.com/">https://cdn.bytedance.com/</a>。也算用下老东家的东西。</p>
<p>接下来只需要在 Hexo 主题的 <code>_config.yml</code> 里，找到 CDN
的部分然后改成这样：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Script Vendors. Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># Be aware that you would better use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Remember to use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">  <span class="comment"># MathJax</span></span><br><span class="line">  <span class="comment"># mathjax: //cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js</span></span><br><span class="line">  <span class="attr">mathjax:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/3.2.0/es5/tex-mml-chtml.js</span></span><br></pre></td></tr></table></figure>
<p>不过字节 CDN 给的链接有 <code>expire-1-M</code>
的字样，难道每个月都要更新链接？先用着看看，反正现在是好了。</p>
<figure>
<img src="/images/FixMathjaxCDN/Fixed.png" alt="Fixed" />
<figcaption aria-hidden="true">Fixed</figcaption>
</figure>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本站</title>
    <url>/2021/10/11/zh-CN/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/</url>
    <content><![CDATA[<h2 id="站点">站点</h2>
<p>这是我的个人博客，在 2021 年 10
月上线并一直更新，一般会放一些课程的复习提纲（加上考砸的心情），也会放算法竞赛的题解（虽然要无牌退役了），和一些技术备忘录。希望能运行得好。</p>
<h2 id="关于多语言支持">关于多语言支持</h2>
<p>这是中文页面的主界面。由于 Hexo
的多语言支持尚未十分完善，目前许多内容仅以英文或中文呈现，我正在摸索更好的解决方案。</p>
<p>页面下方中英切换选项可以切换当前文章的中英翻译（如果有，否则会
404，请回退到主页）。</p>
]]></content>
  </entry>
  <entry>
    <title>写一个 CPU</title>
    <url>/2021/12/21/zh-CN/%E5%86%99%E4%B8%80%E4%B8%AA-CPU/</url>
    <content><![CDATA[<p>这是计算机组成课的实验项目，当然，也是学 CS
底层绕不过去的项目。我曾经试过一个 RISC-V 流水线 CPU 的实践，就跟着
Patterson 教授经典的教材 <a
href="https://www.elsevier.com/books/computer-organization-and-design-risc-v-edition/patterson/978-0-12-820331-6">Computer
Organization and Design RISC-V
Edition</a>，可惜当时动力不是十分充足，做的东西有点烂尾。我觉得到了需要做作业的时候，我大概就有动力了。</p>
<p>可惜 XJTU 的计组不出意料地食古不化，使用
MIPS。无所谓了，反正得写吧。做好的项目已经开源了，如果有小伙伴需要一点参考，那可以看看我是怎么组织这些
Verilog 代码的：</p>
<p><a href="https://github.com/James-Hen/HeliumCPUv2-MIPS32">Github
Repository: HeliumCPUv2-MIPS32</a></p>
<h2 id="文件目录描述">文件目录描述</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.                         # 根目录，包含 Makefile 等文件</span><br><span class="line">|-- common                # 三种 CPU 实现的通用元件</span><br><span class="line">|   |-- dbg_mems          # 仿真用存储器实例</span><br><span class="line">|   |-- ex                # 执行阶段元件，包括 ALU</span><br><span class="line">|   |-- id                # 解码阶段元件，包括解码器、控制器</span><br><span class="line">|   |-- if                # 取值阶段元件</span><br><span class="line">|   |-- mem               # 访存阶段元件</span><br><span class="line">|   `-- wb                # 写回阶段元件</span><br><span class="line">|-- includes              # 宏定义，用于指令集架构描述</span><br><span class="line">|-- multicycle            # 多周期特殊实现</span><br><span class="line">|-- pipeline              # 流水线特殊实现，包括级间寄存与冒险控制</span><br><span class="line">|-- pipeline_bp           # 带分支预测的流水线实现</span><br><span class="line">|-- sim                   # 模拟目录，包括 Testbench 和测试用汇编代码</span><br><span class="line">|   `-- MIPS_sample_src   # 测试用汇编代码目录</span><br><span class="line">`-- single_cycle          # 单周期特殊实现</span><br></pre></td></tr></table></figure>
<h2 id="准备环境">准备环境</h2>
<p>老师提供的是一个古早版本的 Modelsim，在 Win7 安装才不会出 bug
的那种。说实话，我不想用。有更多的好用或免费的解决方案放在这里呢：</p>
<ul>
<li><a href="https://www.veripool.org/verilator/">Verilator</a></li>
<li><a href="http://iverilog.icarus.com/">Icarus Verilog</a></li>
<li><a
href="https://eda.sw.siemens.com/en-US/ic/modelsim/">Modelsim</a></li>
<li><a
href="https://china.xilinx.com/products/design-tools/vivado.html">Vivado</a></li>
<li><a
href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a></li>
</ul>
<p>笔者使用的是 Icarus Verilog，它比较简单；Verilator
也非常不错，可以使用 C++ 写 Testbench。如果想要
IDE，或者买了赛灵思的板子，那推荐使用 Verilator，也是免费的。</p>
<p>Icarus Verilog 是命令行工具，配合 VSCode 使用很香。VSCode
还有查看波形的插件 <a
href="https://www.wavetrace.io/">WaveTrace</a>，但超过 8
个波形要收费，如果有需求可以使用 <a
href="http://gtkwave.sourceforge.net/">GTKWave</a>。至于怎么安装这些环境，以及怎么跑通我的代码，在
Github 的仓库中有说明。</p>
<h2 id="一步一步来">一步一步来</h2>
<h3 id="小目标">小目标</h3>
<p>事实上略有点一步登天，但是直接支持多一点指令，能够提前想好奇怪的数据通路，比先实现一个小的指令集再大修大改要优雅。考虑支持下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`R_TYPE: (18)</span><br><span class="line">    `ADD, `ADDU, `SUB, `SUBU,</span><br><span class="line">    `AND, `OR, `XOR, `NOR,</span><br><span class="line">    `SLT, `SLTU, `SLL, `SRA, `SRL,</span><br><span class="line">    `SLLV, `SRAV, `SRLV:</span><br><span class="line">    `JALR, `JR:</span><br><span class="line">`I_TYPE: (22)</span><br><span class="line">    `LB, `LBU, `LH, `LHU, `LW:</span><br><span class="line">    `SB, `SH, `SW:</span><br><span class="line">    `ADDI, `ADDIU, `ANDI, `ORI, `XORI:</span><br><span class="line">    `SLTI, `SLTIU:</span><br><span class="line">    `LUI:</span><br><span class="line">    `BEQ, `BNE:</span><br><span class="line">    `BLEZ, `BGTZ, `BGEZ_BLTZ:</span><br><span class="line">`J_TYPE: (2)</span><br><span class="line">    `J, `JAL:</span><br></pre></td></tr></table></figure>
<p>Verilog 的宏就需要使用符号 ` 开头，所以这也是我在
<code>defines.v</code> 中说明的方法。</p>
<p>MIPS-32 的指令集分为三种：R 型，I 型和 J 型。R 型指令一般有
<code>op_code</code>，<code>rs</code>，<code>rt</code>，<code>rd</code>，<code>funct</code>
这么几个有用的字段（具体的请参照指令集手册）。I 型顾名思义，没有
<code>rd</code> 和 <code>funct</code>，取而代之的是 16 位的立即数
<code>imm</code>。至于 <code>J</code> 型，除了
<code>op_code</code>，剩下的所有位都是目的地址。</p>
<p>现在设计解码器和控制器为时尚早，只是了解一下有什么东西会进来，可以先从简单的开始。</p>
<p>先参照一下别人设计的数据通路图（比如书上的），或者我的：</p>
<figure>
<img src="/images/WriteCPU/SingleCycleDataPath.drawio.png"
alt="SingleCycleDataPath.drawio" />
<figcaption aria-hidden="true">SingleCycleDataPath.drawio</figcaption>
</figure>
<p>嗯，只是为了看看有什么元件，然后一个一个写。</p>
<h3 id="各个模块">各个模块</h3>
<h4 id="alu">ALU</h4>
<p>事实上，要是不实现乘法，ALU 是最简单的部件，只需要 Case
语句即可，剩下的操作 Verilog 都直接提供了。</p>
<h4 id="alu-mux">ALU MUX</h4>
<p>要想想为什么设计成这样：ALU 的两个 OP
可以有一些不同的来源，在我这里，它们可以是 PC（为了 JALR,
JAL）；可以是立即数；可以是寄存器值。</p>
<h4 id="regfile">REGFILE</h4>
<p>就是很多寄存器存储的地方，顺便解决一下上升沿写入，读出的问题。为了方便，我的读出甚至是组合逻辑。</p>
<h4 id="mem">MEM</h4>
<p>又称 Memory
Access，做的主要工作是处理读字、读半字、读字节的琐事，剩下的交给“内存”就好了。</p>
<h4 id="pc">PC</h4>
<p>除了每回合自增 4，这个 PC 模块还需要处理取指令，以及跳转。</p>
<h4 id="imem-dmem">IMEM &amp; DMEM</h4>
<p>由于是仿真，不需要接上 FPGA 跑，就和寄存器堆差不多实现就可以了。</p>
<h4 id="decode-control">DECODE &amp; CONTROL</h4>
<p>这是最难解决的一部分，也是最能体现设计的一部分，你需要根据指令生成控制信号，耐心些吧。</p>
<h4 id="wb">WB</h4>
<p>事实上只是一个 MUX，控制把什么写回寄存器堆。</p>
<h4 id="counter">COUNTER</h4>
<p>是一个计数器，用来产生各个 Stage 的时钟信号。</p>
<h3 id="连线">连线</h3>
<p>我建议每写一个模块，就把线连出来，这样，写完的时候，线也连好了，几乎就可以测试了！</p>
<h2 id="高级的版本">高级的版本</h2>
<p>上面只是实现了一个单周期的
CPU，每五个周期做完一条指令。但是做的时候就考虑的流水，所以写模块的时候已经为直接用于流水优化了。</p>
<p>我做了多周期和五级流水，可以前往 Github 看看通路和结果！</p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>rCoreOS Tutorial 学习笔记</title>
    <url>/2023/03/07/zh-CN/rCoreOS-Tutorial-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>由于需要做操作系统的工作，但是只上了比较没用的西交理论课，于是我不会
OS 开发（暂时）。组里推荐了清华课用的
rCoreOS，于是自学并尝试做一些作业。</p>
<p>主要跟着 rCoreOS Tutorial 的在线书学习，如果有一定 CS 理论知识基础和
Rust 基础，学起来应该很轻松。如果会用 C 做内核开发但是不会
Rust，这本书也是不错的 Rust 内核（从零）开发的教程。还有就是，本书跟
Linux 没什么关系，不需要很会。</p>
<p>Repo: <a
href="https://github.com/rcore-os/rCore-Tutorial-v3">rCore-Tutorial-v3</a></p>
<p>Book: <a
href="http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book-v3</a></p>
<p>在线书已经写的比较新手友好了，参考答案也存在，但是不全，并且实验也有一些不大的坑，或者书和代码有出入。我觉得写这篇文章可以帮助你更快搞定一些没详细写到的内容，于是分享此笔记。先看书，要做实验的时候可以看看这个。</p>
<p>我在 2023
年二月份进行的学习，目前这个课程的材料仍在不断更新，所以以下内容也仅供参考。</p>
<h2 id="第零章">第零章</h2>
<p>第零章如果理论学过了大可不细看，仅搭环境即可。</p>
<p>我用的老师的 x86 Ubuntu 服务器。VSCode SSH 连接 Remote
开发。编译运行的时候直接用 Docker
环境，省去很多麻烦。本地也可以复用这套环境。Clone 仓库后进入目录即可
Make Docker 镜像。</p>
<p>这个 Docker 镜像<strong>只</strong>包括了运行需要的 QEMU
7.x.x，编译需要的 Rust 和 C
工具链。课程的框架代码不在镜像里。镜像里面也没有 RISCV
GDB，所以需要自行下载，并修改一下 Dockerfile 加入 GDB，再构建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download the rCoreOS repository</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3</span><br><span class="line"><span class="built_in">cd</span> rCore-Tutorial-v3</span><br><span class="line"><span class="comment"># Download RISCV toolchain</span></span><br><span class="line">wget https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.12/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14.tar.gz</span><br></pre></td></tr></table></figure>
<p>接下来修改 Dockerfile。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 4. Download and add RISCV Toolchain</span></span><br><span class="line"><span class="keyword">ARG</span> RV_TOOLCHAIN=riscv64-unknown-elf-toolchain-<span class="number">10.2</span>.<span class="number">0</span>-<span class="number">2020.12</span>.<span class="number">8</span>-x86_64-linux-ubuntu14</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="variable">$&#123;RV_TOOLCHAIN&#125;</span>.tar.gz .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cp -r <span class="variable">$&#123;RV_TOOLCHAIN&#125;</span>/* . &amp;&amp; rm -r <span class="variable">$&#123;RV_TOOLCHAIN&#125;</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;HOME&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>或者可以直接在 Dockerfile 里下载解压。</p>
<p>如果是 M1 的 Mac，需要自己编译 aarch64 的 Toolchain。（我失败了，QEMU
还是不能正确运行）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4. Download and install rv toolchain</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;HOME&#125;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/riscv/riscv-gnu-toolchain</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;HOME&#125;</span>/riscv-gnu-toolchain</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    make linux</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;HOME&#125;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf riscv-gnu-toolchain</span></span><br></pre></td></tr></table></figure>
<p>可以 Dockerfile 配置一下 crates.io 的换源。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.3. Rust src mirror</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CARGO_CONF=<span class="variable">$CARGO_HOME</span><span class="string">&#x27;/config&#x27;</span>; \</span></span><br><span class="line"><span class="bash">    BASHRC=<span class="string">&#x27;/root/.bashrc&#x27;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export RUSTUP_DIST_SERVER=https://rsproxy.cn&#x27;</span> &gt;&gt; <span class="variable">$BASHRC</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export RUSTUP_UPDATE_ROOT=https://rsproxy.cn/rustup&#x27;</span> &gt;&gt; <span class="variable">$BASHRC</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; touch <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;[source.crates-io]&#x27;</span> &gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;replace-with = &#x27;rsproxy-sparse&#x27;&quot;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;[source.rsproxy]&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;registry = &quot;https://rsproxy.cn/crates.io-index&quot;&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;[source.rsproxy-sparse]&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;registry = &quot;sparse+https://rsproxy.cn/index/&quot;&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;[registries.rsproxy]&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;index = &quot;https://rsproxy.cn/crates.io-index&quot;&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;[net]&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;git-fetch-with-cli = true&#x27;</span> &gt;&gt; <span class="variable">$CARGO_CONF</span></span></span><br></pre></td></tr></table></figure>
<p>我构建镜像的时候 QEMU 官方下载炸了，我用的 <a
href="https://fossies.org/linux/misc/qemu-7.2.0.tar.xz">https://fossies.org/linux/misc/qemu-7.2.0.tar.xz</a>。</p>
<p>Dockerfile 里还有一句
<code>cargo install cargo-binutils -vers ~0.2 &amp;&amp; \</code>，会强制版本，可以删掉。如果不删掉，Rust
版本会变成老版本。</p>
<p>改完然后构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make build_docker</span><br></pre></td></tr></table></figure>
<p>仓库根目录自带的 Makefile 写了使用 Docker
镜像的命令，即在根目录用命令 <code>sudo make docker</code>
运行镜像。但是我这里在 Make 时没有 <code>$PWD</code> 环境变量，所以把
Makefile 改成下面这样就能跑了。这个问题在 ch2
及以后的有些分支修掉了，但是有可能 <code>DOCKER_NAME</code>
不对，需要注意。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">docker:</span></span><br><span class="line">	docker run --rm -it -v `pwd`:/mnt -w /mnt $&#123;DOCKER_NAME&#125; bash</span><br></pre></td></tr></table></figure>
<p>这条命令会将 Docker 环境里 <code>mnt</code>
目录和仓库根目录做映射，这样能持久化你的改动，不用让容器一直跑或者担心保存的问题。</p>
<p>调试的时候需要在容器内使用多个命令行，我不喜欢用 tmux（<del>VSCode
用户是这样的</del>），所以可以打开另一个命令行再开启 Docker 的另一个
bash 进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it <span class="variable">$&#123;CONTAINER_NAME&#125;</span> bash</span><br></pre></td></tr></table></figure>
<p>这里的 <code>CONTAINER_NAME</code> 可以用 <code>sudo docker ps</code>
发现，然后换上去。验证这个搞法，可以试试在同一个容器的两个 Bash
里，<code>cd os</code>，一个跑 <code>make gdbserver</code>，一个跑
<code>make gdbclient</code>。</p>
<h2 id="第一章">第一章</h2>
<h3 id="内核第一条指令实践篇">内核第一条指令（实践篇）</h3>
<p>如果搭环境的时候能调试了，那么确实可以看见 QEMU 启动固件的代码，位于
<code>0x1000</code>。我的结果和书上不太一致，但差不多，应该是 QEMU
更新了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      addi    a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure>
<p>作为有兴趣的同学，会知道 <code>auipc t0,0x0</code> 将 PC
的值（加零后）放入通用寄存器 t0。<code>mhartid</code>
寄存器表示运行当前代码的硬件线程（hart）的 ID。<code>csrr</code>
是伪指令，专门用来读 m 开头的特权寄存器。<code>0x100c</code> 处的
<code>ld</code> 指令做 <code>a1 &lt;- $(t0 + 32)</code>，并且
<code>t0 + 32 = 0x1000 + 0x20 = 0x1020</code>。</p>
<p>看看 <code>0x1020</code> 是啥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/1xw 0x1020</span><br><span class="line">0x1020: 0x87000000</span><br></pre></td></tr></table></figure>
<p>那同理，对于 <code>0x1010</code> 处的 <code>ld</code>
指令，<code>t0 + 24 = 0x1018</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/1xw 0x1018</span><br><span class="line">0x1018: 0x80000000</span><br></pre></td></tr></table></figure>
<p>嗯，虽然新加进来的东西不懂，但是 <code>0x80000000</code> 是
bootloader 初始地址，理解了。</p>
<h3 id="编程练习">编程练习</h3>
<blockquote>
<ol start="3" type="1">
<li>** 实现一个基于rcore/ucore
tutorial的应用程序C，用sleep系统调用睡眠5秒（in rcore/ucore tutorial v3:
Branch ch1）</li>
</ol>
</blockquote>
<p><strong>这题别看我的答案，审题错误，一坨答辩。</strong></p>
<p>这个练习没有答案，但是若要实现得好感觉比第二题还难，因为必须考虑 Trap
了。当然，死循环然后检查时间也不是不行吧，毕竟独占 CPU。</p>
<p>若是读一下后面的实现，会发现 <code>sys_sleep</code>
系统调用没有直接用硬件
timer，而是用的内核的计时器堆。那么我就尝试实现一下用硬件 timer 的
<code>ksleep</code> 好了。原理是先
<code>sbi::set_timer()</code>，再死循环等 Trap。</p>
<p>先实现 <code>set_timer()</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sbi.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> SBI_SET_TIMER: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// use sbi call to set a timer</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要让内核能处理 Trap，在 ch2 分支才会实现 Trap 处理，需要把
<code>mod trap</code> 拷过来，并增加 SupervisorTimer
的处理。为了理解这部分的内容，需要先学习第二章。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">use</span> riscv::register::&#123;</span><br><span class="line">    mtvec::TrapMode,</span><br><span class="line">    scause::&#123;<span class="keyword">self</span>, Exception, Trap, Interrupt&#125;,</span><br><span class="line">    stval, stvec, sstatus, sie</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::write(__alltraps <span class="keyword">as</span> <span class="built_in">usize</span>, TrapMode::Direct);</span><br><span class="line">        sstatus::set_sie();</span><br><span class="line">        sie::set_stimer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>(cx: &amp;<span class="keyword">mut</span> TrapContext) -&gt; &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        Trap::Interrupt(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Got timer interruption.&quot;</span>);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; TIMER_TRAPPED = <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现 <code>ksleep()</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> riscv::register::&#123; time &#125;;</span><br><span class="line"><span class="keyword">const</span> CLOCK_FREQ: <span class="built_in">usize</span> = <span class="number">12500000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> TIMER_TRAPPED: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">use</span> crate::sbi::set_timer;</span><br><span class="line"><span class="comment">/// the kernel sleep function, t in milliseconds</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ksleep</span></span>(t: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = time::read();</span><br><span class="line">    <span class="keyword">let</span> fut = cur + CLOCK_FREQ * t / <span class="number">1000</span>;</span><br><span class="line">    set_timer(fut);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] current time &#123;&#125;, timer at &#123;&#125;.&quot;</span>, cur, fut);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] timer set in sleep(), busy looping.&quot;</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> !TIMER_TRAPPED &#123;&#125;</span><br><span class="line">        TIMER_TRAPPED = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完事了在 <code>rust_main()</code> 调用下试试就好了。记得先调用
<code>trap::init()</code>。最后还没调出来，可以 Trap
但无法正确返回，先进行到下一章好了。</p>
<h2 id="第二章">第二章</h2>
<h3 id="实验练习">实验练习</h3>
<blockquote>
<p>ch2 中，我们实现了第一个系统调用
<code>sys_write</code>，这使得我们可以在用户态输出信息。但是 os
在提供服务的同时，还有保护 os
本身以及其他用户程序不受错误或者恶意程序破坏的功能。</p>
<p>由于还没有实现虚拟内存，我们可以在用户程序中指定一个属于其他程序字符串，并将它输出，这显然是不合理的，因此我们要对
sys_write 做检查：</p>
<ul>
<li>sys_write 仅能输出位于程序本身内存空间内的数据，否则报错。</li>
</ul>
</blockquote>
<p>测试样例在 <code>user/src/bin</code> 下，有两个 test。这两个 test
会被编译成二进制然后载入进批处理系统里。需要注意的是，输入不支持的 fd
需要返回 -1 而不是 panic，不然过不了。</p>
<p>不太难（<del>虽然我有一段时间搞不清楚 APP
加载到哪个地址去了</del>），主要代码如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/syscall/fs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::batch::&#123; USER_STACK, USER_STACK_SIZE, APP_BASE_ADDRESS, APP_SIZE_LIMIT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_write</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="comment">// checking the sanity of the buffer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> good: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// if in stack</span></span><br><span class="line">        <span class="keyword">if</span> USER_STACK.data.as_ptr() &lt;= buf &amp;&amp; buf.add(len) &lt;=</span><br><span class="line">      			USER_STACK.data.as_ptr().add(USER_STACK_SIZE) &#123;</span><br><span class="line">            good = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if in allocated static app memory (.data etc)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span> &lt;= buf</span><br><span class="line">            &amp;&amp; buf.add(len) &lt;=</span><br><span class="line">      			(APP_BASE_ADDRESS + APP_SIZE_LIMIT) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">            good = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !good &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> fd &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>还需要把 <code>src/batch.rs</code> 里该 pub 的变量 pub
了，然后再改下用户栈大小到 <code>0x1000</code>。</p>
<p>运行 <code>make run TEST=1</code> 正确的输出应该是这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kernel] Hello, world!</span><br><span class="line">[kernel] num_app = 2</span><br><span class="line">[kernel] app_0 [0x8020a020, 0x8020f558)</span><br><span class="line">[kernel] app_1 [0x8020f558, 0x80214b60)</span><br><span class="line">[kernel] Loading app_0</span><br><span class="line">Test write0 OK!</span><br><span class="line">[kernel] Application exited with code 0</span><br><span class="line">[kernel] Loading app_1</span><br><span class="line">string from data section</span><br><span class="line">strinstring from stack section</span><br><span class="line">strin</span><br><span class="line">Test write1 OK!</span><br><span class="line">[kernel] Application exited with code 0</span><br></pre></td></tr></table></figure>
<h2 id="第三章">第三章</h2>
<h3 id="课后练习">课后练习</h3>
<p>一、二、四题都跟实验差不多，于是不想做了。我倒是对浮点实现、内核态中断和内核任务有点兴趣，先挖坑。</p>
<h4 id="浮点扩展">3. 浮点扩展</h4>
<p>先扩展 <code>TaskContext</code>，参考 <a
href="https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf">RISCV
Calling Convention</a>，需要保存的浮点寄存器是
<code>fs0-fs11</code>，和整数类似，那么先在 <code>TaskContext</code>
留出对应空间。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Task Context</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line">    <span class="comment">/// return address ( e.g. __restore ) of __switch ASM function</span></span><br><span class="line">    ra: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">/// kernel stack pointer of app</span></span><br><span class="line">    sp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">/// callee saved registers:  s 0..11</span></span><br><span class="line">    s: [<span class="built_in">usize</span>; <span class="number">12</span>],</span><br><span class="line">    <span class="comment">/// callee saved fp registers: fs 0-11</span></span><br><span class="line">    fs: [fsize; <span class="number">12</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那个 <code>fsize</code> 不是 Rust 标准里的东西，是我在
<code>config.rs</code> 里写的，因为 RISCV
里所有浮点寄存器的长度取决于扩展，RV64F 的话对应 <code>f32</code>，RV64D
对应 <code>f64</code>。</p>
<p>再尝试修改 <code>switch.S</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.attribute arch, &quot;rv64gc&quot;</span><br><span class="line"># ...</span><br><span class="line">.macro SAVE_FSN n</span><br><span class="line">    fsd fs\n, (\n+14)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_FSN n</span><br><span class="line">    fld fs\n, (\n+14)*8(a1)</span><br><span class="line">.endm</span><br><span class="line"># ...</span><br><span class="line"># save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        SAVE_FSN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        LOAD_FSN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p>第一行不加的话汇编器会报错，不知为什么不是
<code>"rv64d"</code>，但是这样就好了。</p>
<p><code>TrapContext</code> 也差不多，只不过需要保存
<code>f0-f31</code>，不再赘述了。</p>
<p>到这里还是会出问题，直接抛了 Bad Instruction。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kernel] Hello, world!</span><br><span class="line">[kernel] PageFault in application, bad addr = 0xfffffffffffffef8, bad instruction = 0x80200536, kernel killed it.</span><br></pre></td></tr></table></figure>
<p>到 GDB 里调出来抛异常的点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x802003ec &lt;__switch+8&gt;:     sd      s0,16(a0)</span><br><span class="line">   0x802003ee &lt;__switch+10&gt;:    fsd     fs0,112(a0)</span><br><span class="line">   0x802003f0 &lt;__switch+12&gt;:    sd      s1,24(a0)</span><br><span class="line">   0x802003f2 &lt;__switch+14&gt;:    fsd     fs1,120(a0)</span><br><span class="line">   0x802003f4 &lt;__switch+16&gt;:    sd      s2,32(a0)</span><br></pre></td></tr></table></figure>
<p>确切位置是在 <code>0x802003ee</code> 的 <code>fsd</code>
指令。确认这些指令完全正确没问题，那问题在哪。</p>
<p>不得不借鉴下 Linux 源码怎么处理的了，看到 <a
href="https://github.com/torvalds/linux/blob/89f5349e0673322857bd432fa23113af56673739/arch/riscv/kernel/process.c#L114">arch/riscv/kernel/process.c</a>
我悟了，需要设置 <code>sstatus</code> 寄存器 <code>SR_FS_INITIAL</code>
位才能正常使用浮点指令，于是乎在合适的位置加入</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123; sstatus::set_fs(sstatus::FS::Initial); &#125;</span><br></pre></td></tr></table></figure>
<p>即可，由于干作业越糙越好，就直接在 <code>main</code>
搞初始化的时候开启了。</p>
<p>测试的话，直接让第一个程序算 <span
class="math inline">\(1.0001^{(10^6)}\)</span>，它会最后一个完成，然后算出来一个精度烂掉的正确结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">power_3 [980000/1000000]</span><br><span class="line">power_3 [990000/1000000]</span><br><span class="line">power_3 [1000000/1000000]</span><br><span class="line">1.0001^1000000 = 26747109931126675000000000000000000000000000</span><br><span class="line">Test power_3 OK!</span><br><span class="line">[kernel] Application exited with code 0</span><br><span class="line">Test sleep OK!</span><br><span class="line">[kernel] Application exited with code 0</span><br><span class="line">All applications completed!</span><br></pre></td></tr></table></figure>
<h3 id="实验练习-1">实验练习</h3>
<p>实验需要实现系统调用
<code>sys_task_info</code>。实现没什么弯弯绕的，就是记录数据然后给出数据即可，难度不高。</p>
<h4 id="记录数据">记录数据</h4>
<p>记录数据可以在 <code>TaskControllBlock</code>
中进行，我增加的字段如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">--- a/os/src/task/task.rs</span><br><span class="line">+++ b/os/src/task/task.rs</span><br><span class="line"></span><br><span class="line"> <span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">     <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">     <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">+    <span class="keyword">pub</span> call_cnt: <span class="built_in">usize</span>,</span><br><span class="line">+    <span class="keyword">pub</span> call: [SyscallInfo; MAX_SYSCALL_NUM],</span><br><span class="line">+    <span class="comment">// the timestamp in ms of the start time if running</span></span><br><span class="line">+    <span class="keyword">pub</span> last_start: <span class="built_in">usize</span>,</span><br><span class="line">+    <span class="comment">// total run time in ms</span></span><br><span class="line">+    <span class="keyword">pub</span> run_time: <span class="built_in">usize</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>两个 call
相关的字段记录系统调用和总数量，由于没有内核堆，所以就是个数组。最大系统调用数量写到
<code>config.rs</code> 里了。<code>last_start</code>
字段记录进入运行状态的时刻，用于在进入挂起或退出状态时统计时间。为了上面的代码，需要增加一些初始化，编译器会教你怎么改。</p>
<p>记录系统调用的接口放在 <code>TaskManager</code> 里。当
<code>syscall</code> 函数被调用的时候就调用这个方法即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/task/mod.rs</span></span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/// Recording sys_task_info, called when syscall called</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">record_current_syscall</span></span>(&amp;<span class="keyword">self</span>, syscall_id: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> current = inner.current_task;</span><br><span class="line">        <span class="keyword">let</span> cur_task = &amp;<span class="keyword">mut</span> inner.tasks[current];</span><br><span class="line">        <span class="keyword">for</span> ci <span class="keyword">in</span> &amp;<span class="keyword">mut</span> cur_task.call &#123;</span><br><span class="line">            <span class="keyword">if</span> ci.id == <span class="number">0</span> &#123;</span><br><span class="line">                ci.id = syscall_id;</span><br><span class="line">                ci.times = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ci.times += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录时间，则在
<code>run_first_task</code>，<code>run_next_task</code> 加入这句话。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">next_task.last_start = get_time_ms();</span><br></pre></td></tr></table></figure>
<p>并在
<code>mark_current_suspended</code>，<code>mark_current_exited</code>
加入这句话。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cur_task.run_time += get_time_ms() - cur_task.last_start;</span><br></pre></td></tr></table></figure>
<p>注意在 <code>run_next_task</code> 里不要增加
<code>run_time</code>，不然就重复了。</p>
<h4 id="给出数据">给出数据</h4>
<p>给出数据即实现系统调用。首先还是先把接口放 <code>TaskManager</code>
里，然后实现 <code>syscall</code> 的时候调用 <code>TaskManager</code>
的方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">		<span class="comment">/// Implementation of sys_task_info</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_task_info</span></span>(&amp;<span class="keyword">self</span>, id: <span class="built_in">usize</span>) -&gt; <span class="built_in">Option</span>&lt;TaskInfo&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> tm = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> ts = TaskInfo &#123;</span><br><span class="line">            id: id,</span><br><span class="line">            status: tm.tasks[id].task_status,</span><br><span class="line">            call: tm.tasks[id].call,</span><br><span class="line">            time: tm.tasks[id].run_time</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="literal">Some</span>(ts)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用了 <code>core::option::Option</code>
来避免在代码里传入指针获得结果，只有在接口这么干。更 “Rusty”。</p>
<p>在内核中的接口如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"><span class="comment">/// get info of a task</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_task_info</span></span>(id: <span class="built_in">usize</span>, ts: *<span class="keyword">mut</span> TaskInfo) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(res) = TASK_MANAGER.get_task_info(id) <span class="keyword">else</span> &#123; <span class="keyword">return</span> -<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; *ts = res; &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/syscall/mod.rs</span></span><br><span class="line"><span class="comment">/// handle syscall exception with `syscall_id` and other arguments</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">syscall</span></span>(syscall_id: <span class="built_in">usize</span>, args: [<span class="built_in">usize</span>; <span class="number">3</span>]) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    TASK_MANAGER.record_current_syscall(syscall_id);</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; sys_write(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; sys_exit(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">i32</span>),</span><br><span class="line">        SYSCALL_YIELD =&gt; sys_yield(),</span><br><span class="line">        SYSCALL_GET_TIME =&gt; sys_get_time(),</span><br><span class="line">        SYSCALL_TASK_INFO =&gt; sys_task_info(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">mut</span> TaskInfo),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_task_info</code> 实现用了一个 Rust <code>let_else</code>
的不稳定特性，但是好用，以后会稳定的。现在用需要打开
<code>#[feature(let_else)]</code>。</p>
<p>在用户程序库中的接口如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_task_info</span></span>(id: <span class="built_in">usize</span>, ts: *<span class="keyword">mut</span> TaskInfo) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_TASK_INFO, [id, ts <span class="keyword">as</span> <span class="built_in">usize</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">task_info</span></span>(id: <span class="built_in">usize</span>, ts: *<span class="keyword">mut</span> TaskInfo) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    sys_task_info(id, ts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还省略了不少“过编译”的代码，包括各种
<code>use</code>，各种没声明过的 struct
和初始化，以及各种语言修饰，编译器都会教你怎么弄，Rust 就好在这里。</p>
<h4 id="测试与结果">测试与结果</h4>
<p>我在第三个测测试快要完成时查询所有 task
的信息并全部输出，代码如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/bin/03sleep.rs</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ti = TaskInfo &#123; id: <span class="number">0</span>, status: TaskStatus::UnInit, call: [SyscallInfo &#123;id: <span class="number">0</span>, times: <span class="number">0</span>&#125;; <span class="number">10</span>], time: <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> task_info(id, &amp;<span class="keyword">mut</span> ti) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Info of task &#123;&#125; is:\n    &#123;:?&#125;&quot;</span>, id, ti);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Task info query for task &#123;&#125; failed!&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里输出需要各种 struct 实现 Debug
Trait，加个修饰就好了。另外没有去实现 <code>TaskInfo</code>
默认初始化，所以比较丑，摸了。输出如下，省略了一些为空的
<code>call</code> 项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Info of task 0 is:</span><br><span class="line">    TaskInfo &#123; id: 0, status: Exited, call: [SyscallInfo &#123; id: 64, times: 110 &#125;, SyscallInfo &#123; id: 0, times: 0 &#125;, SyscallInfo &#123; id: 0, times: 0 &#125;, SyscallInfo &#123; id: 0, times: 0 &#125;, ...], time: 6 &#125;</span><br><span class="line">Info of task 1 is:</span><br><span class="line">    TaskInfo &#123; id: 1, status: Exited, call: [SyscallInfo &#123; id: 64, times: 80 &#125;, ...], time: 5 &#125;</span><br><span class="line">Info of task 2 is:</span><br><span class="line">    TaskInfo &#123; id: 2, status: Exited, call: [SyscallInfo &#123; id: 64, times: 90 &#125;, ...], time: 4 &#125;</span><br><span class="line">Info of task 3 is:</span><br><span class="line">    TaskInfo &#123; id: 3, status: Running, call: [SyscallInfo &#123; id: 169, times: 1635571 &#125;, ...], time: 2726 &#125;</span><br><span class="line">Task info query for task 4 failed!</span><br></pre></td></tr></table></figure>
<p>都挺合理，但是记录毫秒显然有累计误差，建议记录时钟，能准确不少。</p>
<h2 id="第四章">第四章</h2>
<h3 id="课后练习-1">课后练习</h3>
<p>咕咕咕</p>
<h3 id="实践作业">实践作业</h3>
<h4 id="重写-sys_get_time">重写 sys_get_time</h4>
<p>原来的还是能用的，但是改了个签名就不能用了。实际上，所有把结果写回用户地址空间内存以及读用户地址空间内存的方法都要重写。还很麻烦。并且教程里对
<code>sys_write</code> 的实现也是有 bug 的，UTF-8 是变长编码，buffer
跨页并且非英文字符跨页了就可能会炸。不过好在问题也不太大。</p>
<p>还有就是，ch4-lab 分支编译不了，因为引用的 rCore 版本的 riscv crate
炸了。那就写点代码装装样子。（这个问题我在做下一章作业的时候自己修了，看下一章实践作业）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_get_time</span></span>(_ts: *<span class="keyword">mut</span> TimeVal, _tz: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> us = get_time_us();</span><br><span class="line">  	<span class="keyword">let</span> result = TimeVal &#123;</span><br><span class="line">        sec: us / <span class="number">1_000_000</span>,</span><br><span class="line">        usec: us % <span class="number">1_000_000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  	<span class="keyword">let</span> sz = size_of::&lt;TimeVal&gt;();</span><br><span class="line">    <span class="keyword">let</span> buffers = translated_byte_buffer(current_user_token(), _ts, sz);</span><br><span class="line">  	<span class="keyword">match</span> buffers.len() &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                *(buffers[<span class="number">0</span>].as_ptr() <span class="keyword">as</span> *<span class="keyword">mut</span> TimeVal) = result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      	<span class="number">2</span> =&gt; &#123;</span><br><span class="line">			      <span class="comment">// crazy enough</span></span><br><span class="line">          	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">			          <span class="keyword">let</span> rs = std::slice::from_raw_parts(</span><br><span class="line">			              &amp;result <span class="keyword">as</span> *<span class="keyword">const</span> TimeVal <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>, sz);</span><br><span class="line">              	<span class="keyword">let</span> l0 = buffers[<span class="number">0</span>].len();</span><br><span class="line">              	buffers[<span class="number">0</span>].copy_from_slice(&amp;rs[<span class="number">0</span>..l0]);</span><br><span class="line">              	buffers[<span class="number">1</span>].copy_from_slice(&amp;rs[l0..sz]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      	_ =&gt; &#123; <span class="built_in">panic!</span>(<span class="string">&quot;size_of(TimeVal) larger than a page!&quot;</span>); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a
href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=918534834ee594b6619c3ebb0e590a3c">Rust
Playground</a> 测试了一下，没问题。其实也可以改成循环然后支持返回 buffer
跨很多页的情况，但是这种情况也太恐怖了。</p>
<h4 id="mmap-和-munmap">mmap 和 munmap</h4>
<p>实现这一对调用最难顶的问题是：</p>
<ol type="1">
<li>如果 <code>mmap</code>
了两个相邻的段，应该把这两个段合并为一个段；</li>
<li>如果地址得当，一次 <code>munmap</code> 可以取消多次
<code>mmap</code> 形成的映射；</li>
<li><code>munmap</code> 可以只取消一部分映射，剩下头尾仍需要映射。</li>
</ol>
<p>因为我懒死了，所以假设上面的问题都不存在好了，能过测试用例谢天谢地。可以假设如果操作得当，<code>mmap</code>
和 <code>munmap</code> 是一一对应的。如果没有这样的假设，那就不能用
<code>Vec</code> 装 <code>MapArea</code> 了，得用
<code>BTreeMap</code>。</p>
<p>继续写点代码装装样子。<code>MemorySet</code>
里需要实现一个检查是否已映射的函数，和根据范围取消包含它的映射的函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">range_has_mapped</span></span>(&amp;<span class="keyword">self</span>, start: VirtPageNum, end: VirtPageNum) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="comment">// check overlap</span></span><br><span class="line">        <span class="keyword">self</span>.areas.iter_mut()</span><br><span class="line">            .find(|area| area.vpn_range.get_start() &lt; end &amp;&amp;</span><br><span class="line">                        start &lt; area.vpn_range.get_end())</span><br><span class="line">        != <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="comment">/// Assume that there are no adjacent areas</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap_area_by_range</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: VirtPageNum, end: VirtPageNum)</span><br><span class="line">  			-&gt; <span class="built_in">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// check containing</span></span><br><span class="line">        <span class="keyword">let</span> <span class="literal">Some</span>(pos) = <span class="keyword">self</span>.areas.iter_mut()</span><br><span class="line">            .position(|area| area.vpn_range.get_start() &lt;= start &amp;&amp;</span><br><span class="line">                        end &lt;= area.vpn_range.get_end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.areas[pos].unmap(<span class="keyword">self</span>.page_table);</span><br><span class="line">            <span class="keyword">self</span>.areas.remove(pos);</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让 <code>TaskManager</code> 修改当前任务的
<code>MemorySet</code>，调用当前任务 <code>TaskControllBlock</code>
中如下的函数即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="comment">/// map a new area</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_program_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, </span><br><span class="line">        start: VirtPageNum, end: VirtPageNum, prot: <span class="built_in">usize</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.memory_set.range_has_mapped(start, end) ||</span><br><span class="line">            prot &amp; !<span class="number">0x7</span> != <span class="number">0</span> || prot &amp; <span class="number">0x7</span> = <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> permission = MapPermission::U;</span><br><span class="line">        <span class="keyword">if</span> (prot &amp; <span class="number">0x1</span>) &#123; permission |= MapPermission::R; &#125;</span><br><span class="line">        <span class="keyword">if</span> (prot &amp; <span class="number">0x2</span>) &#123; permission |= MapPermission::W; &#125;</span><br><span class="line">        <span class="keyword">if</span> (prot &amp; <span class="number">0x4</span>) &#123; permission |= MapPermission::X; &#125;</span><br><span class="line">        <span class="keyword">self</span>.memory_set.push(</span><br><span class="line">          MapArea::new(start_va.into(), end_va.into(),</span><br><span class="line">            MapType::Framed, permission),</span><br><span class="line">          <span class="literal">None</span>);</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// unmap a area</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap_program_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: VirtPageNum, end: VirtPageNum)</span><br><span class="line">        -&gt; <span class="built_in">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.memory_set.unmap_area_by_range(start, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的都是实现接口的代码，没必要列出来了。（<del>实际上是没写</del>）</p>
<h2 id="第五章">第五章</h2>
<h3 id="实验练习-1-1">实验练习 1</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> fork() &#123;</span><br><span class="line">        -<span class="number">1</span> =&gt; &#123; -<span class="number">1</span> &#125;,</span><br><span class="line">        <span class="number">0</span> =&gt; &#123; exec(path) &#125;,</span><br><span class="line">        pid =&gt; &#123; pid &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开个玩笑，开个玩笑。（<del>但是以前的 <code>posix_spawn</code>
就是这么搞的</del>）</p>
<p>和上一章一样，这一章 <code>lab</code> 分支的 riscv crate
也出问题了，不得不尝试修一下了。首先升级 Rust 版本，修改目录下
<code>rust-toolchain</code> 文件。然后在 <code>cargo.toml</code> 里修改
riscv crate 为官方版本 <code>0.10.1</code>。根据编译错误修代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sstatus.set_spp(SPP::User); not working, make it dirty</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    *(&amp;<span class="keyword">mut</span> sstatus <span class="keyword">as</span> *<span class="keyword">mut</span> Sstatus <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">usize</span>) &amp;= !(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现 <code>spawn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task/task.rs</span></span><br><span class="line"><span class="comment">// impl TaskControlBlock</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;, elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; Arc&lt;TaskControlBlock&gt; &#123;</span><br><span class="line">    <span class="comment">// alloc a pid and a kernel stack in kernel space</span></span><br><span class="line">    <span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line">    <span class="keyword">let</span> kernel_stack = KernelStack::new(&amp;pid_handle);</span><br><span class="line">    <span class="keyword">let</span> kernel_stack_top = kernel_stack.get_top();</span><br><span class="line">    <span class="comment">// memory_set with elf program headers/trampoline/trap context/user stack</span></span><br><span class="line">    <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><br><span class="line">    <span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">    .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">    .unwrap()</span><br><span class="line">    .ppn();</span><br><span class="line">    <span class="comment">// modify trap context</span></span><br><span class="line">    *trap_cx_ppn.get_mut() = TrapContext::app_init_context(</span><br><span class="line">        entry_point,</span><br><span class="line">        user_sp,</span><br><span class="line">        KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">        kernel_stack_top,</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ---- access parent PCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> parent_inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> task_control_block = Arc::new(TaskControlBlock &#123;</span><br><span class="line">        pid: pid_handle,</span><br><span class="line">        kernel_stack,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123; UPSafeCell::new(TaskControlBlockInner &#123;</span><br><span class="line">            trap_cx_ppn,</span><br><span class="line">            base_size: parent_inner.base_size,</span><br><span class="line">            task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">            task_status: TaskStatus::Ready,</span><br><span class="line">            memory_set,</span><br><span class="line">            parent: <span class="literal">Some</span>(Arc::downgrade(<span class="keyword">self</span>)),</span><br><span class="line">            children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">            exit_code: <span class="number">0</span>,</span><br><span class="line">        &#125;)&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// add child</span></span><br><span class="line">    parent_inner.children.push(task_control_block.clone());</span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    task_control_block</span><br><span class="line">    <span class="comment">// ---- release parent PCB automatically</span></span><br><span class="line">    <span class="comment">// **** release children PCB automatically</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syscall/process.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_spawn</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = get_app_data_by_name(path.as_str()) &#123;</span><br><span class="line">        new_task = current_task.spawn(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> new_pid = new_task.pid.<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// we do not have to modify trap context of the new task</span></span><br><span class="line">    <span class="comment">// add new task to scheduler</span></span><br><span class="line">    add_task(new_task);</span><br><span class="line">    new_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; test_spawn1</span><br><span class="line">new child 3</span><br><span class="line">Test wait OK!</span><br><span class="line">Test waitpid OK!</span><br><span class="line">Shell: Process 2 exited with code 0</span><br><span class="line">&gt;&gt; test_spawn0</span><br><span class="line">new child 3</span><br><span class="line">new child 4</span><br><span class="line">...</span><br><span class="line">new child 30</span><br><span class="line">Test getpid OK! pid = 3</span><br><span class="line">Test getpid OK! pid = 4</span><br><span class="line">...</span><br><span class="line">Test getpid OK! pid = 30</span><br><span class="line">Test getpid OK! pid = 31</span><br><span class="line">new child 31</span><br><span class="line">...</span><br><span class="line">new child 34</span><br><span class="line">Test getpid OK! pid = 10</span><br><span class="line">Test getpid OK! pid = 32</span><br><span class="line">Test getpid OK! pid = 33</span><br><span class="line">Test getpid OK! pid = 34</span><br><span class="line">new child 35</span><br><span class="line">...</span><br><span class="line">new child 42</span><br><span class="line">Test getpid OK! pid = 35</span><br><span class="line">...</span><br><span class="line">Test getpid OK! pid = 42</span><br><span class="line">Test spawn0 OK!</span><br><span class="line">Shell: Process 2 exited with code 0</span><br></pre></td></tr></table></figure>
<h3 id="实验练习-2">实验练习 2</h3>
<p>在 <code>TaskControlBlockInner</code>
加两个字段，<code>prio: isize</code> 和
<code>stride: usize</code>。实现接口。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syscall/process.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_set_priority</span></span>(prio: <span class="built_in">isize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> prio &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current_task_inner = current_task.inner_exclusive_access();</span><br><span class="line">    current_task_inner.prio = prio;</span><br><span class="line">    prio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为 TCB 实现比较，用于小根堆。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task/task.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">PartialOrd</span> <span class="keyword">for</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">partial_cmp</span></span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) -&gt; <span class="built_in">Option</span>&lt;Ordering&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> self_inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> other_inner = other.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">if</span> self_inner.stride &gt; other_inner.stride &#123;</span><br><span class="line">            <span class="literal">Some</span>(Ordering::Less)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> self_inner.stride == other_inner.stride &#123;</span><br><span class="line">            <span class="literal">Some</span>(Ordering::Equal)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> self_inner.stride &lt; other_inner.stride &#123;</span><br><span class="line">            <span class="literal">Some</span>(Ordering::Greater)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">PartialEq</span> <span class="keyword">for</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">eq</span></span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> self_inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> other_inner = other.inner_exclusive_access();</span><br><span class="line">        self_inner.stride == other_inner.stride</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Eq</span> <span class="keyword">for</span> TaskControlBlock &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Ord</span> <span class="keyword">for</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp</span></span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) -&gt; core::cmp::Ordering &#123;</span><br><span class="line">        <span class="keyword">self</span>.partial_cmp(other).unwrap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Manager 换用小根堆。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task/manager.rs</span></span><br><span class="line"><span class="keyword">use</span> alloc::collections::binary_heap::BinaryHeap;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: BinaryHeap&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改一下 <code>fetch</code>，搞定。剩下的问题让编译器弄。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task/manager.rs</span></span><br><span class="line"><span class="comment">// impl TaskManager</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(tcb) = <span class="keyword">self</span>.ready_queue.pop() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = tcb.inner_exclusive_access();</span><br><span class="line">        inner.stride += BIG_STRIDE / (inner.prio <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">        <span class="built_in">drop</span>(inner);</span><br><span class="line">        <span class="literal">Some</span>(tcb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个 lab 的测试用例还没有弄好，只能自己简单测测了。对于 stride
算法深入部分的内容，我没有实现，但是可以想想：由于每次操作都是给最小的
stride 值加上不大于 <code>BigStride / 2</code>
的值，假设队列内任务数大于二，由数学归纳法（<span
class="math inline">\(\text{SM}\)</span> 即
<code>STRIDE_MAX</code>，<span class="math inline">\(\text{SN}\)</span>
即 <code>STRIDE_MIN</code>，<span
class="math inline">\(\text{B}\)</span> 即 <code>BigStride</code>，<span
class="math inline">\(\text{SSM}\)</span> 为第二小值，有 <span
class="math inline">\(\text{SSM} &gt; \text{SM}\)</span>）：</p>
<ol type="1">
<li>假设第 <span class="math inline">\(k\)</span> 次调度时，<span
class="math inline">\(\text{SM}_k – \text{SN}_k \le \text{B} /
2\)</span>；</li>
<li>那么在 <span class="math inline">\(k+1\)</span>
次调度时，假设增加步长为 <span class="math inline">\(b\)</span>，
<ul>
<li>若 <span class="math inline">\(b &lt; \text{SM}_k –
\text{SN}_k\)</span>， <span class="math inline">\(\text{SM}_{k+1} –
\text{SN}_{k+1} \le \text{SM}_k – \text{SN}_k \le B/2\)</span></li>
<li>若 <span class="math inline">\(\text{SM}_k – \text{SN}_k \le b \le
B/2\)</span>，<span class="math inline">\(\text{SM}_{k+1} –
\text{SN}_{k+1} \le \text{SM}_k + B/2 – \text{SSM}_k \le
B/2\)</span>。</li>
</ul></li>
</ol>
<p>有第零次调度，所有 stride 相等，满足条件， 证毕。</p>
<p>如果这样实现的话，新加入的 stride 必须等于
<code>STRIDE_MIN</code>。<code>PartialOrd</code> 的也实现需要
<code>STRIDE_MIN</code>。</p>
<h2 id="第六章">第六章</h2>
<p>这个教程的 easyfs 设计挺怪的，vfs
和磁盘块管理层没有很好分离，inode，efs 和 BlockDevice
的归属关系也挺乱的；代码设计也有些不符合常理的地方，比如该 static
的地方没办法 static，有点混乱。但是还是能改。</p>
<h3 id="实践作业-1">实践作业</h3>
<p>依赖中的 k210-soc 又挂掉了，我只能按自己的理解试着实现了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// easyfs/src/vfs.rs</span></span><br><span class="line"><span class="comment">// impl Inode</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_inodes_by_name</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;(Arc&lt;Inode&gt;, DiskInode, <span class="built_in">u32</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(inode) = <span class="keyword">self</span>.find(name) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">None</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> disk_inode = inode.read_disk_inode(|i| &#123; i.clone() &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(disk_inode_id) = inode.find_inode_id(name, &amp;disk_inode) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">None</span>; &#125;;</span><br><span class="line">    <span class="literal">Some</span>((inode, disk_inode, disk_inode_id))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create_link_dirent</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>, targ_name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == targ_name &#123; <span class="keyword">return</span> -<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>((targ_inode, <span class="keyword">mut</span> targ_disk_inode, targ_disk_inode_id))</span><br><span class="line">    = <span class="keyword">self</span>.get_inodes_by_name(targ_name) <span class="keyword">else</span> &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="comment">// append file in the root inode dirent</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fs = <span class="keyword">self</span>.fs.lock();</span><br><span class="line">    <span class="keyword">self</span>.modify_disk_inode(|root_inode| &#123;</span><br><span class="line">        <span class="keyword">let</span> file_count = (root_inode.size <span class="keyword">as</span> <span class="built_in">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> new_size = (file_count + <span class="number">1</span>) * DIRENT_SZ;</span><br><span class="line">        <span class="comment">// increase size</span></span><br><span class="line">        <span class="keyword">self</span>.increase_size(new_size <span class="keyword">as</span> <span class="built_in">u32</span>, root_inode, &amp;<span class="keyword">mut</span> fs);</span><br><span class="line">        <span class="comment">// write dirent</span></span><br><span class="line">        <span class="keyword">let</span> dirent = DirEntry::new(name, targ_disk_inode_id.into());</span><br><span class="line">        root_inode.write_at(</span><br><span class="line">            file_count * DIRENT_SZ,</span><br><span class="line">            dirent.as_bytes(),</span><br><span class="line">            &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// update nlink</span></span><br><span class="line">    targ_disk_inode.nlink += <span class="number">1</span>;</span><br><span class="line">    targ_inode.modify_disk_inode(|inode| &#123; *inode = targ_disk_inode; &#125;);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_link_dirent</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>((inode, <span class="keyword">mut</span> disk_inode, _disk_inode_id))</span><br><span class="line">    = <span class="keyword">self</span>.get_inodes_by_name(name) <span class="keyword">else</span> &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="comment">// delete the dirent</span></span><br><span class="line">    <span class="comment">// let mut fs = self.fs.lock();</span></span><br><span class="line">    <span class="keyword">self</span>.modify_disk_inode(|root_inode| &#123;</span><br><span class="line">        <span class="keyword">let</span> file_count = (disk_inode.size <span class="keyword">as</span> <span class="built_in">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dirent = DirEntry::empty();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..file_count &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                disk_inode.read_at(</span><br><span class="line">                    DIRENT_SZ * i,</span><br><span class="line">                    dirent.as_bytes_mut(),</span><br><span class="line">                    &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">                ),</span><br><span class="line">                DIRENT_SZ,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> dirent.name() == name &#123;</span><br><span class="line">                <span class="comment">// write a empty dirent</span></span><br><span class="line">                <span class="keyword">let</span> dirent = DirEntry::new(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                root_inode.write_at(</span><br><span class="line">                    i * DIRENT_SZ,</span><br><span class="line">                    dirent.as_bytes(),</span><br><span class="line">                    &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// update nlink</span></span><br><span class="line">    disk_inode.nlink += <span class="number">1</span>;</span><br><span class="line">    inode.modify_disk_inode(|inode| &#123; *inode = disk_inode; &#125;);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">stat</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Stat&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>((_inode, disk_inode, disk_inode_id))</span><br><span class="line">    = <span class="keyword">self</span>.get_inodes_by_name(name) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">None</span>; &#125;;</span><br><span class="line">    <span class="literal">Some</span>(Stat &#123;</span><br><span class="line">        dev: <span class="number">0</span>,</span><br><span class="line">        ino: disk_inode_id.into(),</span><br><span class="line">        mode: <span class="keyword">if</span> disk_inode.is_file() &#123; StatMode::FILE &#125; <span class="keyword">else</span> &#123; StatMode::FILE &#125;,</span><br><span class="line">        nlink: disk_inode.nlink,</span><br><span class="line">        pad: [<span class="number">0</span>; <span class="number">7</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于擦除文件没实现，擦除一个 <code>DirEnt</code>
也很复杂，所以索性留白了，至少下次访问是不合法的。</p>
<h2 id="第七章">第七章</h2>
<p>本章是 IPC 和 Signal。Lab 是邮箱，懒得写了。</p>
<h2 id="第八章">第八章</h2>
<p>Lab 是 ELO 和 实现 eventfd，挖个坑，做完项目设计回来写。</p>
<h2 id="第九章">第九章</h2>
<p>Lab 是加入 virtio-gpu 驱动，挖个坑，做完项目设计回来写。</p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 eBPF XDP 编写一个实验用防火墙</title>
    <url>/2022/03/09/zh-CN/%E5%88%A9%E7%94%A8-eBPF-XDP-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%AA%8C%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<p>SDN 老师出了一道不明所以的实机实验题，要求模拟一个特定的 TCP
传输过程，中途丢掉某个特定的包。</p>
<p>拔网线大概会直接丢所有的包，后来要求收到的包就模拟不出来了，而且十分考验手速。或者使用现有的防火墙程序，但按内容匹配也不容易。另一种方式是使用
mininet，笔者不太会 mininet。不过正好笔者了解过 eBPF，也正要学习，于是用
eBPF 写一个 XDP 防火墙，支持内容匹配。</p>
<p>我们的目的是用 BPF 实现一个 XDP（eXpress Data Path）程序，绑定在本机
loopback 接口上，匹配到 A 到 B 内容为 <code>Are you OK?</code>
的包，然后把它过滤掉。</p>
<p>不了解 eBPF 的话可以先看一下这篇博客 <a
href="https://imliuda.com/post/1047">eBPF 技术介绍-刘达的博客</a></p>
<p>本文的 repo：<a
href="https://github.com/James-Hen/eBPF-PayloadFilter">eBPF-PayloadFilter</a></p>
<h2 id="实现主机-a-和-b">实现主机 A 和 B</h2>
<p>使用 Socket 实现 TCP 连接已经老生常谈了，这次我们把它们绑定到
Loopback 接口；A 的端口 <code>1145</code>，B 的端口 <code>5141</code>，A
作为服务器。 <code>experiment.c</code>
的简化代码是这样的，错误处理省略掉了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// experiment.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_PORT 1145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PORT 5141</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">host_A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SOCKET</span></span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,</span><br><span class="line">                                                &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">// BIND to 1145</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(A_PORT);</span><br><span class="line">    bind(server_fd, (struct sockaddr *)&amp;address,</span><br><span class="line">                                <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="comment">// LISTEN</span></span><br><span class="line">    listen(server_fd, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ACCEPT</span></span><br><span class="line">    <span class="keyword">int</span> new_socket = accept(server_fd, (struct sockaddr *)&amp;address,</span><br><span class="line">                    (<span class="keyword">socklen_t</span>*)&amp;addrlen))；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *hello = <span class="string">&quot;Hello!&quot;</span>, *areuok = <span class="string">&quot;Are you OK?&quot;</span>;</span><br><span class="line">    <span class="comment">// A sends &quot;Hello!&quot;</span></span><br><span class="line">    send(new_socket, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// After ACK, A sends &quot;Are you OK?&quot;</span></span><br><span class="line">    send(new_socket, areuok, <span class="built_in">strlen</span>(areuok), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// B sends &quot;Hello!&quot;</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">host_B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SOCKET</span></span><br><span class="line">    <span class="keyword">int</span> client_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// BIND to 5141</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line">    cli_addr.sin_family = AF_INET;</span><br><span class="line">    cli_addr.sin_port = htons(B_PORT);</span><br><span class="line">    bind(client_fd, (struct sockaddr *)&amp;cli_addr, <span class="keyword">sizeof</span>(cli_addr));</span><br><span class="line">    <span class="comment">// CONNECT to localhost:1145</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(A_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">    connect(client_fd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// B reads &quot;Hello!&quot; and ACK</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(client_fd, buffer, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// B sends &quot;Hello!&quot;</span></span><br><span class="line">    <span class="keyword">char</span> *hello = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    send(client_fd, hello ,<span class="built_in">strlen</span>(hello) ,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// B reads &quot;Are you OK?&quot; and ACK</span></span><br><span class="line">    valread = read(client_fd, buffer, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (B_pid == <span class="number">0</span>) &#123; <span class="comment">// B</span></span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// Let A start first</span></span><br><span class="line">        host_B();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// A</span></span><br><span class="line">        host_A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ebpf-工具链准备">eBPF 工具链准备</h2>
<p>既然是 eBPF，必须是 Linux 了，Win 和 MacOS 不好使。</p>
<p>虽然可以使用 <code>libbpfcc</code> 和 Python
实现简单的编译和启用，但无奈在我们的服务器上存在权限问题，所以转战
<code>libbpf</code>。但是 <code>libbpf</code> 在新的 Ubuntu 20.04 LTS
上不存在了（会有 <code>E: Unable to locate package libbpf</code>
错误），需要从源码编译，我在 repo 里已经把它作为 submodule，使用
Makefile 自动编译了。</p>
<p>再者就是需要 LLVM 和 Clang 作为编译器来生成 eBPF 字节码。</p>
<p>实验抓包可以使用命令行版本的 WireShark——TShark，使用 TShark
抓包可以生成 <code>.pcapng</code> 文件，可以利用图形界面的 WireShark
分析。</p>
<p>可以这样使用 TShark 抓取 1145 端口的 TCP 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tshark -i lo -f <span class="string">&quot;tcp port 1145&quot;</span> -w <span class="string">&quot;./result.pcapng&quot;</span> -P -a duration:5</span><br></pre></td></tr></table></figure>
<p>其中 <code>-i</code> 选取设备（<code>lo</code>
是本地环回接口）；<code>-f</code> 设置一个过滤条件（和 WireShark
的显示条件语法不一样）；<code>-w</code> 写入一个文件；<code>-P</code>
在写入文件的同时把格式化的输出放到 stdout；<code>-a duration:5</code>
设置抓包五秒</p>
<h2 id="编译并加载-ebpf-程序">编译并加载 eBPF 程序</h2>
<p>上代码之前先看看怎么编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -I/usr/include/x86_64-linux-gnu -Ibuild/usr/include -O3 -target bpf -c filter.c -o filter.o</span><br></pre></td></tr></table></figure>
<p>指定的 include 目录包括了系统的目录和 libbpf 的安装目录。必须使用
Clang 才能使用 LLVM 提供的 BPF 字节码后端。可以试试查看 BPF
字节码长什么样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ llvm-objdump -D filter.o</span><br><span class="line">[...]</span><br><span class="line">Disassembly of section prog:</span><br><span class="line"></span><br><span class="line">0000000000000000 xdp_func:</span><br><span class="line">       0:       b7 00 00 00 02 00 00 00 r0 = 2</span><br><span class="line">       1:       61 12 04 00 00 00 00 00 r2 = *(u32 *)(r1 + 4)</span><br><span class="line">       2:       61 13 00 00 00 00 00 00 r3 = *(u32 *)(r1 + 0)</span><br><span class="line">       3:       bf 31 00 00 00 00 00 00 r1 = r3</span><br><span class="line">       4:       07 01 00 00 0e 00 00 00 r1 += 14</span><br><span class="line">       5:       2d 21 53 00 00 00 00 00 if r1 &gt; r2 goto +83 &lt;LBB0_12&gt;</span><br><span class="line">       6:       bf 31 00 00 00 00 00 00 r1 = r3</span><br><span class="line">       7:       07 01 00 00 22 00 00 00 r1 += 34</span><br><span class="line">       8:       2d 21 50 00 00 00 00 00 if r1 &gt; r2 goto +80 &lt;LBB0_12&gt;</span><br><span class="line">       9:       bf 34 00 00 00 00 00 00 r4 = r3</span><br><span class="line">      10:       07 04 00 00 36 00 00 00 r4 += 54</span><br><span class="line">      11:       2d 24 4d 00 00 00 00 00 if r4 &gt; r2 goto +77 &lt;LBB0_12&gt;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>可以看出它是“64 位指令字长的 RISC 架构”，BPF 的内核态 JIT 引擎会在
Verifier
验证后（这个验证非常严格），把这些字节码翻译成宿主机的指令集机器码来执行。</p>
<p>通过下面的命令把编译出来的字节码丢给 Kernel，其中 <code>lo</code>
是环回接口，<code>xdp</code> 是程序类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev lo xdp obj filter.o</span><br></pre></td></tr></table></figure>
<p>可以这样关闭它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev lo xdp off</span><br></pre></td></tr></table></figure>
<p>如果担心是不是没关掉或者误加载了，可以使用 <code>ip link list</code>
查看一下。</p>
<h2 id="先实现一个能编译的板子">先实现一个能编译的板子</h2>
<p>（用 BPF 实现的）XDP
程序的结构是这样的，前面加了一些问题描述中用到的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filter.c: drop all A-&gt;B TCP packets</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The pattern that will be matched</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> match_pattern[] = <span class="string">&quot;Are you OK?&quot;</span>;</span><br><span class="line"><span class="comment">// The ports of src and dst</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_PORT 1145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PORT 5141</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell clang that the section name of the function is prog</span></span><br><span class="line">SEC(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_func</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ctx: the pointer to the frame and relevant fields</span></span><br><span class="line">    <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">    <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">    <span class="comment">// Ethernet header is the first one</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> =</span> data;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)eth + <span class="keyword">sizeof</span>(*eth) &gt; data_end)  <span class="comment">// Overflow detection</span></span><br><span class="line">        <span class="keyword">return</span> XDP_PASS; <span class="comment">// PASS</span></span><br><span class="line">    <span class="comment">// Calculate the IP header address, must&#x27;t overflow because tested</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span> =</span> data + <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)ip + <span class="keyword">sizeof</span>(*ip) &gt; data_end)    <span class="comment">// Overflow detection</span></span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// If not IP protocol</span></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;protocol != IPPROTO_TCP)</span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// Calculatethe TCP header address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcp</span> =</span> (<span class="keyword">void</span> *)ip + <span class="keyword">sizeof</span>(*ip);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)tcp + <span class="keyword">sizeof</span>(*tcp) &gt; data_end)  <span class="comment">// Overflow detection</span></span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// Match the source and target port</span></span><br><span class="line">    <span class="comment">// htons: host to network (byte order) short</span></span><br><span class="line">    <span class="keyword">if</span> (tcp-&gt;source != htons(A_PORT) || tcp-&gt;dest != htons(B_PORT))</span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP; <span class="comment">// Drop it!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看得出来，他会把所有的 A 到 B 的 TCP 包通过端口匹配丢掉，可以试试跑
<code>experiment</code> 来看看能不能过滤。</p>
<p>XDP
程序中写了很多溢出的判断，这里的判断都保证了计算下一个包头位置不会达到无效内存。虽然对于正常的帧看起来显然不会溢出，但是
BPF 的 Verifier 会检查你有没有检查，否则是不愿意把你 JIT 进内核的。</p>
<h2 id="字符串匹配">字符串匹配</h2>
<p>XDP 有严格的函数调用限制，<code>strcmp</code>
是完全不能用的。有些情况下 <code>__builtin_memcmp</code>
可以用，但是我没用成功。BPF 程序基本不支持循环，但是可以使用
<code>#pragma unroll</code>
预处理指令让编译器把常数上下限的循环给完全展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filter.c (part)</span></span><br><span class="line"><span class="comment">// include and some global variables ignored</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The pattern that will be matched</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> match_pattern[] = <span class="string">&quot;Are you OK?&quot;</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_func</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ignored Ethernet, TCP, IP header tests</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Here we begin to check payloads</span></span><br><span class="line">    <span class="keyword">uint32_t</span> payload_size = <span class="comment">// ip total length - ip header length - tcp data offset</span></span><br><span class="line">        ntohs(ip-&gt;tot_len) - ((<span class="keyword">uint32_t</span>)(ip-&gt;ihl) &lt;&lt; <span class="number">2</span>) - tcp_hdrl(tcp);</span><br><span class="line">    <span class="keyword">uint32_t</span> pattern_size = <span class="keyword">sizeof</span>(match_pattern) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (payload_size != pattern_size) </span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// Point to start of payload.</span></span><br><span class="line">    payload = (<span class="keyword">const</span> <span class="keyword">char</span> *)tcp + tcp_hdrl(tcp);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)payload + payload_size &gt; data_end)</span><br><span class="line">        <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// Compare first bytes, exit if a difference is found.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; payload_size; i++)</span><br><span class="line">        <span class="keyword">if</span> (match_pattern[i] != payload[i])</span><br><span class="line">            <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">    <span class="comment">// matched, Drop it</span></span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦对了，出现了一个
<code>tcp_hdrl(tcp)</code>。它其实是我自己写的宏，来取得 TCP
的头长度（也是数据的 Offset）。为啥不是个简单的字段呢？因为有些实现是
BSD 标准，可以参照 <a
href="https://sites.uclouvain.be/SystInfo/usr/include/netinet/tcp.h.html">tcp.h</a>。另外，这个偏移量是以
4 字节（32 位）为单位的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __FAVOR_BSD</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> tcp_hdrl(hdr) ((uint32_t)(hdr-&gt;th_off) &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> tcp_hdrl(hdr) ((uint32_t)(hdr-&gt;doff) &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="需要-debug">需要 Debug！</h2>
<p>万一写挂了，这东西完全没有调试器，没有断点可以打。只能 print
些什么，但是连 <code>printf</code> 也不能用！所幸 <code>libbpf</code>
提供了 <code>bpf_trace_printk()</code>，提供类似 <code>printf</code>
的功能，但是：</p>
<ul>
<li>它最多只可以格式化输出三个变量的值</li>
<li>必须传格式字符串的长度</li>
<li>在程序中必须声明使用 <a
href="https://github.com/torvalds/linux/blob/master/include/linux/license.h">GPL-compatible</a>
许可证开源</li>
</ul>
<p>唉，虽然不喜欢 GPL，但是至少 MIT 和 BSD 是能 GPL-compatible
的。至于前两个限制，可以写一个宏解决（来自 <a
href="https://www.gigamon.com/content/dam/resource-library/english/guide---cookbook/gu-bpf-reference-guide-gigamon-insight.pdf">BPF
Reference Guide</a>）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual MIT/GPL&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printk(fmt, ...)                            \</span></span><br><span class="line"><span class="meta">(&#123;                                                  \</span></span><br><span class="line"><span class="meta">        char ____fmt[] = fmt;                       \</span></span><br><span class="line"><span class="meta">        bpf_trace_printk(____fmt, sizeof(____fmt),  \</span></span><br><span class="line"><span class="meta">                         ##__VA_ARGS__);            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">SEC(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_func</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    printk(<span class="string">&quot;Payload filter debugging enabled!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的东西不会输出到标准输出（命令行），而是一个系统的管道
<code>/sys/kernel/debug/tracing/trace_pipe</code>，可以在另一个终端
<code>cat</code> 一下来看输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cat /sys/kernel/debug/tracing/trace_pipe</span><br></pre></td></tr></table></figure>
<h2 id="我只想丢一次怎么办">我只想丢一次怎么办</h2>
<p>如果我按照上面的说法写防火墙，那么我内容是 <code>Are you OK?</code>
的包就再也传不到了，程序只有在超时重传开始摆烂才能真正退出来，很难受，也没法好好做实验。怎么办呢，我搞个全局变量记一下丢了几个包？</p>
<p>很可惜没有这么简单，XDP
不允许全局的可变量<del>，淦</del>。但是内核为了实现 Stateful
的网络设计（比如 NAT
和虚连接），给你提供了它的一些数据结构的接口。那么我们就用它的
<code>BPF_MAP_TYPE_HASH</code>
来实现一下记住我丢了几次吧（虽然我只用一个值就行）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Packet drop counts, implement as eBPF map, just using map[0] as counter</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DROP_COUNT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ENTRIES	16</span></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">&quot;maps&quot;</span>)</span> drop_map </span>= &#123;</span><br><span class="line">	.type = BPF_MAP_TYPE_HASH,</span><br><span class="line">	.key_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">	.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">	.max_entries = MAX_ENTRIES,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_func</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a lot omitted here...</span></span><br><span class="line">    <span class="comment">// will reach here only if matched the pattern &quot;Are you OK?&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stateful: only drop DROP_COUNT times</span></span><br><span class="line">    <span class="keyword">uint32_t</span> key = <span class="number">0</span>, init_val = DROP_COUNT;</span><br><span class="line">    <span class="comment">// Update only if it doesn&#x27;t exist</span></span><br><span class="line">	bpf_map_update_elem(&amp;drop_map, &amp;key, &amp;init_val, BPF_NOEXIST);</span><br><span class="line">    <span class="keyword">uint32_t</span> *val = bpf_map_lookup_elem(&amp;drop_map, &amp;key);</span><br><span class="line">	<span class="keyword">if</span> (val &amp;&amp; *val) &#123;</span><br><span class="line">        <span class="keyword">int</span> new_val = *val - <span class="number">1</span>;</span><br><span class="line">        bpf_map_update_elem(&amp;drop_map, &amp;key, &amp;new_val, BPF_ANY);</span><br><span class="line">        <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Match but had dropped, pass</span></span><br><span class="line">    <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把这个实验做好了，搞了一天半属实有点大动干戈，但是学了不少好东西呢！</p>
<h2 id="结果">结果</h2>
<p>如图为使用 TShark 得到的包，并使用 WireShark 分析的结果：</p>
<figure>
<img src="/images/ePBFFirewall/pcapng-result.png"
alt="pcapng-result.png" />
<figcaption aria-hidden="true">pcapng-result.png</figcaption>
</figure>
<p>图中最后倒数第三个包的 ACK number 和理论计算值有差异，原因是 TCP
选择性重传（TCP Out-Of-Order）。虽然长度为 0，但选择了
<code>SLE=18</code> 和 <code>SRE=19</code> 一个长度为一对区间做选择性
ACK。</p>
<p>这里是不启用防火墙的结果，作为参考：</p>
<figure>
<img src="/images/ePBFFirewall/pcapng-ref.png"
alt="pcapng-result.png" />
<figcaption aria-hidden="true">pcapng-result.png</figcaption>
</figure>
<h2 id="references">References</h2>
<ul>
<li><a
href="https://www.gigamon.com/content/dam/resource-library/english/guide---cookbook/gu-bpf-reference-guide-gigamon-insight.pdf">BPF
Reference Guide</a></li>
<li><a href="https://nakryiko.com/posts/bpf-tips-printk/">BPF tips &amp;
tricks: the guide to bpf_trace_printk() and bpf_printk()</a></li>
<li><a
href="https://github.com/xdp-project/xdp-tutorial/tree/master/tracing03-xdp-debug-print">Tutorial:
Tracing03 - debug print</a></li>
<li><a href="https://vvl.me/2021/02/eBPF-3-eBPF-map/">eBPF 系列三：eBPF
map</a></li>
</ul>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>博客升级搬迁</title>
    <url>/2023/03/28/zh-CN/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7%E6%90%AC%E8%BF%81/</url>
    <content><![CDATA[<p>近日将博客使用的 Next 主题从好久不更新的 <a
href="https://github.com/theme-next/hexo-theme-next">Github 仓库</a>
部署方式切到了 npm，也获得了版本的升级。并且我现在把博客在 <a
href="railway.app">Railway</a> 上以 Docker 加 Nginx 的方式托管，不再用
Github Pages 了。</p>
<p>原来的用的好好的，为什么要多此一举呢？本质原因可能是因为我要整理一下目前正在用的域名，打算以后都使用
<code>junyang.me</code> 这个域名。但是原先的 <code>jyzhang.xyz</code>
因为也分享给了别人，所以要保持很长一段时间的可用。Github Pages
并不能使用多个自定义域名，于是想要搬迁。还有一个次要原因，可能是因为我最近玩
OpenAI API，搭了个 GPT-3.5-turbo 的镜像站给家人用，用 Railway 部署了 <a
href="https://github.com/Chanzhaoyu/chatgpt-web">ChatGPT WEB</a>，感觉
Railway 很好用，于是购买了 plan。心想买都买了就把博客搞过来吧。</p>
<h2 id="为-hexo-编写-dockerfile">为 Hexo 编写 Dockerfile</h2>
<p>Hexo 生成的是静态网站，如果不想在静态页面托管处使用，可以搭建 Nginx
服务器。Railway 上的话就用 Docker 部署 Nginx
即可（实际上也不支持别的方式）。我直接在 Hexo 的博客仓库里加了个
Dockerfile，这样每次 Github commit
之后就会自动触发构建，更新到网站上。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first stage: build the site using node</span></span><br><span class="line"><span class="keyword">FROM</span> node:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> junyangzhang, <span class="keyword">user</span>@junyang.me</span><br><span class="line"></span><br><span class="line"><span class="comment"># install hexo and others in package.json</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/src</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /root/src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g &amp;&amp; npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install pandoc</span></span><br><span class="line"><span class="comment"># get package based on architecture</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ARCH=$(dpkg --print-architecture) \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Architecture: <span class="variable">$ARCH</span>&quot;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> = <span class="string">&quot;amd64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="bash">           wget https://github.com/jgm/pandoc/releases/download/3.1.1/pandoc-3.1.1-1-amd64.deb &amp;&amp; \</span></span><br><span class="line"><span class="bash">           dpkg -i pandoc-3.1.1-1-amd64.deb; \</span></span><br><span class="line"><span class="bash">       <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> = <span class="string">&quot;arm64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="bash">           wget https://github.com/jgm/pandoc/releases/download/3.1.1/pandoc-3.1.1-1-arm64.deb &amp;&amp; \</span></span><br><span class="line"><span class="bash">           dpkg -i pandoc-3.1.1-1-arm64.deb; \</span></span><br><span class="line"><span class="bash">       <span class="keyword">else</span> \</span></span><br><span class="line"><span class="bash">           <span class="built_in">echo</span> <span class="string">&quot;Unsupported architecture: <span class="variable">$ARCH</span>&quot;</span>; \</span></span><br><span class="line"><span class="bash">           <span class="built_in">exit</span> 1; \</span></span><br><span class="line"><span class="bash">       <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make inplace style changes</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x customization/alter_styles.sh &amp;&amp; ./customization/alter_styles.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build the site</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> hexo generate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second stage: configure nginx</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d/hexosite.conf</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /var/logs/ &amp;&amp; touch /var/logs/error.log &amp;&amp; touch /var/logs/nginx.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get the built site from the node stage</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/share/nginx/html/public</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /root/src/public /usr/share/nginx/html/public</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo default port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run hexo server</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>这个 Dockerfile 有两个 Stage，思路就是先用 Node.js
镜像构建网站，然后再配置 Nginx 镜像并把上一个阶段的静态网站输出拷贝到
Nginx 镜像来。我之前也写过同一个 Stage 的方案，后来发现服务端并不需要
Node.js，分成两个阶段的话第一个阶段的文件都不会出现在最终镜像里，实际部署的大小不到一百兆。如果包含
Node.js，就有一个多 G 了。</p>
<h3 id="第一阶段">第一阶段</h3>
<p>第一个阶段，先在 node 镜像上拷贝所有网站源码，并安装
Hexo。<code>npm install</code> 指令会按照源码中的
<code>package.json</code> 安装需要的模块。另外，Hexo
构建的时候需要安装非 npm 模块 pandoc，所以第一个阶段需要下载 pandoc
安装。我本地是 M1 Mac，云端是
x86，为了本地能构建，所以增加了不少判断指令集的代码。</p>
<p>第一个阶段在真正构建静态网站之前，我添加了修改主题的一个脚本
<code>./customization/alter_styles.sh</code>，来完成外置
<code>.styl</code> 文件没法做到的事情，这个干了什么就后面再说吧。</p>
<h3 id="第二阶段">第二阶段</h3>
<p>第二个阶段构建的镜像就是最终的镜像，它是基于 Nginx
的。<code>/etc/nginx/conf.d/</code> 下需要放置 Nginx
的配置文件，我直接在源码里提供了。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">4000</span>;</span><br><span class="line">    <span class="attribute">server_name</span> blog.junyang.me;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html/public;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个站点的位置和 Dockerfile 里是对应的，需要把上一个阶段生成的站点用
<code>COPY --from=0</code> 拷过来。</p>
<h3 id="思考一下">思考一下</h3>
<p>这个方式好像也有缺点，每次构建网站都需要先配置一个构建镜像再构建，并且看
Railway 也不怎么 Cache
这个镜像，每次部署构建时间比较长（一分多钟）。也没什么办法，毕竟 Railway
只是个功能支持一般的 Docker
平台，看他以后会怎么改进吧。另外一个思路就是可以在 Dockerhub
上预构建镜像然后直接 <code>FROM</code>，不过这点加速我就懒得搞了。</p>
<h2 id="升级-next">升级 Next</h2>
<p>不知道为啥 Next 有两个官方 repo，并且我用的那个好久不更新了。现在按照
<a href="https://github.com/next-theme/hexo-theme-next">新的 repo</a>
来配置吧，目前的版本是 8.15.0。我采用的方式是直接
<code>npm install</code>，并且在网站源码中加入
<code>_config.next.yml</code> 来配置 Next 主题。<code>npm install</code>
的话会自动将包和依赖写入 <code>package.json</code>，所以不需要在
Dockerfile 再写一次。具体怎么操作可以见<a
href="https://theme-next.js.org/docs/getting-started/configuration.html">文档</a>。</p>
<h3 id="魔改-next-的方法">魔改 Next 的方法</h3>
<p>我用的 Pisces 主题，如果觉得还想自定义一下，现在可以在
<code>source/_data/</code> 目录下写自己的 <code>.styl</code>
文件来修改样式。但是这种方式没法修改所有的细节，比如圆角。若想修改文本块圆角需要修改主题的样式文件
<code>node_modules/hexo-theme-next/source/css/_variables/Pisces.styl</code>，这个文件每次构建都会重新下载并覆盖，所以我写了个脚本修改它，脚本会在
Dockerfile 构建的时候调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># customization/alter_styles.sh</span></span><br><span class="line"><span class="built_in">set</span> -ex</span><br><span class="line"></span><br><span class="line">THEME_NEXT_PATH=<span class="string">&quot;node_modules/hexo-theme-next&quot;</span></span><br><span class="line">PISCES_STYL_FILE=<span class="string">&quot;<span class="variable">$THEME_NEXT_PATH</span>/source/css/_variables/Pisces.styl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the old and new lines to replace</span></span><br><span class="line">OLD_LINE1=<span class="string">&#x27;$border-radius-inner[[:blank:]]*= initial&#x27;</span></span><br><span class="line">OLD_LINE2=<span class="string">&#x27;$border-radius[[:blank:]]*= initial&#x27;</span></span><br><span class="line">NEW_LINE1=<span class="string">&#x27;$border-radius-inner   = 0 0 8px 8px&#x27;</span></span><br><span class="line">NEW_LINE2=<span class="string">&#x27;$border-radius         = 8px&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use sed to replace the lines in the file</span></span><br><span class="line">sed -i -e <span class="string">&quot;s/<span class="variable">$OLD_LINE1</span>/<span class="variable">$NEW_LINE1</span>/g&quot;</span> <span class="string">&quot;<span class="variable">$PISCES_STYL_FILE</span>&quot;</span></span><br><span class="line">sed -i -e <span class="string">&quot;s/<span class="variable">$OLD_LINE2</span>/<span class="variable">$NEW_LINE2</span>/g&quot;</span> <span class="string">&quot;<span class="variable">$PISCES_STYL_FILE</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>目前我只搞了一点点自定义，因为原版本来就不丑，如果想搞深度自定义，可以参考下网上搜到的大佬的文章：</p>
<ul>
<li><a href="https://zenreal.github.io/posts/44730/">雲沐居-最新 Hexo
NexT v7.4.1 主題優化</a></li>
</ul>
<p>他也写了从零建站的方法，若之前没搞过 Hexo 博客，值得一看。</p>
<h2 id="评论系统迁移">评论系统迁移</h2>
<p>升级 Hexo 版本到 8.0 之后发现 Valine 不再支持了，具体原因可以见 <a
href="https://github.com/next-theme/hexo-theme-next/issues/4">更新说明</a>。</p>
<p>于是我兜兜转转试了试下面几个方案，发现都不太行：</p>
<ul>
<li><a href="https://disqus.com/">Disqus</a>：广告太多，比较丑陋；</li>
<li><a href="https://artalk.js.org/">Artalk</a>：非常棒，但是他的后端
Dockerfile 用了 <code>VOLUME</code>，Railway 不支持，并且需要 CLI
添加管理员账户，我自己 Fork 了一个改改感觉非常麻烦，就舍弃了；</li>
</ul>
<p>其他的解决方案看了看，大概都需要在 Hexo 配置文件里写
Key，这是非常危险的，因为我可能试图把配置文件也同步到
Github。最后我发现了 <a
href="https://waline.js.org/">Waline</a>，完美解决了需求。</p>
<h3 id="waline-前端">Waline 前端</h3>
<p>前端增加 Waline 评论区的方式就是 <code>npm install</code>，然后在
<code>_config.next.yml</code> 加入配置即可，非常简单。不像
Artalk，并没有 Hexo 的官方插件包，我还自己写了 js 文件，最后却放弃了
Artalk，痛心。</p>
<h3 id="waline-后端">Waline 后端</h3>
<p>Waline 可以通过 Raiway 直接部署 PostgreSQL 来做后端（<a
href="https://waline.js.org/guide/deploy/railway.html">官方指南</a>），无需
LeanCloud 了。一键部署之后，需要在 Railway 上 Query
建表，就可以用了。我需要吧之前老博客的评论都搬过来，于是用了下 Waline
官方 Doc 的迁移工具，把老博客导出的 <code>jsonl</code> 文件转成了
<code>csv</code>。转成 <code>csv</code> 之后发现，若在 Railway
PostgreSQL 上导入需要转成 Query，于是用了一个不知道靠不靠谱的网站 <a
href="https://www.convertcsv.com/csv-to-sql.htm">convertcsv.com</a>，转成了对
<code>wl_comment</code> 表的 <code>INSERT</code> Query，然后捅进了
PostgreSQL。现在评论都回来了！</p>
<p>部署后端记得环境变量配置下
<code>SECURE_DOMAINS</code>，省的被人乱用。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>给 MX Anywhere 3 换静音微动</title>
    <url>/2021/10/23/zh-CN/%E7%BB%99-MX-Anywhere-3-%E6%8D%A2%E9%9D%99%E9%9F%B3%E5%BE%AE%E5%8A%A8/</url>
    <content><![CDATA[<p>多图警告！</p>
<h2 id="起因">起因</h2>
<p>2021年初，心想买一个随处用的鼠标，正好 Anywhere 3 出来，搭载了 Master
3 上一样的电磁滚轮。十分心动！所以就买下来了。</p>
<figure>
<img src="\images\MXMaster3Pics\1.jpg" alt="罗技 MX Anywhere 3" />
<figcaption aria-hidden="true">罗技 MX Anywhere 3</figcaption>
</figure>
<p>白色鼠标十分讨人欢喜，用到现在也不觉得用脏了，而且有时候撞到什么东西也很难留下划痕。虽然他很贵，但我觉得一点也不娇贵，是个趁手的东西。电池续航很久，根本意识不到需要充电，即使需要充电，Type
C
也十分方便。它最拿手的卖点就是电磁滚轮，真的爽到会让人觉得天下只有这一种滚轮，才能配的上鼠标的使用者。</p>
<p>然而它其实也有一些小缺点，比如回报率只有 125
Hz，比如没有滚轮左右摆动。但是这都不痛不痒，最致命的缺点，便是：</p>
<ul>
<li><strong>不静音</strong></li>
</ul>
<p>这意味着我这小半年在图书馆用鼠标都畏畏缩缩的，因为这个高频的噪声不止让别人难受，我自己听了也难受。导致这个鼠标只是每天被我带去图书馆，摆在桌上做吉祥物，然后用触摸板......</p>
<p>我一直想给它换个微动，但是又胆小，怕伤害了它的精致。直到有一天，终于忍不住了，要是它再不闭嘴，它就不是我爱的宝。</p>
<p>于是上淘宝买了凯华的静音红点（微动）和底部的鼠标脚垫，因为需要揭开脚垫才能拧螺丝。本来想去工程坊借焊台，但是感觉买个垃圾电烙铁也不贵，备着吧，就开始在寝室搞了。</p>
<h2 id="拆解">拆解</h2>
<p>很简单，撕掉脚垫，卸下四颗螺丝，打开即可看到诱人的电磁滚轮，以及吵闹<del>又垃圾</del>的
OMRON 白点微动。</p>
<figure>
<img src="\images\MXMaster3Pics\2.jpg" alt="主板部件一赏" />
<figcaption aria-hidden="true">主板部件一赏</figcaption>
</figure>
<p>接下来卸螺丝需要整理一下螺丝类型，内部外部螺丝不一样，内部螺丝也分长短两种，不要像笔者一样搞错了。</p>
<p>内部确实十分精致，电池在后方也充当了配重的角色，以弥补精巧硕大的电磁滚轮。电磁滚轮的结构有点类似步进电机，但细节不同。滚轮轮内有永磁体齿（类似步进电机的定子），轴上有一块带齿的电磁铁。通过改变电磁铁磁性可以调节阻尼和段落。使得慢速拥有步进电机的段落感，快速滚动时由于金属滚轮的动量，像陀螺仪一样不停。迅速滑动滚轮让它转起来的那下，随着屏幕页面的飞速上升，感觉买的值了。</p>
<figure>
<img src="\images\MXMaster3Pics\3.jpg" alt="电磁滚轮" />
<figcaption aria-hidden="true">电磁滚轮</figcaption>
</figure>
<p>注意滚轮下方有一个控制中键反馈的小弹簧，别弄丢了。下面放一张全家福：</p>
<figure>
<img src="\images\MXMaster3Pics\5.jpg" alt="全家福" />
<figcaption aria-hidden="true">全家福</figcaption>
</figure>
<p>接下来就是对主板动手脚。电烙铁插电上锡。原配的是三脚微动，但是购买的静音微动只有两脚的。别担心，他们是兼容的。取下三脚的比较困难，吸锡器用后仍然拔不下来，我让室友拿着，然后边用烙铁烫边拿小刀拨才拿下来。最后把
PCB
背面两个地方烫焦了（<del>焊盘毁灭者</del>），所幸并没有危及走线。</p>
<figure>
<img src="\images\MXMaster3Pics\6.jpg" alt="电烙铁和主板背面" />
<figcaption aria-hidden="true">电烙铁和主板背面</figcaption>
</figure>
<p>虽然用松香（助焊剂）担心烟雾报警器，但是并没有报警，室友显得很开心。</p>
<figure>
<img src="\images\MXMaster3Pics\7.jpg" alt="换完微动的主板" />
<figcaption aria-hidden="true">换完微动的主板</figcaption>
</figure>
<p>换完微动的主板就是上面的样子。中间的蓝点是触发中键的微动开关。</p>
<figure>
<img src="\images\MXMaster3Pics\8.jpg" alt="归位测试" />
<figcaption aria-hidden="true">归位测试</figcaption>
</figure>
<p>有点担心搞砸了，那就对不起父母给的钱。扣上电池开不了机，并不能打开蓝牙配对，把我慌了一下。之后装上滚轮的两个排线就好了，也许滚轮不安装就不会开机，但是上盖是无所谓的。裸奔测试完成功能后，就可以合盖了！</p>
<p>新的微动果然没有段落声。</p>
<figure>
<img src="\images\MXMaster3Pics\9.jpg" alt="裁脚垫" />
<figcaption aria-hidden="true">裁脚垫</figcaption>
</figure>
<p>我买的一大张的脚垫，因为没有找到专用的，只能照着老脚垫裁，必然会裁得不太规整。唉只能认了。</p>
<figure>
<img src="\images\MXMaster3Pics\10.jpg" alt="完工" />
<figcaption aria-hidden="true">完工</figcaption>
</figure>
<p>搞定，打开电脑试了试，声音小了太多，仅有的也是低频的机械结构声。现在它是完美的鼠标了！</p>
<p>嗯，换个微动从吃完饭换到八点半，对于正在备考的同学可不是什么好事，灰溜溜去学习了（<del>卑微</del>）。</p>
]]></content>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>Building SocketSnake: A Multiplayer TUI Game Written in Rust</title>
    <url>/2021/12/12/en/Building-SocketSnake-A-Multiplayer-TUI-Game-Written-in-Rust/</url>
    <content><![CDATA[<figure>
<img src="/images/SocketSnake/in_game_demo.png" alt="In Game Capture" />
<figcaption aria-hidden="true">In Game Capture</figcaption>
</figure>
<p>Github repository: <a
href="https://github.com/James-Hen/SocketSnake">SocketSnake</a></p>
<h2 id="why-snake">Why snake</h2>
<p>I started this Rust project days ago before my assignment for
computer networks was due. And also, I though that I shall practice
coding after reading half through the book <a
href="https://www.oreilly.com/library/view/programming-rust/9781491927274/">Programming
Rust by Jim Blandy, Jason Orendorff</a>. Then the snake was born out of
nowhere.</p>
<p>The project is build for personal practice, especially around
networks and rust features. Nevertheless, We shall consider if someone
would acually play it, right? Or a step forward, if somebody would learn
from the project? Thus I write this blog in case of oblivion.</p>
<h2 id="the-structure-of-the-project">The structure of the project</h2>
<p>Everything starts from a easy ground. For building a local version of
the game, while considering that it may be migrated to a networked
version, we implements a <code>Client</code> thread and a
<code>Server</code> thread. The <code>Client</code> thread is
responsible for listening a keyboard action, and convert then into a
<code>Ctrl</code> signal (which is a <code>enum</code> type), and send
it to the <code>Server</code> with a <code>std::mpsc</code> channel; The
<code>Server</code> thread will host an instance of the game
(<code>YardSim</code>), and push the screen buffer <code>YardBuf</code>
(which is a <code>Vec&lt;Vec&lt;TUIBlock&gt;&gt;</code>) to the
<code>Client</code>, who is in charge of rendering the game.</p>
<pre class="mermaid">graph TB
    subgraph Client
        Renderer(Render)
        Keyboard(KeyboarCtrlListener)
    end
    subgraph Server
        YardSim(YardSim)--BufferPipe-->Renderer
        Keyboard--CtrlPipe-->YardSim
    end</pre>
<p>Moreover, to implement the multiplayer game via network, we shall
develop more modules. The <code>ServerWrapper</code> thread consists the
<code>Server</code> thread, so do the <code>ClientWrapper</code> do.</p>
<pre class="mermaid">graph TB
    
    subgraph ClientWrapper1
        subgraph Client
            Renderer(Render)
            Keyboard(KeyboarCtrlListener)
        end
        Keyboard--CtrlPipe-->TCPSocket1(TCPSocket)
        UDPSocket1(UDPSocket)--BufferPipe-->Renderer
    end
    
    
    
    subgraph ClientWrapper2
        TCPSocket2(TCPSocket)
        UDPSocket2(UDPSocket)
    end

    subgraph ClientWrapperN
        TCPSocketN(TCPSocket)
        UDPSocketN(UDPSocket)
    end
    
    subgraph ServerWrapper
        TCPSocket1-.Connect.-TCPListener(TCPListener)
        TCPSocket2-.Connect.-TCPListener
        TCPSocketN-.Connect.-TCPListener
        
        TCPListener-.FireUp.-ClientHandler1
        TCPListener-.FireUp.-ClientHandler2
        TCPListener-.FireUp.-ClientHandlerN
        
        TCPSocket1==TCPStream==>ClientHandler1
        TCPSocket2==TCPStream==>ClientHandler2
        TCPSocketN==TCPStream==>ClientHandlerN
        
        ClientHandler1[ClientHandler1]--CtrlPipe-->YardSim
        ClientHandler2[ClientHandler2]--CtrlPipe-->YardSim
        ClientHandlerN[ClientHandlerN]--CtrlPipe-->YardSim
        
        
        
        subgraph Server
            YardSim(YardSim)
        end
        
        ServerUDPSocket(UDPSocket Multicast)==Buffer==>UDPSocket1
        ServerUDPSocket==Buffer==>UDPSocket2
        ServerUDPSocket==Buffer==>UDPSocketN
        
        YardSim--BufferPipe-->ServerUDPSocket
        
    end</pre>
<p>In the diagram, the squared blocks are threads, and round-cornered
squares are objects. The bol lines are network channels, and the regular
lines are inter-thread channels. The server wrapper has a
<code>TCPListener</code>: whenever the server listened a connection
request, it launches a <code>ClientHadler</code> thread to deal with the
TCP stream, and send the control signals to the server backend through a
channel. The client then receive the buffer through UDP, and send it for
rendering.</p>
<p>The chioce of a mixure of TCP and UDP is due to the different
demands: the control signals need to be sent losslessly and orderly, but
the buffer cares more about latency than loosing packets.</p>
<h3 id="files">Files</h3>
<p>The files implementing the project are listed below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SocketSnake</span><br><span class="line">├── Cargo.toml			<span class="comment"># provides definition for Rust&#x27;s Cargo utility</span></span><br><span class="line">└── src</span><br><span class="line">    ├── client.rs		<span class="comment"># User interface, game control threads implementation</span></span><br><span class="line">    ├── main.rs			<span class="comment"># Main</span></span><br><span class="line">    ├── multiplayer.rs	<span class="comment"># Server and client wrappers to introduce sockets and channels</span></span><br><span class="line">    ├── render.rs		<span class="comment"># Defined some ui rendering components and utilities</span></span><br><span class="line">    ├── server.rs		<span class="comment"># Game simulation thread implementation</span></span><br><span class="line">    ├── snakeux.rs		<span class="comment"># Defines the user interaction that improves user&#x27;s experience</span></span><br><span class="line">    ├── transmit.rs		<span class="comment"># Defined some network transmitting components and utilities</span></span><br><span class="line">    └── yard.rs			<span class="comment"># Snake game rule implementation, simulate step by step in ticks</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CS</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Pitfalls</title>
    <url>/2021/10/13/en/Hexo-Pitfalls/</url>
    <content><![CDATA[<p>Here are the useful blogs, packages and resources that I learned from
to build this site.</p>
<p>And following the list of changes, I can reproduce this site quickly.
This is why the blog is also helpful for me.</p>
<h2 id="theme-of-hexo-next">Theme of Hexo-Next</h2>
<p>It's an elegant theme with a lot of effortless customizations.</p>
<h2 id="internationalization">Internationalization:</h2>
<p>The i18n package, which can generate directories for languages, but
still not perfect.</p>
<p><a
href="https://github.com/Jamling/hexo-generator-i18n">hexo-generator-i18n</a></p>
<p>Other solutions like moving the whole site to a sub-folder.</p>
<p><a
href="https://blog.csdn.net/calvin_zhou/article/details/110957632">Hexo站点建设之——国际化(i18n)</a></p>
<h2 id="problems-of-nunjucks-collision">Problems of nunjucks
collision:</h2>
<p>In short: do not type <code>&#123;&#123;` or `&#125;&#125;</code> in equations,
use <code>&#123; &#123;</code> or <code>&#125; &#125;</code> instead.</p>
<p><a href="http://wxnacy.com/2018/01/12/hexo-specific-symbol/">Hexo
特殊符号的转义问题</a></p>
<p><a
href="https://blog.csdn.net/violetjack0808/article/details/79472256">Hexo博客系统报错解决方案</a></p>
<h2 id="latex-support"><span class="math inline">\(\LaTeX\)</span>
Support:</h2>
<p><a
href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md">Math
Equations</a></p>
<p><a
href="https://www.jianshu.com/p/9b9c241146bc">Hexo渲染LaTeX公式</a></p>
<p>For <span class="math inline">\(\LaTeX\)</span>, I prefer to use Ktex
for faster experience. However it doesn't break lines. Thus I am
compelled to use mathjax based solutions, which are slow for voluminous
equations.</p>
<h2 id="excerpt-settings">Excerpt settings:</h2>
<p><a href="https://github.com/chekun/hexo-excerpt">hexo-excerpt</a></p>
<h2 id="images-loading">Images loading:</h2>
<p><a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a></p>
<h2 id="viewer-statistics">Viewer statistics:</h2>
<p><a
href="https://github.com/JoeyBling/busuanzi.pure.js">busuanzi</a></p>
<p><a
href="https://inspiring26.github.io/2019/10/10/hexo%E5%BC%80%E5%90%AFbusuanzi%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1/">https://inspiring26.github.io/2019/10/10/hexo%E5%BC%80%E5%90%AFbusuanzi%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1/</a></p>
<h2 id="comment-functionality">Comment functionality:</h2>
<p><a href="https://valine.js.org/">Valine -
一款快速、简洁且高效的无后端评论系统</a></p>
<p><a
href="https://blog.csdn.net/blue_zy/article/details/79071414">为你的Hexo加上评论系统-Valine</a></p>
<h2 id="update-time">Update time:</h2>
<p>The functionality seems to be added into some versions of Hexo-Next.
Just keep updated!</p>
<p><a
href="https://www.jianshu.com/p/ae3a0666e998">hexo添加文章更新时间</a></p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Moving My Blog To a Static Website</title>
    <url>/2021/10/12/en/Moving-My-Blog-To-a-Static-Website/</url>
    <content><![CDATA[<p>Hi, This is the first day that my new blog site and domain have been
established. The new site is for sharing thoughts on specific problems,
sharing works that I have done as well as introducing myself.</p>
<p>The previous site that I developed in my high school is no longer
available, and blog posts are too insignificant to repost. Thus this
site only contains posts from now on and some works not previously
published before this date.</p>
<p>Now my blog is powered by <a href="https://hexo.io/">Hexo</a>, and
operated by Github Pages (might change in the future). This is one of
the static site frameworks that fit me the most. Several blogs
indicating measures and pitfalls on establishing a Hexo site may be
posted.</p>
<p>Hope it would operate well.</p>
]]></content>
  </entry>
  <entry>
    <title>Solution on 2018 ICPC Asia Nanjing Regional M</title>
    <url>/2021/10/16/en/Solution-on-2018-ICPC-Asia-Nanjing-Regional-M/</url>
    <content><![CDATA[<p>Today we virtually participated the regional of 2018 Nanjing, and I
have done my first non-trivial string problem, introducing a new
algorithm called Extended-KMP. Thus I bet it notable on by blog.</p>
<h2 id="problem-statement">Problem Statement</h2>
<blockquote>
<p>Given two strings s and t, count the number of tuples <span
class="math inline">\((i, j, k)\)</span> such that</p>
<ol type="1">
<li><span class="math inline">\(1\le i\le j\le |s|\)</span></li>
<li><span class="math inline">\(1\le k\le |t|\)</span></li>
<li><span class="math inline">\(j − i + 1 &gt; k\)</span></li>
<li>The <span class="math inline">\(i\)</span>-th character of <span
class="math inline">\(s\)</span> to the <span
class="math inline">\(j\)</span>-th character of <span
class="math inline">\(s\)</span>, concatenated with the first character
of <span class="math inline">\(t\)</span> to the <span
class="math inline">\(k\)</span>-th character of <span
class="math inline">\(t\)</span>, is a palindrome.</li>
</ol>
<p><span class="math inline">\(2\le |s|\le 10^6\)</span>, <span
class="math inline">\(1\le |t|&lt;|s|\)</span></p>
</blockquote>
<h2 id="solution">Solution</h2>
<p>The problem is to find and count the number of cases that there is
two adjacent substrings <span class="math inline">\(s^{(1)}\)</span>,
<span class="math inline">\(s^{(2)}\)</span> in <span
class="math inline">\(s\)</span> and another <span
class="math inline">\(t^{(1)}\)</span> in <span
class="math inline">\(t\)</span>, provided that <span
class="math inline">\(s^{(2)}\)</span> is a palindrome, and <span
class="math inline">\(s^{(1)}\)</span> is reversely matched with <span
class="math inline">\(t^{(1)}\)</span>.</p>
<p>So let's reverse the string <span class="math inline">\(s\)</span>.
Then use the famous Manacher algorithm on <span
class="math inline">\(s\)</span> (when there is a longest palindrome
<span class="math inline">\(s_x\cdots s_y\)</span>, let <span
class="math inline">\(p_{x+y}=\lfloor(y-x+1)/2\rfloor\)</span>) and
count every occurrence centered at <span
class="math inline">\(i=\lceil(x+y)/2\rceil\)</span>.</p>
<p>Let <span class="math inline">\(s^j\)</span> be the suffix of <span
class="math inline">\(s\)</span> starting from <span
class="math inline">\(j\)</span>. We should firstly find the longest
common prefix of suffix <span class="math inline">\(s^j\)</span> and
<span class="math inline">\(t\)</span>, and sum up the length of these
prefixes around <span class="math inline">\(i\)</span>. Precisely, all
of the prefixes starting from <span class="math inline">\(i+1\)</span>
to <span class="math inline">\(i+p_{x+y}\)</span> should be counted.
Using prefix sum, we could get that value in <span
class="math inline">\(O(1)\)</span> at every symmetrical center.</p>
<p>It must be noted that <span
class="math inline">\(j-i+1&gt;k\)</span>, then <span
class="math inline">\(s_2\)</span> must not be empty.</p>
<p>Dealing with bounds and indexes of strings is tricky, so be
careful.</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">MaxN</span><span class="params">(<span class="number">2e6</span>+<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> s[MaxN], t[MaxN];</span><br><span class="line"><span class="keyword">int</span> palin[MaxN]; <span class="comment">// the half length of palindrome centered at i/2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> len[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    len[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">0</span>); i &lt; (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(i &gt;&gt; <span class="number">1</span>)</span>, <span class="title">q</span><span class="params">(i - p)</span>, <span class="title">r</span><span class="params">(((j + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + len[j] - <span class="number">1</span>)</span></span>;</span><br><span class="line">        len[i] = r &lt; q ? <span class="number">0</span> : <span class="built_in">min</span>(r - q + <span class="number">1</span>, len[(j &lt;&lt; <span class="number">1</span>) - i]);</span><br><span class="line">        <span class="keyword">while</span> (p &gt; len[i] - <span class="number">1</span> &amp;&amp; q + len[i] &lt; n &amp;&amp; str[p - len[i]] == str[q + len[i]])</span><br><span class="line">            ++len[i];</span><br><span class="line">        <span class="keyword">if</span> (q + len[i] - <span class="number">1</span> &gt; r)</span><br><span class="line">            j = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Extended KMP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span> *T, <span class="keyword">int</span> &amp; m, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; m &amp;&amp; T[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            next[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExtend</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">int</span> &amp; n, <span class="keyword">char</span> *T, <span class="keyword">int</span> &amp; m, <span class="keyword">int</span> extend[], <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetNext</span>(T, m, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            extend[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Next[MaxN], Lcsp[MaxN]; <span class="comment">// longest common prefix of suffix s_i and t</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL SLcsp[MaxN]; <span class="comment">// prefix sum of Lcsp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(strlen(s))</span>, <span class="title">lt</span><span class="params">(strlen(t))</span></span>;</span><br><span class="line">    <span class="comment">// reverse the string s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; ls / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[ls - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">manacher</span>(s, palin, ls);</span><br><span class="line">    <span class="built_in">GetExtend</span>(s, ls, t, lt, Lcsp, Next);</span><br><span class="line">    <span class="comment">// prefix sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; ls; ++i) &#123;</span><br><span class="line">        SLcsp[i + <span class="number">1</span>] = SLcsp[i] + Lcsp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; ls + ls - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123; <span class="comment">// even length palindrome</span></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">((i + <span class="number">1</span>) / <span class="number">2</span>)</span></span>; <span class="comment">// to exclude empty palindrome part</span></span><br><span class="line">            ans += SLcsp[<span class="built_in">min</span>(mid + palin[i] + <span class="number">1</span>, ls)] - SLcsp[mid + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// odd length palindrome</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">mid</span>(i / <span class="number">2</span>);</span><br><span class="line">            ans += SLcsp[<span class="built_in">min</span>(mid + palin[i] + <span class="number">1</span>, ls)] - SLcsp[mid + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Problem Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能导论考试背诵</title>
    <url>/2022/05/05/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%E8%80%83%E8%AF%95%E8%83%8C%E8%AF%B5/</url>
    <content><![CDATA[<p>这门课我在 XJTU
大三下学期上的，老师是可爱的罗敏楠老师，用的课本是著名的《人工智能——一种现代的方法》</p>
<h2 id="考试回忆">考试回忆</h2>
<p>八个题</p>
<ol type="1">
<li>填空题，被坑到了，有一个题填的是 <span
class="math inline">\(h(n)\)</span> 可采纳时<u> 树搜索 </u>的 A*
算法最优；<span class="math inline">\(h(n)\)</span> 可采纳且一致时<u>
图搜索 </u>的 A*
算法最优。<del>下面没整理到，我自然就不会了</del>（这里有一点点小争议，图上
A* 搜索若有 <span class="math inline">\(h(n)\)</span>
一致则不需要重新访问节点；而且这个题挖空挖得很难想到）</li>
<li>无信息搜索，让画二叉树，写出深度限制和迭代加深搜索的节点序列</li>
<li>有信息搜索，画出北京地铁北京站到西四的 A* 搜索树</li>
<li>CSP，写弧相容过程</li>
<li>概率论，给了所有条件概率，算一些概率（简单）</li>
<li>概率推理，贝叶斯网络推理，不过是解析的而不是数值的，网络结构很小，挺有意思</li>
<li>时序推理，一阶马尔可夫，不过证据变量一共有四个值（两个布尔变量），算
<span class="math inline">\(t=1,2,3\)</span> 滤波和平滑</li>
<li>决策，默写 Expected Utility
公式，顺便考了理性定义，最后给了个不深的例子让求 EU</li>
</ol>
<p>考试两个半小时，但我看不到表，所以前五题不紧不慢写了一个半小时，老师提醒的时候还有三个大题，直接绷不住了。写完刚好交卷。</p>
<h2 id="agent">Agent</h2>
<p>Agent 通过传感器感知环境并通过执行器对环境产生影响。</p>
<ul>
<li>Agent 函数 <span class="math inline">\(f:P^*\to A\)</span>，其中
<span class="math inline">\(P^*\)</span> 为感知序列，<span
class="math inline">\(A\)</span> 为行动；</li>
<li>Agent 程序实现 Agent 函数；</li>
<li>Agent 程序在 Agent 体系结构上执行。</li>
</ul>
<p>理性：对每一个可能的感知序列，根据已知的感知序列提供的证据和 Agent
具有的先验知识，理性 Agent
应该选择能够使其性能度量最大化的行动。判断理性依赖于：性能度量、先验知识、行动、感知序列。</p>
<p>任务环境 PEAS (Performance, Environment, Actuators, Sensors)</p>
<p>任务环境的性质：</p>
<ul>
<li>完全可观察，部分可观察；</li>
<li>单 Agent，多 Agent（其他 Agent 的性能度量依赖于你的行为）；</li>
<li>确定的，随机的；</li>
<li>片段式的（片段之间没有依赖），延续式的；</li>
<li>静态的（环境在计算时不变化），半动态的（性能评价在计算时变化），动态的；</li>
<li>离散的，连续的；</li>
<li>已知的，未知的；</li>
</ul>
<p>Agent 类型：</p>
<ul>
<li>简单反射 Agent；</li>
<li>基于模型的 Agent；</li>
<li>基于目标的 Agent；</li>
<li>基于效用的 Agent；</li>
<li>学习 Agent：Critic, Learning element, Problem generator, Performance
element.</li>
</ul>
<h2 id="搜索">搜索</h2>
<h3 id="无信息搜索">无信息搜索</h3>
<p>初始状态、行动、转移模型、目标测试、路径消耗</p>
<p>图搜索算法：树搜索算法 + 探索集（closed 表）</p>
<p>最大分支因子 <span class="math inline">\(b\)</span>，最优解深度 <span
class="math inline">\(d\)</span>，路径最大长度 <span
class="math inline">\(m\)</span></p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 32%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>完备性</th>
<th>最优性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>宽度优先</td>
<td>是若 <span class="math inline">\(b\)</span> 有限</td>
<td>是若消耗是深度的非递减函数</td>
<td><span class="math inline">\(O(b^{d})\)</span></td>
<td><span class="math inline">\(O(b^d)\)</span></td>
</tr>
<tr class="even">
<td>一致代价</td>
<td>是若代价大于零</td>
<td>是</td>
<td><span class="math inline">\(O(b^{d^*+1})\)</span></td>
<td><span class="math inline">\(O(b^{d^*+1})\)</span></td>
</tr>
<tr class="odd">
<td>深度优先</td>
<td>是若空间有限</td>
<td>否</td>
<td><span class="math inline">\(O(b^m)\)</span></td>
<td><span class="math inline">\(O(bm)\)</span></td>
</tr>
<tr class="even">
<td>深度受限 DLS</td>
<td>是若 <span class="math inline">\(l&gt;d\)</span></td>
<td>否</td>
<td><span class="math inline">\(O(b^l)\)</span></td>
<td><span class="math inline">\(O(bl)\)</span></td>
</tr>
<tr class="odd">
<td>迭代加深 IDS</td>
<td>是</td>
<td>是</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(bd)\)</span></td>
</tr>
<tr class="even">
<td>双向搜索</td>
<td>是若 <span class="math inline">\(b\)</span> 有限</td>
<td>是若消耗是深度的非递减函数</td>
<td><span class="math inline">\(O(b^{d/2})\)</span></td>
<td><span class="math inline">\(O(b^{d/2})\)</span></td>
</tr>
</tbody>
</table>
<p>一致代价搜索的最大深度计算：<span class="math inline">\(d^*=1+\lfloor
C^*/\varepsilon\rfloor\)</span>，其中 <span
class="math inline">\(C^*\)</span> 是最优解的代价，每个行动的代价至少为
<span class="math inline">\(\varepsilon\)</span></p>
<h3 id="有信息搜索">有信息搜索</h3>
<ul>
<li>最佳优先搜索：评估函数 <span class="math inline">\(f(n)\)</span>
表示节点可取性，启发式
<ul>
<li>贪婪最佳优先搜索，BFS，对评估函数一致代价，很垃圾，会环</li>
</ul></li>
<li>A*：评估函数 <span
class="math inline">\(f(n)=h(n)+g(n)\)</span>，<span
class="math inline">\(g(n)\)</span> 是实际代价，<span
class="math inline">\(h(n)\)</span> 是估计代价
<ul>
<li>保证 <span class="math inline">\(h(n)\)</span>
可采纳（小于真实代价）且一致（三角不等式）；可以得到 <span
class="math inline">\(f(n)\)</span> 非递减；则最优</li>
<li><span class="math inline">\(h(n)\)</span> 越大越有优势，两个的 <span
class="math inline">\(\max\)</span> 也是可采纳的</li>
</ul></li>
<li>有效分枝因子 <span class="math inline">\(b^*\)</span> 满足 <span
class="math inline">\(N+1=1+b^*+(b^*)^2+\cdots+(b^*)^d\)</span>，节点总数
<span class="math inline">\(N\)</span>，解深度 <span
class="math inline">\(d\)</span></li>
</ul>
<h3 id="非经典搜索算法">非经典搜索算法</h3>
<h4 id="局部搜索算法">局部搜索算法</h4>
<ul>
<li>爬山法、随机重启爬山法</li>
<li>模拟退火</li>
<li>局部束搜索（记录 <span class="math inline">\(k\)</span>
个生成所有子状态，选 <span class="math inline">\(k\)</span>
个最优）</li>
<li>遗传（选择、杂交、变异）</li>
</ul>
<h4 id="使用不确定性动作的搜索">使用不确定性动作的搜索</h4>
<p>动作可能导致不同结果，但结果可观察（完全可观察，不确定）</p>
<p>问题的解不是行动序列，而是应急规划：根据感知信息决定行动</p>
<p>与或树搜索：或做选择形成与节点，与节点可以导致多个或节点</p>
<p>与节点需要搜索所有子节点形成规划，或节点需要找到一个成功的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConditionalPlan andOrSearch(Problem p) &#123;</span><br><span class="line">	return orSearch(p.init_state, p, [])</span><br><span class="line">&#125;</span><br><span class="line">ConditionalPlan orSearch(State s, Problem p, Path pth) &#123;</span><br><span class="line">	if (p.goalTest(s))</span><br><span class="line">		return []</span><br><span class="line">	if (s in pth) # infinity loop</span><br><span class="line">		return fail</span><br><span class="line">	for action in p.actions(s) &#123;</span><br><span class="line">		plan = andSearch(state.results(action), p, s + pth)</span><br><span class="line">		if (plan)</span><br><span class="line">			return action + plan</span><br><span class="line">	&#125;</span><br><span class="line">	return fail</span><br><span class="line">&#125;</span><br><span class="line">ConditionalPlan andSearch(State s, Problem p, Path pth) &#123;</span><br><span class="line">	for (si in s) &#123;</span><br><span class="line">		plani = orSearch(si, p, pth)</span><br><span class="line">		if (!plani)</span><br><span class="line">			return fail</span><br><span class="line">	&#125;</span><br><span class="line">	return [if si plan1 elif s2 plan2 elif ... if sn-1 plann-1 else plann]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用部分可观察信息的搜索">使用部分可观察信息的搜索</h4>
<p>部分可观察问题：使用信念状态（状态的集合）</p>
<p>无观察信息：解是行动序列</p>
<p>部分可观察：感知函数返回状态 <span class="math inline">\(s\)</span>
的感知信息，可用于更新信念状态，可使用与或树搜索</p>
<h3 id="对抗搜索">对抗搜索</h3>
<p>即博弈，两人参与的游戏，状态 <span class="math inline">\(s\)</span>
只有 <span class="math inline">\(\text{PLAYER}(s)\)</span> 可以行动
<span class="math inline">\(\text{UTILITY}(s,p)\)</span> 表示玩家 <span
class="math inline">\(p\)</span> 在中止状态 <span
class="math inline">\(s\)</span> 的效用（零和博弈）。 <span
class="math display">\[
\text{MINMAX}(s)=\begin{cases}
\text{UTILITY}(s), &amp; \text{TERMINAL-TEST}(s) \\
\max_{a\in \text{Actions(s)}}\text{MINMAX}(\text{RESULT}(s, a)), &amp;
\text{PLAYER}(s) = MAX \\
\min_{a\in \text{Actions(s)}}\text{MINMAX}(\text{RESULT}(s, a)), &amp;
\text{PLAYER}(s) = MIN \\
\end{cases}
\]</span> 若树有限则完备，若对手最优则最优，时间复杂度 <span
class="math inline">\(O(b^m)\)</span>，空间复杂度 <span
class="math inline">\(O(bm)\)</span>（深搜）</p>
<p><span class="math inline">\(\alpha\)</span>-<span
class="math inline">\(\beta\)</span>
剪枝：如果已经有更好的就不搜了，最好情况 <span
class="math inline">\(O(b^{m/2})\)</span>，平均 <span
class="math inline">\(O(b^{4m/3})\)</span></p>
<p>不完美的实时决策：使用 <span
class="math inline">\(EVAL(s)=\sum_iw_if_i(s)\)</span>
函数，其在设置的最大深度的下一层节点被使用</p>
<p>随机博弈：机会节点（MIN-Chance-MAX-Chance-Min-...），机会节点上做期望</p>
<h2 id="csp">CSP</h2>
<p>变量 <span class="math inline">\(X_i\in X\)</span> 定义，值域 <span
class="math inline">\(D_i\in D\)</span>，约束 <span
class="math inline">\(C_i=\left&lt;scope_i, rel_i\right&gt;\)</span></p>
<p>状态：对部分（全部）变量的赋值</p>
<ul>
<li>相容的赋值：不违反条件</li>
<li>完整的赋值（对应不完整的）：每个都赋值</li>
</ul>
<p>约束：</p>
<ul>
<li>一元约束：单变量值的约束（使用结点相容消去）</li>
<li>二元约束：两个变量值的约束</li>
<li>高阶约束：多个（使用枚举转换为一元约束）</li>
<li>全局约束：任意个数的变量</li>
<li>偏好约束</li>
</ul>
<h3 id="约束传播">约束传播</h3>
<p>弧相容：所有满足二元约束</p>
<p>AC-3
算法：队列包含所有弧，每次使一条弧相容，如果有变化，插入所有变化变量的弧</p>
<p>假设有 <span class="math inline">\(c\)</span> 个弧，复杂度 <span
class="math inline">\(O(cd^3)\)</span></p>
<h3 id="回溯搜索">回溯搜索</h3>
<p>具有单变量赋值的 CSP 的深度优先搜索称为回溯搜索</p>
<ul>
<li><p>最少剩余值启发式：每次单变量赋值，选择合法值最少的变量</p></li>
<li><p>度启发式：选择与未赋值变量约束最多的变量以降低未来分支因子</p></li>
<li><p>最少约束值启发式：排除剩余变量中最少的值的那个，试图为剩余变量赋
值留下最大空间</p></li>
<li><p>前向检验：跟踪未赋值变量的剩余合法值</p></li>
</ul>
<h3 id="问题结构">问题结构</h3>
<p>约束图，可以分解为联通子图，假设每个子图大小 <span
class="math inline">\(c\)</span>，复杂度 <span
class="math inline">\(O(d^c n/c)\)</span>，<span
class="math inline">\(d\)</span> 为值域大小</p>
<p>树结构 CSP（<span class="math inline">\(O(nd^2)\)</span> 求解）：</p>
<ol type="1">
<li>选一个树根做拓扑排序</li>
<li>倒序做弧相容</li>
<li>正序赋值</li>
</ol>
<p>近似树结构：对一个变量赋值删除更新邻居之后就是树</p>
<h2 id="概率推理">概率推理</h2>
<p>先验概率即无条件概率，后验概率即有条件概率</p>
<p><span class="math inline">\(P(Weather=sunny)=0.72,\cdots\)</span>
可以这样写概率分布：<span class="math inline">\(\boldsymbol
P(Weather)=\left&lt;0.72,0.1,0.08,0.1\right&gt;\)</span> <span
class="math display">\[
P(a|b)P(b)=P(a,  b)
\]</span> 并且对概率分布也成立（枚举所有组合的等式组），还有 <span
class="math display">\[
P(x_1, \cdots,  x_n)=\prod_{i=1}^n P(x_i|x_1, \cdots,  x_{i-1})
\]</span> 贝叶斯规则 <span class="math display">\[
P(a|b)=\frac{P(a,  b)}{P(b)}=\frac{P(b|a)P(a)}{P(b)}
\]</span> 枚举推理，其中 <span class="math inline">\(Y\cup E\cup
H=U\)</span> <span class="math display">\[
\boldsymbol{P}(Y|E=e)=\boldsymbol{P}(Y,E=e)/P(E=e)=\alpha\boldsymbol{P}(Y,E=e)=\alpha\sum_h\boldsymbol{P}(Y,E=e,H=h)
\]</span> 条件独立性：给定 <span class="math inline">\(A\)</span>，有
<span class="math inline">\(B\)</span> 和 <span
class="math inline">\(C\)</span> 独立，即 <span
class="math inline">\(P(B|C,A)=P(B|A)\)</span></p>
<p>朴素贝叶斯： <span class="math display">\[
\boldsymbol{P}(Cause,Effect_1,\cdots,Effect_n)=\boldsymbol{P}(Cause)\prod_{i=1}\boldsymbol{P}(Effect_i|Cause)
\]</span></p>
<h3 id="贝叶斯网络">贝叶斯网络</h3>
<p>每个节点的条件概率表是所有父节点可能取值组合下的概率</p>
<p>“语法”：网络</p>
<p>“语义”：<span
class="math inline">\(P(x_1,\cdots,x_n)=\prod_{i=1}^{n}P(x_i|parents(X_i))\)</span>，其中
<span class="math inline">\(parents(X_i)\)</span> 表示 <span
class="math inline">\(X_i\)</span> 的父节点的取值，满足 <span
class="math inline">\(X_1=x_1,\cdots,X_n=x_n\)</span></p>
<p>构造贝叶斯网络：选择一个变量顺序 <span
class="math inline">\(X_1,\cdots,X_n\)</span>，依次加入网络，父节点选择已经在网络里的最小集合</p>
<p>“拓扑”语义：给定父节点后，变量独立于它的非后代节点</p>
<p>拓扑语义推论：给定马尔科夫覆盖（父节点，子节点，子节点的父节点），变量独立于其他变量</p>
<p>确定性节点：<span class="math inline">\(X=f(Parents(X))\)</span></p>
<p>不确定性节点（噪声或关系）：某一个节点为真仅当某一父节点集合中的一个或多个为真，概率为父节点集合中
One-Hot 项 <span class="math inline">\(q_i\)</span> 的积（<span
class="math inline">\(P(X|U_1,\cdots,U_j,\neg
U_{j+1},\cdots,U_k)=1-\prod_{i=1}^j q_i\)</span>）</p>
<p>连续节点：</p>
<ul>
<li>离散化</li>
<li>参数化（使用概率密度函数）：子变量连续，则定义条件密度函数；父节点连续，则使用概率密度函数（可
Sigmoid）</li>
</ul>
<h4 id="精确推理">精确推理</h4>
<p>枚举推理 <span class="math display">\[
\boldsymbol{P}(Y|E=e)=\alpha\sum_h\boldsymbol{P}(Y,E=e,H=h)
\]</span> 上式可以以条件概率表项的乘积重写</p>
<p>变量消元法：按照从右到左的次序求和，存中间因子；因子 <span
class="math inline">\(\boldsymbol f_i\)</span>
是其变量所有取值的值在询问元素上形成的子矩阵，两因子逐点相乘得到的因子，变量是两因子的并集</p>
<h4 id="近似推理">近似推理</h4>
<ul>
<li>直接采样：从网络按拓扑序采样，没有证据</li>
<li>拒绝采样：拒绝与证据不一致的样本</li>
<li>似然加权：固定证据变量的值，对于证据“依赖”的被采样的事件进行加权，<span
class="math inline">\(w=\prod_{i}P(e_i|parents(E_i))\)</span></li>
<li>马尔可夫链蒙特卡洛
(MCMC)：从一个随机过程采样，每次通过采样一个非证据变量生成下一个状态，这次采样依赖于马尔可夫覆盖；马尔科夫链趋于稳态分布，在每种状态下花费的时间的长期比例正好与其后验概率成正比</li>
</ul>
<h3 id="时间上推理">时间上推理</h3>
<p>下面都忽略了粗体，假设 <span class="math inline">\(P(X)\)</span> 表示
<span class="math inline">\(X\)</span> 的概率分布</p>
<p><span class="math inline">\(n\)</span> 阶马尔可夫过程 <span
class="math inline">\(P(X_t|X_{0:t-1})=P(X_t|X_{t-n:t-1})\)</span></p>
<p>传感器模型 <span
class="math inline">\(P(E_t|X_t)\)</span>（不依赖之前传感），<span
class="math inline">\(n\)</span> 阶传感器马尔可夫过程 <span
class="math inline">\(P(X_t|X_{t-n:t-1}, E_{t-n:t-1})\)</span></p>
<p>稳态过程：所有的概率分布是固定的</p>
<ul>
<li>滤波：给证据算信念状态 <span
class="math inline">\(P(X_t|e_{1:t})\)</span>，计算方法类似贝叶斯（<span
class="math inline">\(P(X|e)=P(e|X)P(X)\)</span>，<span
class="math inline">\(P(X)\)</span> 依赖过去）</li>
<li>预测：给证据算未来后验 <span
class="math inline">\(P(X_{t+k}|e_{1:t})\)</span>，计算方法由马尔可夫性
<span class="math inline">\(P(X_{t+1}|X_t)\)</span> 得</li>
<li>平滑：给证据算过去后验 <span
class="math inline">\(P(X_k|e_{1:t})\)</span>，计算方法是滤波得到的前推后乘马尔可夫得到的后推前</li>
<li>最可能解释：算状态序列 <span
class="math inline">\(\arg\max_{x_{1:t}}P(x_{1:t}|e_{1:t})\)</span></li>
</ul>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>公式</th>
<th>一阶马尔可夫计算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>滤波</td>
<td><span class="math inline">\(P(X_{t+1}|e_{1:t+1})=\alpha
P(e_{t+1}|X_{t+1})P(X_{t+1}|e_{1:t})\)</span></td>
<td><span
class="math inline">\(P(X_{t+1}|e_{1:t})=\displaystyle\sum_{x_t}P(X_{t+1}|x_t)P(x_t|e_{1:t})\)</span></td>
</tr>
<tr class="even">
<td>预测</td>
<td>（同上右）</td>
<td>（同上）</td>
</tr>
<tr class="odd">
<td>平滑</td>
<td><span class="math inline">\(P(X_k|e_{1:t})=\alpha
P(X_k|e_{1:k})P(e_{k+1:t}|X_k)\)</span></td>
<td><span
class="math inline">\(\begin{aligned}P(e_{k+1:t}|X_k)&amp;=\sum_{x_{k+1}}P(e_{k+1:t}|x_{k+1})P(x_{k+1}|X_k)\\
&amp;=\sum_{x_{k+1}}P(e_{k+1}|x_{k+1})P(x_{k+1}|X_k)\end{aligned}\)</span></td>
</tr>
<tr class="even">
<td>最可能解释</td>
<td><span class="math inline">\(m_{1:t}=P(X_{1:t}|e_{1:t})\)</span>，令
<span
class="math inline">\(m_{1:t}^{(x_t)}=P(x_{1:t}|e_{1:t})\)</span></td>
<td><span
class="math inline">\(m_{1:t+1}=P(e_{t+1}|X_{t+1})\max_{x_t}(P(X_{t+1}|x_t)m^{(x_t)}_{1:t})\)</span></td>
</tr>
</tbody>
</table>
<p>隐马尔可夫模型，只用一个离散变量 <span
class="math inline">\(X_t\)</span>，但是这个变量有 <span
class="math inline">\(S\)</span> 个值</p>
<ul>
<li>转移模型 <span
class="math inline">\(T_{ij}=P(X_t=j|X_{t-1}=i)\)</span>，<span
class="math inline">\(T=P(X_t|X_{t-1})\)</span></li>
<li>传感器模型 <span
class="math inline">\(O_{ii}=P(e_t|X_{t}=i)\)</span></li>
<li>前向消息 <span class="math inline">\(f_{1:t+1}=\alpha
O_{t+1}T^{T}f_{1:t}\)</span></li>
<li>后向消息 <span
class="math inline">\(b_{k+1:t}=TO_{k+1}b_{k+2:t}\)</span></li>
</ul>
<p>卡尔曼滤波用连续变量建模，使用高斯分布，预测使用积分</p>
<p>动态贝叶斯网络：可以由任意数量状态变量和证据变量构成；隐马尔可夫是各一个离散节点的动态贝叶斯网络；按时间展开再推理</p>
<p>粒子滤波：采样方式进行预测、滤波，每个样本 <span
class="math inline">\(x_t\)</span> 通过似然 <span
class="math inline">\(P(e_t|x_t)\)</span> 加权</p>
<h2 id="制定决策">制定决策</h2>
<p>决策理论 = 概率理论 + 效用理论</p>
<p>期望效用： <span class="math display">\[
EU(A|E)=\sum_{i}P(Result(A)|Do(A),E)U(Result_i(A))
\]</span> 最大期望效用原则（MEU）：<span
class="math inline">\(Action=\arg\max_A EU(A|E)\)</span></p>
<p>Agent 偏好（遵循下述公理的关系）：</p>
<ul>
<li>有序：<span class="math inline">\(\succ,\prec,\sim\)</span>
成立一个</li>
<li>传递：<span class="math inline">\(A\succ B\succ C \Rightarrow A\succ
C\)</span></li>
<li>连续：有 <span class="math inline">\(A\succ B\succ C \Rightarrow
\exists p,[p,A;1-p,C]\sim B\)</span></li>
<li>可替换：<span class="math inline">\(A\sim
B\Rightarrow[p,A;1-p,C]\sim[p,B;1-p,C]\)</span></li>
<li>单调：<span class="math inline">\(A\sim B\Rightarrow (p\ge q\iff
[p,A;1-p, B]\succcurlyeq[q,A;1-1, B])\)</span></li>
<li>可分解：<span
class="math inline">\([p,A;1-p,[q,B;1-q,C]]\sim[p,A;(1-p)q,B;(1-p)(1-q),C]\)</span></li>
</ul>
<p>如果遵守上述公理，那么存在不唯一的实值函数对应偏好（仿射变换保持性质，则可归一化）</p>
<p>生命的价值：微亡，质量调整寿命年</p>
<p>金钱效用，期望货币价值 <span class="math inline">\(EMV(A)=\sum_i
P(Result_i(A))MV(Result_i(A))\)</span>，追求风险 <span
class="math inline">\(U(L)&gt;U(S_{EMV(L)})\)</span>，规避风险 <span
class="math inline">\(U(L)&lt;U(S_{EMV(L)})\)</span>，保险费 <span
class="math inline">\(U(L)-U(S_{EMV(L)})\)</span></p>
<h3 id="多属性偏好">多属性偏好</h3>
<p>多属性效用函数 <span
class="math inline">\(U(x_1,\cdots,x_n)=f(f_1(x1),\cdots,f_n(x_n))\)</span>，严格优势
<span class="math inline">\(\forall i, X_i(B)\ge
X_i(A)\)</span>，当行为导致概率分布时有随机优势 <span
class="math inline">\(\forall
x,\int_{-\infty}^xp_1(t)dt\le\int_{-\infty}^xp_2(t)dt\)</span></p>
<p>定性推理确定随机优势：<span
class="math inline">\(X\stackrel{+}{\to}Y\)</span> 表示 <span
class="math inline">\(X\)</span> 对 <span
class="math inline">\(Y\)</span> 有积极影响</p>
<p>确定性偏好：<span class="math inline">\(X_1\)</span> 和 <span
class="math inline">\(X_2\)</span> 偏好独立于 <span
class="math inline">\(X_3\)</span>，当且仅当结果 <span
class="math inline">\(\left&lt;x_1,x_2,x_3\right&gt;\)</span> 和 <span
class="math inline">\(\left&lt;x_1&#39;,x_2&#39;,x_3\right&gt;\)</span>
之间的偏好不依赖于 <span class="math inline">\(x_3\)</span></p>
<p>相互偏好独立性：如果每个属性都不会影响其它属性之间的权衡方式，那么所有属性显示出相互偏好独立性；如果相互偏好独立，那么
<span class="math inline">\(f(f_1(x1),\cdots,f_n(x_n))=\sum_i
f_i(x_i)\)</span></p>
<p>效用独立性：如果对 <span class="math inline">\(X\)</span>
中的属性的抽奖之间的偏好独立于 <span class="math inline">\(Y\)</span>
中的属性值，则属性集 <span class="math inline">\(X\)</span>
效用独立于属性集 <span class="math inline">\(Y\)</span></p>
<p>相互效用独立性（MUI）：如果一个属性集中的每个子集都效用独立于其余属性，则这个属性集满足相互效用独立性；有
<span
class="math inline">\(U=k_1U_1+k_2U_2+k_1k_2U_1U_2+\cdots\)</span></p>
<h3 id="序列式决策">序列式决策</h3>
<ul>
<li>回报 <span
class="math inline">\(R\)</span>：对局部效用，状态的实值函数</li>
<li>价值 <span
class="math inline">\(V\)</span>：对全局效用，状态的实值函数</li>
<li>效用 <span
class="math inline">\(U\)</span>：适用于行为、状态、状态序列对通用术语</li>
</ul>
<p>有限期决策：最优策略非静态（随时间变化）；无限期决策：最优策略静态</p>
<p>序列的效用（假设静态），那么如果初始状态一致，偏好序列也一致：</p>
<ul>
<li>累加效用：<span class="math inline">\(U_h([s_0, s_1,
s_2,\cdots])=R(S_0)+R(s_i)+R(s_2)+\cdots\)</span></li>
<li>折扣效用（更重视眼前利益）：<span class="math inline">\(U_h([s_0,
s_1, s_2,\cdots])=R(S_0)+\gamma R(s_i)+\gamma^2
R(s_2)+\cdots\)</span></li>
</ul>
<p>马尔可夫决策过程：完全可观察、随机动作、马尔可夫转移模型、折扣或累加回报；转移模型
<span class="math inline">\(P(s&#39;|s,a)\)</span></p>
<p>策略 <span class="math inline">\(\pi(s)\)</span>：在状态 <span
class="math inline">\(s\)</span>
下推荐的行为；无期限折扣效用下对于不同开始状态，策略唯一</p>
<p>状态的真正效用 <span
class="math inline">\(V^{\pi^*}(s)=E[\sum_{t=0}^\infty \gamma^t
R(S_t)]\)</span>：当 Agent 执行最优决策时的折扣回报的期望值</p>
<p>贝尔曼方程 <span class="math inline">\(V(s)=R(s)+\gamma\max_{a\in
A(s)}\sum_{s&#39;}P(s&#39;|s,a)V(s&#39;)\)</span>：使用该方程迭代是收敛的</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>优化方法基础课程</title>
    <url>/2021/11/20/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<p>今天刚考了优化方法，感觉还可以，但是据说改卷很严，我好像也感受到要是一严我就裂开了。唉，听天由命吧。</p>
<p>考前看到有之前上了的同学给这个课的评价，瘆得慌，博文链接在下面：</p>
<p><a
href="https://www.cnblogs.com/betelgeu/p/14999087.html">https://www.cnblogs.com/betelgeu/p/14999087.html</a></p>
<p>虽然他觉得罗老师不行，但是我们对罗老师印象其实挺好的，挠头。</p>
<p>不过呢，这个博主发的考试回忆还是挺准的，打消了不知道题型带来的考试懵逼感。</p>
<p>把考前复习整理的放在下面吧</p>
<h2 id="数学基础">数学基础</h2>
<h3 id="内积与范数">内积与范数</h3>
<p><span class="math inline">\(n\)</span> 维实向量集合 <span
class="math inline">\(\mathbb R^n\)</span> 上，<span
class="math inline">\(\forall x=(x_1,x_2,\cdots,x_n)^\intercal\in\mathbb
R^n\)</span>，<span
class="math inline">\(y=(y_1,y_2,\cdots,y_n)^\intercal\in \mathbb
R^n\)</span>的<strong>标准内积</strong>： <span class="math display">\[
\left&lt;x,y\right&gt;=x^\intercal y=\sum_{i=1}^n x_iy_i
\]</span></p>
<p><strong>范数</strong>的定义：满足以下条件的函数 <span
class="math inline">\(f:\mathbb R^n\to\mathbb R\)</span> 称为范数</p>
<ul>
<li>非负：<span class="math inline">\(\forall x\in \mathbb
R^n\)</span>，有 <span class="math inline">\(f(x)\ge 0\)</span>；</li>
<li>正定：若 <span class="math inline">\(f(x)=0\)</span>，则 <span
class="math inline">\(x=0\)</span>；</li>
<li>齐次：<span class="math inline">\(\forall x\in \mathbb R^n\)</span>
和 <span class="math inline">\(t\in\mathbb R\)</span>，有 <span
class="math inline">\(f(tx)=|t|f(x)\)</span>；</li>
<li>三角不等式：<span class="math inline">\(\forall x, y\in\mathbb
R^n\)</span>，有 <span class="math inline">\(f(x+y)\le
f(x)+f(y)\)</span></li>
</ul>
<p><strong><span class="math inline">\(l_p\)</span> 范数</strong>（<span
class="math inline">\(p\ge 1\)</span>）： <span class="math display">\[
\|x\|_p=\left(\sum_{i=1}^n |x_i|^p\right)^\frac{1}{p}
\]</span> <span class="math inline">\(p=2\)</span> 时称 Euclid
范数，<span class="math inline">\(p=\infty\)</span> 时称 Chebyshev
范数；“<span class="math inline">\(l_0\)</span>
范数”：向量中非零元的个数</p>
<p><strong>Cauchy-Schwartz 不等式</strong>：<span
class="math inline">\(\forall x,y\in \mathbb R^n\)</span>，有 <span
class="math display">\[
|\left&lt;x,y\right&gt;|\le\|x\|_2\|y\|_2
\]</span></p>
<p><strong><span
class="math inline">\(P\)</span>-二次范数</strong>：<span
class="math inline">\(P\in S^n_{++}\)</span>（对称正定） <span
class="math display">\[
\|x\|_P=\sqrt{x^\intercal P x}=\|P^{\frac{1}{2} }x\|_2
\]</span> 其单位球为椭球</p>
<p><strong>范数等价性</strong>：对于所有 <span
class="math inline">\(\mathbb R^n\)</span> 上范数 <span
class="math inline">\(\|\cdot\|_a\)</span>，<span
class="math inline">\(\|\cdot\|_b\)</span>，存在正常数 <span
class="math inline">\(\alpha\)</span>，<span
class="math inline">\(\beta\)</span> 使对所有 <span
class="math inline">\(x\in \mathbb R^n\)</span> 有 <span
class="math inline">\(\alpha\|x\|_a\le\|x\|_n\le\beta\|x\|_a\)</span></p>
<p><strong>对偶范数</strong></p>
<p>令 <span class="math inline">\(\|\cdot\|\)</span> 是 <span
class="math inline">\(\mathbb R^n\)</span> 上范数，其对偶范数 <span
class="math inline">\(\|\cdot\|_*\)</span> 定义为 <span
class="math display">\[
\|z\|_* =\sup\{z^\intercal x: \|x\|\le 1\} =\sup\{z^\intercal x:
\|x\|=1\}
\]</span> <span class="math inline">\(l_p\)</span> 范数的对偶为 <span
class="math inline">\(l_q\)</span> 范数，<span
class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span></p>
<p>P 范数的对偶范数 <span class="math inline">\(\|z\|_*=\sup
\{z^\intercal x\ |\ \|x\|_P=1\}=\|P^{-1/2}z\|_2\)</span></p>
<h3 id="求导与梯度">求导与梯度</h3>
<p><strong>导数</strong>：<span class="math inline">\(f:\mathbb
R^n\to\mathbb R^m\)</span> 的导数（Jacobian 矩阵）<span
class="math inline">\(Df(x)\in \mathbb R^{m\times n}\)</span> 满足 <span
class="math display">\[
\lim_{z\to x\atop z\in\operatorname {dom} f, z\neq x}
\frac{\|f(z)-f(x)-Df(x)(z-x)\|_2}{\|z-x\|_2}=0
\]</span> 有 <span class="math inline">\(Df(x)_{ij}=\dfrac{\partial
f_i(x)}{\partial x_j}\)</span>（偏导数）</p>
<p>梯度 <span class="math inline">\(\nabla
f(x)=Df(x)^\intercal\)</span></p>
<p>e.g., <span class="math inline">\(\mathrm d\left(x^\intercal A
x\right)=x^\intercal(A+A^\intercal)\mathrm dx\)</span>；</p>
<p>若有非奇异矩阵 <span class="math inline">\(T\)</span>，令 <span
class="math inline">\(\bar f(y)=f(Tx)\)</span>，则 <span
class="math inline">\(\nabla\bar f(y)=T^\intercal\nabla
f(y)\)</span>，<span class="math inline">\(\nabla^2\bar
f(y)=T^\intercal\nabla^2f(y)T\)</span></p>
<p>实函数<strong>二阶导数</strong>：<span
class="math inline">\(f:\mathbb R^n\to\mathbb R\)</span>（Hessian
矩阵）为 <span class="math display">\[
\nabla^2f(x)_{ij}=\frac{\partial^2f(x)}{\partial x_i\partial x_j}
\]</span></p>
<p><strong>二次逼近</strong>（在 <span
class="math inline">\(x_0\)</span> 处二阶泰勒展开） <span
class="math display">\[
\hat f(x)=f(x_0)+\nabla f(x)^\intercal(x-x_0)
+\frac{1}{2}(x-x_0)^\intercal\nabla^2f(x)(x-x_0)
\]</span> 有 <span class="math inline">\(\hat
f(x)=f(x)+o(\|x-x_0\|_2^2)\)</span></p>
<p><strong>梯度一阶近似</strong> <span class="math display">\[
\nabla f(x+d)\approx \nabla f(x) + \nabla^2 f(x)d
\]</span></p>
<h3 id="凸集合与凸函数">凸集合与凸函数</h3>
<p><strong>凸集</strong></p>
<p>集合 <span class="math inline">\(C\subset \mathbb R^n\)</span>
称为凸集，如果 <span class="math inline">\(\forall x,y\in C\)</span> 及
<span class="math inline">\(\forall \lambda\in [0,1]\)</span>，有 <span
class="math inline">\(z=\lambda x+(1-\lambda)y\in C\)</span></p>
<p><strong>集合保凸运算</strong>：交、闵科夫斯基和、仿射函数、透视函数
<span class="math inline">\(P(z,t)=\dfrac{z}{t}\)</span>，<span
class="math inline">\(P:\mathbb R^n\times \mathbb R_{++}\to\mathbb
R^n\)</span></p>
<p><strong>凸函数</strong>：令集合 <span
class="math inline">\(C\)</span> 为凸集，如果 <span
class="math inline">\(\forall x,y\in C\)</span> 及 <span
class="math inline">\(\forall \lambda\in [0,1]\)</span>，函数 <span
class="math inline">\(f:C\to \mathbb R\)</span> 满足 <span
class="math inline">\(f(\lambda x + (1-\lambda)y) \le\lambda f(x) +
(1-\lambda)f(y)\)</span>，则 <span class="math inline">\(f\)</span>
为凸函数</p>
<p><strong>凸函数保凸运算</strong>：非负数乘、和、带权和、自变量仿射变换、对某几维求最小值、对（所有）非凸维求最大值、<span
class="math inline">\(\max\)</span>、作其透视函数 <span
class="math inline">\(g(x,t)=tf(x/t)\)</span></p>
<p><strong>凸函数一阶判定</strong>：<span class="math inline">\(\forall
x,y\in C\)</span>，<span class="math inline">\(f(y)\ge f(x)+\nabla
f(x)^\intercal(y-x)\)</span></p>
<p><strong>凸函数二阶判定</strong>：<span class="math inline">\(\forall
x\in C\)</span>，<span class="math inline">\(\nabla^2 f(x)\)</span>
为对称半正定矩阵</p>
<p><strong>共轭函数</strong>：函数 <span class="math inline">\(f:\mathbb
R^n\to\mathbb R\)</span> 的共轭函数 <span
class="math inline">\(f^*:\mathbb R^n\to\mathbb R\)</span> 为仿射函数
<span class="math inline">\(y^\intercal x\)</span> 与 <span
class="math inline">\(f(x)\)</span> 的最大差值，<span
class="math inline">\(f^*(y)=\sup (y^\intercal
x-f(x))\)</span>；任意函数的共轭为凸函数</p>
<p><strong>Jensen's Inequality</strong>：<span
class="math inline">\(f(E[x])\le E[f(x)]\)</span></p>
<p><strong>Min-Max 不等式</strong>：<span
class="math inline">\(\inf\limits_{z\in Z}\sup\limits_{w\in W} f(w,z)
\ge \sup\limits_{w\in W}\inf\limits_{z\in Z}
f(w,z)\)</span>；若满足等号则称 <span
class="math inline">\(f,W,Z\)</span> 满足鞍点性质</p>
<h3 id="线性代数">线性代数</h3>
<p><strong>奇异矩阵</strong>：非满秩的方阵</p>
<h2 id="优化问题">优化问题</h2>
<h3 id="数学形式">数学形式</h3>
<p><span class="math display">\[
\begin {align}
\min_x\ &amp;f_0(x)  \\
\text{s.t. } &amp;f_i(x)\le 0, &amp;i=1,2,\cdots,m \\
&amp; h_j(x)=0,  &amp;j=1,2,\cdots,p
\end{align}
\]</span></p>
<p>目标函数、等式限制、不等式限制、可行解集</p>
<p>定义域 <span class="math inline">\(\mathcal
D=\bigcap_{i=0}^m\operatorname{dom} f_i \cap
\bigcap_{i=1}^p\operatorname{dom}h_i\)</span></p>
<p>凸优化问题：目标函数为凸函数，不等式限制函数为凸函数，等式限制函数为仿射函数</p>
<p>例子：线性规划、二次规划、二次函数限制的二次规划</p>
<p>优化问题的等价，增加松弛变量 <span class="math inline">\(s_i\ge
0\)</span> 将仿射函数不等式限制转为等式限制</p>
<p>局部最优解：若存在常数 <span class="math inline">\(R&gt;0\)</span> 使
<span class="math inline">\(x\)</span> 是以下问题的最优解，则 <span
class="math inline">\(x\)</span> 是一个局部最优解 <span
class="math display">\[
\begin {align}
\min_z\ &amp;f_0(z)  \\
\text{s.t. } &amp;f_i(z)\le 0, &amp;i=1,2,\cdots,m \\
&amp; h_j(z)=0,  &amp;j=1,2,\cdots,p \\
&amp; \|z-x\|_2\le R
\end{align}
\]</span></p>
<h3 id="对偶问题与最优性条件">对偶问题与最优性条件</h3>
<p>对不等式约束引入拉格朗日乘子 <span class="math inline">\(\lambda_i\in
\mathbb R\)</span>，对等式约束引入拉格朗日乘子 <span
class="math inline">\(v_i\in \mathbb R\)</span>，记 <span
class="math inline">\(\lambda=(\lambda_1,\lambda_2,\cdots,\lambda_m)^\intercal\)</span>，<span
class="math inline">\(v=(v_1,v_2,\cdots,v_m)^\intercal\)</span></p>
<p><strong>拉格朗日函数</strong> <span class="math display">\[
L(x,\lambda, v)=f_0(x)+\sum_{i=1}^m\lambda_if_i(x)+\sum_{i=1}^pv_ih_i(x)
\]</span> <strong>拉格朗日对偶函数</strong> <span
class="math display">\[
g(\lambda,v)=\inf_{x\in \mathcal D} L(x,\lambda,v)
\]</span>
线性函数是示性函数的下界，对偶函数是原问题最优解的下界，对偶函数是凹函数，<span
class="math inline">\(p^*\ge\max_{\lambda&gt;0}\min_{x\in\mathcal
D}L(x,\lambda,v)\)</span></p>
<p>设 <span class="math inline">\(f_0\)</span> 的共轭函数为 <span
class="math inline">\(f_0^*\)</span>，不等式限制 <span
class="math inline">\(Ax\le b\)</span>，等式限制 <span
class="math inline">\(Cx=d\)</span> 则对偶函数 <span
class="math inline">\(g(\lambda,v)=-f^*_0(-A^\intercal\lambda-C^\intercal
v)-b^\intercal\lambda-d^\intercal v\)</span></p>
<p><strong>对偶问题</strong> <span class="math display">\[
\begin {align}
\max_x\ &amp;g(\lambda, v)  \\
\text{s.t. } &amp;\lambda \ge0
\end{align}
\]</span> 设对偶问题最优解 <span
class="math inline">\(d^*\)</span>，对偶间隙 <span
class="math inline">\(p^*-d^*\)</span>，弱对偶 <span
class="math inline">\(d^*\le p^*\)</span> 对所有函数成立（<span
class="math inline">\(\inf\limits_{x\in\mathcal
D}\sup\limits_{\lambda\ge 0} L\ge \sup\limits_{\lambda\ge
0}\inf\limits_{x\in\mathcal D} L\)</span>）；强对偶 <span
class="math inline">\(d^*=p^*\)</span> 当凸优化问题满足 Slater
约束品性时成立</p>
<p>非启发式停止准则：对偶间隙 <span
class="math inline">\(f_0(x^{(k)})-g(\lambda^{(k)},v^{(k)})\le
\varepsilon_{abs}\)</span></p>
<p><strong>Slater 约束品性</strong>：若存在集合 <span
class="math inline">\(\mathcal D\)</span> 的一个<strong>内点</strong>
<span class="math inline">\(x_0\)</span>，使得 <span
class="math inline">\(f_i(x_0)&lt;0,\ i=1,2,\cdots,m\)</span>，<span
class="math inline">\(Ax_0=b\)</span></p>
<p><strong>通过解对偶问题求解原问题</strong></p>
<p>若对偶问题存在解 <span
class="math inline">\(d^*=g(\lambda^*,v^*)\)</span>，且 <span
class="math inline">\(L(x,\lambda^*,v^*)\)</span> 是 <span
class="math inline">\(x\)</span> 的严格凸函数，则解优化问题 <span
class="math display">\[
\min_{x\in\mathcal D}L(x,\lambda^*,v^*)
\]</span> 若该问题解 <span class="math inline">\(x^*\)</span>
是原问题的可行解，则其为原问题的最优解；否则原问题不存在最优解</p>
<h3 id="kkt-方程">KKT 方程</h3>
<p>（充要条件）假设原问题与对偶问题最优解可取得，分别为 <span
class="math inline">\(x^*\)</span> 和 <span
class="math inline">\((\lambda^*,v^*)\)</span>，且强对偶性成立，则 <span
class="math display">\[
\begin{cases}
f_i(x^*)\le 0 ,&amp; i=1,2,\cdots,m;\\
\lambda_i^*f_i(x^*)=0,&amp; i=1,2,\cdots,m;\\
\lambda_i^*\ge 0,&amp; i=1,2,\cdots,m;\\
h_i(x^*)=0,&amp; i=1,2,\cdots,p;\\
\nabla f_0(x^*)+\sum_{i=1}^m\lambda_i^*\nabla
f_i(x^*)+\sum_{i=1}^pv_i^*\nabla h_i(x^*)=0
\end{cases}
\]</span> 从上到下分别为</p>
<ul>
<li>满足不等式限制</li>
<li>互补松弛性</li>
<li>对偶可行性条件</li>
<li>满足等式限制</li>
<li>对偶局部最小值</li>
</ul>
<p><strong>等式约束二次规划的 KKT 矩阵</strong> <span
class="math display">\[
\begin{aligned}
\min_x &amp;\ \ \frac{1}{2}x^\intercal P x+q^\intercal x+r\\
\text{s.t.} &amp;\ \ Ax=b
\end{aligned}
\]</span> 其中 <span class="math inline">\(P\in S_{++}^n\)</span>（<span
class="math inline">\(n\)</span> 阶对称正定阵）。此问题 KKT 条件为 <span
class="math display">\[
\begin{cases}
Ax=b\\
Px+q+A^\intercal v^*=0
\end{cases}
\]</span> 等价于线性方程 <span class="math display">\[
\begin{bmatrix}
P &amp; A^\intercal\\
A &amp; 0
\end{bmatrix}
\begin{bmatrix}
x^*\\
v^*
\end{bmatrix}=
\begin{bmatrix}
-q\\
b
\end{bmatrix}
\]</span></p>
<h2 id="无约束优化问题">无约束优化问题</h2>
<p><span class="math display">\[
\min_x f(x)
\]</span></p>
<p>其中 <span class="math inline">\(f:\mathbb R^n \to \mathbb
R\)</span>，假设 <span class="math inline">\(f\)</span>
是具有连续二阶导数的凸函数，最优解 <span
class="math inline">\(x^*=\arg\min f(x)\)</span>，最优值 <span
class="math inline">\(p^*=f(x)\)</span>，最优条件 <span
class="math inline">\(\nabla f(x^*)=0\)</span></p>
<p>无约束最小化方法要求下水平集 <span
class="math inline">\(S=\{x|f(x)\le f(x^0)\}\)</span> 是闭集</p>
<p><strong>强凸性假设</strong></p>
<p>Hessian 下界：存在 <span class="math inline">\(m&gt;0\)</span> 使得
<span class="math inline">\(\forall x\in S\)</span>，<span
class="math inline">\(\nabla ^2 f(x)\ge mI\)</span></p>
<p>则 <span class="math inline">\(f(x)-p^*\le\frac{1}{2m}\|\nabla
f(x)\|_2^2\)</span></p>
<p>（证明：任意 <span class="math inline">\(y\)</span>，在 <span
class="math inline">\(x\)</span> 展开，有 <span
class="math inline">\(f(y)\ge f(x)-\frac{1}{2m}\|\nabla
f(x)\|_2^2\)</span>）</p>
<p>且 <span class="math inline">\(\|x-x^*\|_2\le\frac{2}{m}\|\nabla
f(x)\|_2\)</span></p>
<p>（证明：<span class="math inline">\(f(x^*)\)</span> 在 <span
class="math inline">\(x\)</span> 展开，柯西不等式）</p>
<p><strong>上界</strong></p>
<p>Hessian 上界：存在存在 <span class="math inline">\(M&gt;0\)</span>
使得 <span class="math inline">\(\forall x\in S\)</span>，有 <span
class="math inline">\(\nabla^2 f(x)\le MI\)</span></p>
<p>则 <span class="math inline">\(f(x)-p^*\ge\frac{1}{2M}\|\nabla
f(x)\|_2^2\)</span></p>
<p>（证明：<span class="math inline">\(f(y)\)</span> 在 <span
class="math inline">\(x\)</span> 处展开，两边对 <span
class="math inline">\(y\)</span> 求极小）</p>
<p><strong>下降方法</strong></p>
<p>产生优化点列 <span class="math inline">\(x^{(k)}\)</span>，<span
class="math inline">\(k=1,2,3,\cdots\)</span>，其中 <span
class="math inline">\(x^{(k+1)}=x^{(k)}+t^{(k)}d^{(k)}\)</span></p>
<p>下降方向 <span class="math inline">\(d^{(k)}\)</span> 满足 <span
class="math inline">\(\nabla f(x^{(k)})^\intercal
d^{(k)}&lt;0\)</span></p>
<p>（<span class="math inline">\(\exists t^{(k)}\)</span>，使得 <span
class="math inline">\(f(x^{(k+1)})=f(x^{(k)}+t^{(k)}d^{(k)})&lt;f(x^{(k)})\)</span>）</p>
<p>收敛时，迭代次数上界 <span class="math display">\[
f(x^{K})-p^*\le \varepsilon \Longrightarrow K\ge
\frac{\log\left((f(x^{(0)})-p^*)/\varepsilon\right)}{\log(1/c)}
\]</span> 其中</p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 36%" />
<col style="width: 30%" />
<col style="width: 21%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>非规范化回溯直线搜索</th>
<th>回溯直线搜索</th>
<th>非规范化精确直线搜索</th>
<th>精确直线搜索</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(c\)</span></td>
<td><span class="math inline">\(1-2m\alpha
\tilde\gamma^2\min\left\{1,\frac{\beta\gamma^2}{M}\right\}\)</span></td>
<td><span class="math inline">\(1-2m\alpha
\min\left\{1,\frac{\beta}{M}\right\}\)</span></td>
<td><span
class="math inline">\(1-\frac{m\gamma^2\hat\gamma^2}{M}\)</span></td>
<td><span class="math inline">\(1-\frac{m}{M}\)</span></td>
</tr>
</tbody>
</table>
<p>对于非规范化方向，存在 <span class="math inline">\(\gamma,\tilde
\gamma\in (0,1]\)</span>，使得 <span class="math inline">\(\|x\|\ge
\gamma\|x\|_2\)</span>，<span
class="math inline">\(\|x\|_*\ge\tilde\gamma\|x\|_2\)</span></p>
<p>对于牛顿方法，阻尼牛顿阶段 <span class="math inline">\(K_1\ge
\dfrac{M^2L^2/m^5}{\alpha\beta\min\{1,9(1-2\alpha)^2\}
}(f(x^{(0)})-p^*)\)</span></p>
<p>（<span class="math inline">\(0\le \eta\le
\dfrac{m^2}{L}\)</span>，<span class="math inline">\(\|\nabla
f(x^{(k)})\|_2\ge \eta\)</span>）；</p>
<p>二次收敛阶段 <span class="math inline">\(\|\nabla
f(x^{(k)})\|_2\le\dfrac{L}{2m^2}\|\nabla f(x)\|_2^2\)</span>，认为 <span
class="math inline">\(K_2\ge 6\)</span></p>
<p>（<span class="math inline">\(\|\nabla f(x^{(k)})\|_2\le \eta\le
3(1-2\alpha)^2\dfrac{m^2}{L}\)</span>）</p>
<h3 id="精确直线搜索">精确直线搜索</h3>
<p><span class="math inline">\(t^{(k)}=\arg\min_{s\ge 0}
f(x^{(k)}+sd^{(k)})\)</span></p>
<p>改进值下界 <span
class="math inline">\(f(x^{(k)})-f(x^{(k+1)})\ge\dfrac{|\nabla
f(x^{(k)})^\intercal
d^{(k)}|}{2(d^{(k)})^\intercal\nabla^2f(x^{(k)})d^{(k)}
}\ge\dfrac{\|\nabla f(x^{(k)})\|_2^2}{2M}\)</span></p>
<p>又有 <span
class="math inline">\(f(x^{(k)})-p^*\le\frac{1}{2m}\|\nabla
f(x^{(k)})\|_2^2\)</span></p>
<p>则 <span class="math inline">\(2m(f(x^{(k)})-p^*)\le \|\nabla
f(x^{(k)})\|_2^2\le 2M(f(x^{(k)})-f(x^{(k+1)}))\)</span></p>
<h3 id="回溯直线搜索">回溯直线搜索</h3>
<p><span class="math inline">\(0&lt;\alpha\le 0.5\)</span>，<span
class="math inline">\(0&lt;\beta&lt;1\)</span></p>
<p><code>While</code> <span
class="math inline">\(f(x^{(k)}+t^{(k)}\nabla
f^{(k)})&gt;f(x^{(k)})+\alpha t^{(k)}\nabla f(x^{(k)})^\intercal
d^{(k)}\)</span></p>
<p>​ <span class="math inline">\(t^{(k)}:= \beta t^{(k)}\)</span></p>
<p><code>End</code></p>
<p>只要 <span class="math inline">\(0\le t\le \frac{1}{M}\)</span>
即可满足回溯停止条件，则回溯直线搜索将终止于 <span
class="math inline">\(t=1\)</span> 或 <span
class="math inline">\(t&gt;\frac{\beta}{M}\)</span></p>
<p>则改进值下界 <span
class="math inline">\(f(x^{(k)})-f(x^{(k+1)})\ge\min\{1,\frac{\beta}{M}\}\alpha\|\nabla
f(x^{(k)})\|_2^2\)</span></p>
<h3 id="最速下降方法">最速下降方法</h3>
<p>规范化最速下降方向（给定某范数） <span class="math display">\[
d^{(k)}_{nsd}=\arg\min_d \{\nabla f(x^{(k)})^\intercal d\ |\ \|d\|=1\}
\]</span> 有 <span class="math inline">\(\nabla f(x^{(k)})^\intercal
d^{(k)}_{nsd}=-\|\nabla f(x^{(k)})\|_*\)</span></p>
<p>非规范化最速下降方向 <span class="math display">\[
d_{sd}^{(k)}=\|\nabla f(x^{(k)})\|_* d_{nsd}^{(k)}
\]</span></p>
<p>采用 <span class="math inline">\(l_1\)</span>
范数的下降即坐标下降（收敛性证明见作业）</p>
<h3 id="牛顿下降方法">牛顿下降方法</h3>
<p><span class="math display">\[
d_{nt}^{(k)}=-\nabla^2f(x^{(k)})^{-1}\nabla f(x^{(k)})
\]</span></p>
<p>有 <span class="math inline">\(\arg\min_v \hat
f(x^{(k)}+v)=-\nabla^2f(x^{(k)})^{-1}\nabla f(x^{(k)})\)</span></p>
<p>是梯度线性近似的根：<span
class="math inline">\(f(x^{(k)}+v)\approx\nabla f(x^{(k)})+\nabla^2
f(x^{(k)})v=0\)</span></p>
<p>是 Hessian 范数（P 范数）下的非规范化最速下降方向</p>
<p><strong>牛顿减少量</strong> <span class="math display">\[
\begin{aligned}
\lambda(x^{(k)})&amp;=
\sqrt{\nabla f(x^{(k)})^\intercal\nabla^2f(x^{(k)})^{-1}\nabla
f(x^{(k)})}
\\
&amp;=\sqrt{-\nabla f(x^{(k)})^\intercal d_{nt}^{(k)} }
\\
&amp;=\sqrt{ {d_{nt}^{(k)} }^\intercal \nabla^2 f(x^{(k)}) d_{nt}^{(k)}
}
\end{aligned}
\]</span> <span
class="math inline">\(\dfrac{1}{2}\lambda(x^{(k)})^2\)</span> 是在 <span
class="math inline">\(x^{(k)}\)</span> 处二阶近似对 <span
class="math inline">\(f(x)-p^*\)</span> 做出的估计</p>
<p>停止准则：<span
class="math inline">\(\frac{1}{2}\lambda(x^{(k)})^2\le
\varepsilon\)</span></p>
<p>牛顿回溯直线搜索（要求 <span
class="math inline">\(\alpha&lt;\dfrac{1}{2}\)</span>）</p>
<p><code>While</code> <span
class="math inline">\(f(x^{(k)}+t^{(k)}d_{nt}^{(k)})&gt;f(x^{(k)})-\alpha
t^{(k)}\lambda(x^{(k)})^2\)</span></p>
<p>​ <span class="math inline">\(t^{(k)}:= \beta t^{(k)}\)</span></p>
<p><code>End</code></p>
<p>牛顿步径对座标的仿射变换是独立的</p>
<p><strong>收敛阶段</strong></p>
<p>假设：</p>
<ul>
<li>强凸性</li>
<li>Hessian 矩阵 Lipschitz 连续，<span
class="math inline">\(\|\nabla^2f(y)-\nabla^2f(x)\|_F\le
L\|y-x\|_2\)</span></li>
</ul>
<p>存在 <span class="math inline">\(0&lt;\eta\le\dfrac{m^2}{L}\)</span>
和 <span class="math inline">\(\gamma&gt;0\)</span></p>
<p>阻尼牛顿阶段：<span class="math inline">\(\|\nabla f(x^{(k)})\|_2\ge
\eta\)</span>，则 <span class="math inline">\(f(x^{(k)})-f(x^{(k+1)})\ge
\gamma\)</span></p>
<p>二次收敛阶段：<span class="math inline">\(\|\nabla f(x^{(k)})\|_2&lt;
\eta\)</span>，则 <span class="math inline">\(\dfrac{L}{2m^2}\|\nabla
f(x^{(k+1)})\|_2\le\left( \dfrac{L}{2m^2}\|\nabla
f(x^{(k+1)})\|_2\right)^2\)</span></p>
<p>且 <span class="math inline">\(\|\nabla f(x^{(k)})\|_2&lt; \eta\le
3(1-2\alpha)\dfrac{m^2}{L}\)</span> 时有 <span
class="math inline">\(t^{(k)}=1\)</span></p>
<h2 id="等式约束优化问题">等式约束优化问题</h2>
<p><span class="math display">\[
\begin{aligned}
\min_x &amp;\ \ f(x)\\
\text{s.t.} &amp;\ \ Ax=b
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(A\in \mathbb R ^{p\times
n}\)</span>，<span
class="math inline">\(\operatorname{rank}(A)=p&lt;n\)</span></p>
<h3 id="消除方法">消除方法</h3>
<p>参数化（仿射）可行集： <span
class="math inline">\(\{x|Ax=b\}=\{Fz+\hat x|z\in \mathbb
R^{n-p}\}\)</span></p>
<p>$x f $ 是满足 <span class="math inline">\(A\hat x=b\)</span>
的任意特殊解</p>
<p>消除矩阵 <span class="math inline">\(F\in\mathbb R^{n\times
(n-p)}\)</span> 是值域为 <span class="math inline">\(A\)</span>
的零空间（<span class="math inline">\(Ax=0\)</span> 的 <span
class="math inline">\(n-p\)</span>
个线性无关一维解）的任何矩阵，也就是说，<span
class="math inline">\(\mathcal R(F)=\mathcal N(A)\)</span>，<span
class="math inline">\(AF=0\)</span>。</p>
<p>则转化为以下无约束问题 <span class="math display">\[
\min_{z\in R^{n-p} } f(Fz+\hat x)
\]</span> 简化问题的牛顿方向 <span
class="math inline">\(d_z=-(F^\intercal\nabla^2
f(Fz+x)F)^{-1}F^\intercal\nabla f(Fz+x)\)</span></p>
<p><span class="math inline">\(v^*=-(AA^\intercal)^{-1}A\nabla
f(x^*)\)</span> 为一个最优对偶变量</p>
<p>（证明对偶可行性条件 <span class="math inline">\(\nabla
f(x^*)+A^\intercal v^*=0\)</span>，左乘非奇异矩阵 <span
class="math inline">\(\begin{bmatrix}F^\intercal \\
A\end{bmatrix}\)</span>）</p>
<p>求矩阵 <span class="math inline">\(F\)</span> 亦可选取初等列变换矩阵
<span class="math inline">\(P\)</span> 使得 <span
class="math inline">\(\tilde
A=AP=\begin{bmatrix}A_1&amp;A_2\end{bmatrix}\)</span> 前 <span
class="math inline">\(p\)</span> 个列向量线性无关，令 <span
class="math inline">\(\tilde A\tilde
x=\begin{bmatrix}A_1&amp;A_2\end{bmatrix}\begin{bmatrix}\tilde
x_1\\\tilde x_2\end{bmatrix}=b\)</span>，有 <span
class="math display">\[
x=P\tilde x=P
\left(
\begin{bmatrix}-A_1^{-1}A_2\\I\end{bmatrix}\tilde x_2
+
\begin{bmatrix}-A_1^{-1}b\\0\end{bmatrix}
\right)
\]</span></p>
<h3 id="对偶方法">对偶方法</h3>
<p>目标函数的对偶函数是 <span
class="math inline">\(g(\lambda,v)=-f^*_0(-A^\intercal\lambda-C^\intercal
v)-b^\intercal\lambda-d^\intercal v\)</span>，其中 <span
class="math inline">\(f^*\)</span> 是 <span
class="math inline">\(f_0\)</span> 的对偶函数</p>
<p>则对偶问题是 <span class="math display">\[
\max_v  -f^*(-A^\intercal v)-b^\intercal v
\]</span> 则可求解关于 <span class="math inline">\(v\)</span>
的无约束最优化问题，Slater 条件成立，得 <span
class="math inline">\(g(v^*)=p^*\)</span>，再求解以下无约束最优化问题得到原问题的最优条件
<span class="math inline">\(x^*\)</span> <span class="math display">\[
\min_x f(x)+(v^*)^\intercal (Ax-b)
\]</span></p>
<h3 id="直接求解newton-方法">直接求解（Newton 方法）</h3>
<h4 id="可行初始点">可行初始点</h4>
<p>牛顿方向 <span class="math inline">\(d_x\)</span>
为等式约束的二次近似模型的极小解（<span
class="math inline">\(f(x+d)\)</span> 在 <span
class="math inline">\(x\)</span> 处展开） <span class="math display">\[
\begin{aligned}
\min_d &amp;\ \ \frac{1}{2}d^\intercal \nabla^2 f(x) d+\nabla
f(x)^\intercal d+f(x)\\
\text{s.t.} &amp;\ \ Ad=0
\end{aligned}
\]</span> 得 KKT 方程 <span class="math display">\[
\begin{bmatrix}
\nabla^2 f(x) &amp; A^\intercal\\
A &amp; 0
\end{bmatrix}
\begin{bmatrix}
d_x\\
w
\end{bmatrix}=
\begin{bmatrix}
-\nabla f(x)\\
0
\end{bmatrix}
\]</span> 其中 <span class="math inline">\(w\)</span>
是该问题的最优对偶变量</p>
<p>等式约束问题的牛顿方法与简化后无约束问题牛顿方法的迭代过程完全一致：</p>
<p>令 <span class="math inline">\(d_x=Fd_z\)</span>，其能满足 KKT
方程，其中 <span class="math inline">\(w=-(AA^\intercal)^{-1}A(\nabla
f(x^*)+\nabla^2f(x)d_x)\)</span>；</p>
<p>减少量相等：<span class="math inline">\(\tilde
\lambda(z)^2=d_z^\intercal\nabla^2\tilde f(z)d_z=d_z^\intercal
F^\intercal\nabla^2f(x)Fd_z=d_x^\intercal\nabla^2
f(x)d_x=\lambda(x)^2\)</span>.</p>
<p>其中 <span class="math inline">\(x=Fz+\hat x\)</span></p>
<h4 id="不可行初始点">不可行初始点</h4>
<p>假设 <span class="math inline">\(x+d_x\)</span> 满足最优性条件 <span
class="math inline">\(A(x+d_x)=b\)</span>，<span
class="math inline">\(\nabla f(x+d_x)+A^\intercal
w=0\)</span>；利用梯度一阶近似，有 <span class="math inline">\(\nabla
f(x+d_x)=\nabla f(x)+\nabla^2f(x)d_x\)</span>，则得到方程组 <span
class="math display">\[
\begin{bmatrix}
\nabla^2 f(x) &amp; A^\intercal\\
A &amp; 0
\end{bmatrix}
\begin{bmatrix}
d_x\\
w
\end{bmatrix}=
\begin{bmatrix}
-\nabla f(x)\\
b-Ax
\end{bmatrix}
\]</span> 原对偶解释：令 <span class="math inline">\(y=[x\
v]^\intercal\)</span>，原对偶残差 <span class="math display">\[
r(y)=
\begin{bmatrix}
\nabla f(x)+A^\intercal v\\
Ax-b
\end{bmatrix}
\triangleq
\begin{bmatrix}
r_{dual}(y)\\
r_{pri}(y)
\end{bmatrix}
\]</span> 原残差 <span class="math inline">\(r_{\text{pri}
}(x,v)=Ax-b\)</span>，对偶残差 <span
class="math inline">\(r_{\text{dual} }(x,v)=\nabla f(x)+A^\intercal
v\)</span>；</p>
<p>对原对偶残差使用一阶近似，<span class="math inline">\(r(y+\Delta
y)\approx r(y)+Dr(y)\Delta y\)</span>，可以得到 <span
class="math display">\[
\begin{bmatrix}
\nabla^2 f(x) &amp; A^\intercal\\
A &amp; 0
\end{bmatrix}
\Delta y=
\begin{bmatrix}
-\nabla f(x)-A^\intercal v\\
b-Ax
\end{bmatrix}
\]</span> 整理一下得 <span class="math display">\[
\begin{bmatrix}
\nabla^2 f(x) &amp; A^\intercal\\
A &amp; 0
\end{bmatrix}
\begin{bmatrix}
d_x\\
v+d_v
\end{bmatrix}=
\begin{bmatrix}
-\nabla f(x)\\
b-Ax
\end{bmatrix}
\]</span> 有 <span class="math inline">\(w=v^+=v+d_v\)</span></p>
<p>原问题等价于找到原对偶残差为零的点，停止准则 <span
class="math inline">\(\|r(x^{(k)},v^{(k)})\|_2\le
\varepsilon\)</span></p>
<p><code>While</code> <span
class="math inline">\(\|r(x^{(k)}+td_x^{(k)},
v^{(k)}+td_v^{(k)})\|_2&gt;(1-\alpha
t)\|r(x^{(k)},v^{(k)})\|_2\)</span></p>
<p>​ <span class="math inline">\(t^{(k)}:= \beta t^{(k)}\)</span></p>
<p><code>End</code></p>
<p><strong>收敛性分析</strong></p>
<p>假设</p>
<ol type="1">
<li><span class="math inline">\(S=\{(x,v)\ |\ x\in\operatorname {dom}
f,\|r(x,v)\|_2&lt;\|r(x^{(0)},v^{(0)})\|_2\}\)</span> 是闭集</li>
<li>KKT 逆矩阵有界（<span class="math inline">\(\le K\)</span>）</li>
<li>Lipschitz 条件：存在 <span class="math inline">\(L\)</span>
满足导数差的范数比 <span class="math inline">\(L\)</span>
倍线性函数小</li>
</ol>
<p>阻尼牛顿阶段 <span
class="math inline">\(\|r(y^{(k)})\|_2&gt;\frac{1}{K^2L}\)</span>，二次收敛阶段
<span class="math inline">\(\|r(y^{(k)})\|_2\le
\frac{1}{K^2L}\)</span></p>
<h2 id="等式不等式约束优化问题">等式不等式约束优化问题</h2>
<p><span class="math display">\[
\begin {align}
\min_x\ &amp;f_0(x)  \\
\text{s.t. } &amp;f_i(x)\le 0, &amp;i=1,2,\cdots,m \\
&amp; Ax=b
\end{align}
\]</span></p>
<ul>
<li>函数 <span class="math inline">\(f_i:\mathbb R^n\to \mathbb
R\)</span> 为二次连续可微凸函数；</li>
<li>定义域 <span class="math inline">\(D=\bigcap_{i=0}^m \operatorname
{dom} f_i\)</span>；</li>
<li><span class="math inline">\(A\in \mathbb R^{p\times
n}\)</span>，<span class="math inline">\(\operatorname{rank}
(A)=p&lt;n\)</span>；</li>
<li><span class="math inline">\(p^*=f(x^*)\)</span> 是原问题的解。</li>
</ul>
<p>示性函数 <span class="math display">\[
I_{-}(u)=
\begin{cases}
0, &amp;u\le 0 \\
\infty, &amp; u &gt; 0
\end{cases}
\]</span> 将不等式限制转化为示性函数 <span class="math display">\[
\begin {align}
\min_x&amp;\ \ f_0(x)+\sum_{i=1}^{m} I_{-}(f_i(x))  \\
\text{s.t.}&amp;\ \ Ax=b
\end{align}
\]</span> 示性函数不可微，则使用近似示性函数代替（<span
class="math inline">\(t\)</span> 越大，近似精度逐渐增加） <span
class="math display">\[
\hat I_{-}(u)=-\frac{1}{t}\log(-u)
\]</span> 记对数障碍函数 <span
class="math inline">\(\phi(x)=-\sum_{i=1}^m\log(-f_i(x))\)</span>，有</p>
<ul>
<li><span class="math inline">\(\nabla \phi(x)=\sum_{i=1}^m\dfrac{\nabla
f_i(x)}{-f_i(x)}\)</span></li>
<li><span
class="math inline">\(\nabla^2\phi(x)=\sum_{i=1}^m\dfrac{\nabla
f_i(x)\nabla f_i(x)^\intercal}{f_i(x)^2}+\sum_{i=1}^m\dfrac{\nabla^2
f_i(x)}{-f_i(x)}\)</span></li>
</ul>
<p>不等式线性规划 <span class="math inline">\(Ax\le b\)</span>
的障碍函数 <span
class="math inline">\(\phi(x)=-\sum_{i=1}^m\log(b_i-a_i^\intercal
x)\)</span></p>
<ul>
<li><span
class="math inline">\(\nabla\phi(x)=\sum_{i=1}^{m}\dfrac{a_i}{b_i-a_i^\intercal
x}=A^\intercal d\)</span></li>
<li><span
class="math inline">\(\nabla^2\phi(x)=\sum_{i=1}^{m}\dfrac{a_ia_i^\intercal}{(b_i-a_i^\intercal
x)^2}=A^\intercal\operatorname{diag}(d)^2A\)</span></li>
</ul>
<p>其中 <span class="math inline">\(d_i=1/(b_i-a_i^\intercal
x)\)</span></p>
<h3 id="中心路径">中心路径</h3>
<p><span class="math display">\[
\begin {align}
\min_x&amp;\ \ tf_0(x)+\phi(x)  \\
\text{s.t.}&amp;\ \ Ax=b
\end{align}
\]</span></p>
<p>假定 <span class="math inline">\(\forall t&gt;0\)</span>
该问题能用牛顿方法求解，唯一解 <span
class="math inline">\(x^*(t)\)</span></p>
<p>中心路径：<span class="math inline">\(\{x^*(t)\ |\
t&gt;0\}\)</span>，满足（KKT条件）</p>
<ul>
<li>严格可行性 <span class="math inline">\(Ax^*(t)=b\)</span>，<span
class="math inline">\(f_i(x^*(t))&lt;0\)</span></li>
<li>存在 <span class="math inline">\(\hat v\in\mathbb R^p\)</span> 使得
<span class="math inline">\(t\nabla
f_0(x^*(t))+\nabla\phi(x^*(t))+A^\intercal \hat v =0\)</span></li>
</ul>
<p>现在来研究原对偶问题的原对偶可行性，有 <span
class="math inline">\(\lambda^*_i(t)=-\dfrac{1}{t
f_i(x^*(t))}\)</span>，<span class="math inline">\(v^*(t)=\hat v
/t\)</span>，使得 <span class="math inline">\(\nabla
f_0(x^*(t))+\sum_{i=1}^m\lambda_i^*(t)\nabla f_i(x^*(t))+ A^\intercal
v^*(t)=0\)</span>；则 <span class="math inline">\(\lambda^*,v^*\)</span>
为对偶可行解</p>
<p>而对偶函数 <span class="math display">\[
\begin{aligned}
g(\lambda^*(t),
v^*(t))&amp;=f_0(x^*(t))+\sum_{i=1}^m\lambda_i^*(t)f_i(x^*(t))+  v^*(t)^\intercal(Ax^*(t)-b)\\
&amp;= f_0(x^*(t))-\frac{m}{t}
\end{aligned}
\]</span> 则对偶间隙 <span class="math inline">\(m/t\)</span>，随着
<span class="math inline">\(t\)</span> 增大而收敛</p>
<p>修改的 KKT 方程 <span class="math display">\[
\begin{cases}
f_i(x^*)\le 0 ,&amp; i=1,2,\cdots,m;\\
-\lambda_i^*f_i(x^*)=\dfrac{1}{t},&amp; i=1,2,\cdots,m;\\
\lambda_i^*\ge 0,&amp; i=1,2,\cdots,m;\\
Ax=b\\
\nabla f_0(x^*)+\sum_{i=1}^m\lambda_i^*\nabla f_i(x^*)+A^\intercal v=0
\end{cases}
\]</span> 牛顿步径（等价于求解修改的 KKT 方程一阶线性逼近） <span
class="math display">\[
\begin{bmatrix}
t\nabla^2 f_0(x)+\nabla^2\phi(x) &amp; A^\intercal \\
A &amp; 0
\end{bmatrix}
\begin{bmatrix}
d_x \\
d_v
\end{bmatrix}
=-\begin{bmatrix}
t\nabla f_0(x) + \nabla\phi(x)\\
0
\end{bmatrix}
\]</span></p>
<h3 id="障碍方法">障碍方法</h3>
<p>给定 <span class="math inline">\(t^{(0)}\)</span>，<span
class="math inline">\(\mu&gt;1\)</span>，<span
class="math inline">\(\varepsilon &gt; 0\)</span>，外循环迭代 <span
class="math inline">\(t^{(k+1)}=\mu t^{(k)}\)</span> 直到 <span
class="math inline">\(m/t\le\varepsilon\)</span></p>
<p>外层迭代次数 <span class="math inline">\(N\ge
\left\lceil\dfrac{\log\frac{m}{\varepsilon t^{(0)} }}{\log
\mu}\right\rceil\)</span> 时满足精度要求</p>
<h4 id="阶段-1-方法">阶段 1 方法</h4>
<p>确定 <span class="math inline">\(x\)</span> 满足 <span
class="math inline">\(f_i(x)\le 0\)</span>，<span
class="math inline">\(i=1,2,\cdots,m\)</span> 且 <span
class="math inline">\(Ax =b\)</span></p>
<p><strong>情况一</strong></p>
<p>已知 <span class="math inline">\(x^{(0)}\in \bigcap \operatorname
{dom} f_i\)</span>，且 <span
class="math inline">\(Ax^{(0)}=b\)</span>，则用障碍方法求解阶段 1
优化问题（极小化不可行值的最大值） <span class="math display">\[
\begin {align}
\min_{x,s}&amp;\ \ s  \\
\text{s.t.}&amp;\ \ f_i(x)\le s,\ (i=1,2,\cdots, m) \\
&amp; \ \ Ax=b
\end{align}
\]</span> 记目标最优值 <span class="math inline">\(\bar
p^*\)</span>：</p>
<ul>
<li><span class="math inline">\(\bar p^*&lt;0\)</span>
则有严格可行解</li>
<li><span class="math inline">\(\bar p^*&gt;0\)</span> 则不可行</li>
<li><span class="math inline">\(\bar p^*=0\)</span>
则不等式组可行但不存在严格可行解，如果 <span class="math inline">\(\bar
p^*\)</span> 不可取到，则不等式组不可行</li>
</ul>
<p>可加入限制条件 <span class="math inline">\(f_0(x)\le
M\)</span>（有限制的极小化不可行值的最大值），其中 <span
class="math inline">\(M\ge\max\{f_0(x^{(0)}), p^*\}\)</span></p>
<p>也可以将问题构造为极小化不可行值之和</p>
<p><strong>情况二</strong></p>
<p>已知 <span class="math inline">\(x^{(0)}\in \bigcap \operatorname
{dom} f_i\)</span>，但不满足 <span
class="math inline">\(Ax^{(0)}=b\)</span>，则用不可行初始点牛顿方法求解
<span class="math display">\[
\begin {align}
\min_{x,s}&amp;\ \ t^{(0)}f_0(x)-\sum_{i=1}^{m}\log(s-f_i(x))  \\
\text{s.t.}&amp;\ \ Ax=b,\ s=0 \\
\end{align}
\]</span></p>
<p><strong>情况三</strong></p>
<p>不能在 <span class="math inline">\(\bigcap \operatorname {dom}
f_i\)</span> 中确定一点，用不可行初始点牛顿方法求解 <span
class="math display">\[
\begin {align}
\min_{x,s}&amp;\ \
t^{(0)}f_0(x+z_0)-\sum_{i=1}^{m}\log(s-f_i(x+z_i))  \\
\text{s.t.}&amp;\ \ Ax=b,\ s=0,\ z_i=0 \\
\end{align}
\]</span></p>
<h3 id="原对偶内点法">原对偶内点法</h3>
<p>仅有一层迭代，原对偶迭代值不需要可行；由修改的 KKT
条件定义对偶-中心-原残差 <span class="math display">\[
r_{t}(x,\lambda,v)=
\begin{bmatrix}
r_{\text{dual} }\\
r_{\text{cent} }\\
r_{\text{pri} }
\end{bmatrix}
=\begin{bmatrix}
\nabla f_0(x) + \nabla f(x)\lambda+A^\intercal v\\
-\operatorname{diag}(\lambda) f(x)-(1/t)1\\
Ax-b
\end{bmatrix}
\]</span> 由下式计算原对偶搜索方向 <span class="math inline">\(\Delta
y_{\text{pd} }\)</span>（牛顿步径）</p>
<p><span class="math display">\[
\begin{bmatrix}
\nabla^2 f_0(x)+\sum_{i=1}^m\lambda_i\nabla^2 f_i(x) &amp; \nabla f(x)
&amp; A^\intercal\\
-\operatorname{diag}(\lambda) \nabla f(x)^\intercal
&amp;-\operatorname{diag}(f(x)) &amp; 0\\
A &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix}
\Delta x\\
\Delta \lambda\\
\Delta v
\end{bmatrix}
=
\begin{bmatrix}
r_{\text{dual} }\\
r_{\text{cent} }\\
r_{\text{pri} }
\end{bmatrix}
\]</span></p>
<p>代理对偶间隙 <span class="math inline">\(\hat\eta
(x,\lambda)=-f(x)^\intercal \lambda\)</span></p>
<p>步骤：</p>
<p><code>while</code> <span class="math inline">\(\|r_{\text{pri}
}\|,\|r_{\text{dual} }\|,\hat\eta&gt;\varepsilon\)</span></p>
<ol type="1">
<li><span class="math inline">\(t:=\mu m/\hat\eta\)</span></li>
<li>计算 <span class="math inline">\(\Delta y_{\text{pd} }\)</span></li>
<li>确定步长，更新</li>
</ol>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>偏微分方程复习整理</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="数学基础">数学基础</h2>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p><span class="math display">\[
f(t)=\frac{a_0}{2}+\sum_{n=1}^{\infty}\left[a_n\cos(n\omega
t)+b_n\sin(n\omega t)\right]
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\begin{align}
a_n&amp;=\frac{2}{T}\int_{t_0}^{t_0+T}f(t)\cos(n\omega t)\mathrm d t
&amp;,n\in \mathbb{Z}_+ \nonumber
\\
b_n&amp;=\frac{2}{T}\int_{t_0}^{t_0+T}f(t)\sin(n\omega t)\mathrm d t
&amp;,n\in \mathbb{Z}_+ \nonumber
\end{align}
\]</span></p>
<h3 id="二次型正交变化">二次型正交变化</h3>
<p>设有二次型矩阵 <span class="math inline">\(A\)</span>，<span
class="math inline">\(f(x)=\boldsymbol x^{\mathrm T}A\boldsymbol
x\)</span></p>
<p>存在正交矩阵 <span class="math inline">\(P\)</span> 使 <span
class="math inline">\(\boldsymbol x=P\boldsymbol y\)</span>，<span
class="math inline">\(f(x)=\boldsymbol y^{\mathrm T}P^{\mathrm
T}AP\boldsymbol x=d_1y_1^2+d_2y_2^2+\cdots+d_ny_n^2\)</span></p>
<p>步骤</p>
<ol type="1">
<li>求出 <span class="math inline">\(A\)</span> 的特征值 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span>，（即求解
<span class="math inline">\(|A-\lambda I|=0\)</span>）​</li>
<li>得出对应的特征向量 <span
class="math inline">\(\xi_1,\xi_2,\cdots,\xi_n\)</span>，（即求解 <span
class="math inline">\((A-\lambda_iI)x=0\)</span>）</li>
<li>特征向量标准正交化得 <span
class="math inline">\(\eta_1,\eta_2,\cdots,\eta_n\)</span></li>
<li>得 <span class="math inline">\(P=[\eta_1\ \eta_2\ \cdots\
\eta_n]\)</span></li>
</ol>
<p>应用于梯度算子 <span
class="math inline">\(\boldsymbol{\nabla_x}=\left(\dfrac{\partial}{\partial
x_2},\dfrac{\partial}{\partial x_2}\right)\)</span>
以化简二阶线性微分方程</p>
<h2 id="数学模型">数学模型</h2>
<h3 id="一维弦振动方程">一维弦振动方程</h3>
<p><span class="math display">\[
u_{tt}=a^2u_{xx}+f(x,t)\ ,\ 0&lt;x&lt;l\ ,\ t&gt;0
\]</span></p>
<p>其中 <span class="math inline">\(a^2=T_0/\rho\)</span>，<span
class="math inline">\(f=f_0/\rho\)</span></p>
<h4 id="初始条件">初始条件</h4>
<p><span class="math display">\[
u|_{t=0} = \phi(x)\ ,\ u_t|_{t=0} = \psi(x)
\]</span></p>
<h4 id="边界条件">边界条件</h4>
<ol type="1">
<li><p>第一类边界条件：已知端点的位移随时间的变化</p></li>
<li><p>第二类边界条件：已知端点的受力随时间的变化</p>
<p>设受外力 <span class="math inline">\(\bar g_1(t)\)</span>、<span
class="math inline">\(\bar g_2(t)\)</span></p>
<p>左端 <span class="math inline">\(u_x(0,t)=-\frac{\bar
g_1(t)}{T_0}\)</span></p>
<p>右端 <span class="math inline">\(u_x(l,t)=\frac{\bar
g_2(t)}{T_0}\)</span></p></li>
<li><p>第三类边界条件：端点连接弹簧振子</p>
<p>以左端为例，弹簧长度 <span
class="math inline">\(l_1\)</span>，下端位置 <span
class="math inline">\(Q_1(t)\)</span>，<span
class="math inline">\(\sigma_1=k_1/T_0\)</span></p>
<p>得条件 <span class="math inline">\(u_x(0,t)-\sigma_1
u(0,t)=-\sigma_1(Q_1(t)+l_1)\)</span></p>
<p>右端 <span class="math inline">\(u_x(l,t)+\sigma_2
u(l,t)=\sigma_1(Q_1(t)+l_2)\)</span></p></li>
</ol>
<h3 id="热传导方程">热传导方程</h3>
<p><span class="math display">\[
u_t = a^2\Delta u + f
\]</span></p>
<p>其中 <span class="math inline">\(a^2=k/(\rho c)\)</span>，（<span
class="math inline">\(c\)</span> 为比热容），<span
class="math inline">\(f=f_0/c\)</span>，表示热源强度</p>
<h4 id="初始条件-1">初始条件</h4>
<p><span class="math display">\[
u|_{t=0}=\varphi(x,y,z)
\]</span></p>
<h4 id="边界条件-1">边界条件</h4>
<ol type="1">
<li><p>第一类边界条件：已知边界的温度分布</p></li>
<li><p>第二类边界条件：已知通过边界的热流量 <span
class="math display">\[
\left.k\frac{\partial u}{\partial\boldsymbol
n}\right|_{\partial\Omega}=g(x,y,z,t)
\]</span></p></li>
<li><p>第三类边界条件：导热体置于介质之中 <span class="math display">\[
\frac{\partial u}{\partial\boldsymbol n}+\sigma u=g(x,y,z,t)\ ,\
(x,y,z,t)\in\partial\Omega
\]</span></p></li>
</ol>
<h3 id="泊松方程">泊松方程</h3>
<p>泊松方程即稳态热传导方程</p>
<p><span class="math display">\[
-\Delta u=\frac{1}{a^2}f
\]</span></p>
<p>其中 <span class="math inline">\(f\)</span> 描述热源</p>
<p>当 <span class="math inline">\(f\equiv 0\)</span>
时称为拉普拉斯方程</p>
<h4 id="狄利克雷条件">狄利克雷条件</h4>
<p><span class="math display">\[
u|_{\partial \Omega}=\varphi
\]</span></p>
<h4 id="诺伊曼条件">诺伊曼条件</h4>
<p><span class="math display">\[
\left.\frac{\partial u}{\partial n}\right|_{\partial\Omega}=\varphi
\]</span></p>
<p>或</p>
<p><span class="math display">\[
\left.\left(\frac{\partial u}{\partial n}+\sigma
u\right)\right|_{\partial\Omega}=\varphi
\]</span></p>
<h2 id="叠加原理">叠加原理</h2>
<h3 id="线性算子">线性算子</h3>
<p>以下分别为二阶偏微分算子、波算子、拉普拉斯算子和热算子</p>
<p><span class="math display">\[
\begin{align}
L&amp;=a_{11}\frac{\partial^2}{\partial x^2}
+2a_{12}\frac{\partial^2}{\partial x \partial y}
+a_{22}\frac{\partial^2}{\partial y^2}
+b_1\frac{\partial}{\partial x}
+b_2\frac{\partial}{\partial y}
+c \nonumber
\\
\Box&amp;=\frac{\partial^2}{\partial t^2}-a^2\frac{\partial^2}{\partial
x^2} \nonumber
\\
\Delta&amp;=\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial
y^2} \nonumber
\\
H&amp;=\frac{\partial}{\partial t}-a^2\frac{\partial^2}{\partial x^2}
\nonumber
\end{align}
\]</span></p>
<h3 id="二阶线性偏微分方程">二阶线性偏微分方程</h3>
<p><span class="math display">\[
Lu=f
\]</span></p>
<p>以下为一个带有初始条件和边界条件的弦振动问题</p>
<p><span class="math display">\[
\begin{cases}
&amp; u_{tt} -a^2u_{xx}=f &amp;&amp;,\ 0&lt;x&lt;l\ ,\ t&gt;0 \newline
&amp; u|_{x=0} = g_1(t)  &amp;,\ u|_{x=l} = g_2(t) &amp;,\ t\geq 0
\newline
&amp; u|_{t=0}=\varphi(x)&amp;,\ u_t|_{t=0} = \psi(x) &amp;,\
0&lt;x&lt;l
\end{cases}
\]</span></p>
<h3 id="初始条件叠加原理">初始条件叠加原理</h3>
<h4 id="叠加原理-1">叠加原理 1</h4>
<p>若 <span class="math inline">\(f=\sum_i \alpha_if_i\)</span>，<span
class="math inline">\(\alpha_i\)</span> 为任意常数，<span
class="math inline">\(u_i\)</span> 是 <span
class="math inline">\(Lu=f_i\)</span> 的解，则 <span
class="math inline">\(\sum_i \alpha_iu_i\)</span> 是原问题的解</p>
<h4 id="叠加原理-23">叠加原理 2、3</h4>
<p><em>当将方程叠加时将初始条件和非齐次项一起加在一起</em></p>
<h3 id="边界条件齐次性">边界条件齐次性</h3>
<p>方程边界条件 <span class="math inline">\(u|_{x=0}\ ,\
u|_{x=l}\)</span> 为零时，称为<strong>齐次边界条件</strong></p>
<h4 id="齐次化">齐次化</h4>
<p>采用变换 <span
class="math inline">\(u(x,t)=v(x,t)+w(x,t)\)</span>，其中 <span
class="math inline">\(w(x,t)\)</span> 满足 <span
class="math inline">\(w(0,t)=g_1(t)\ ,\ w(l,t)=g_2(t)\)</span></p>
<p>可以取 <span
class="math inline">\(w(x,t)=g_1(t)+\frac{g_2(t)-g_1(t)}{l}x\)</span></p>
<p>代入可得边界条件齐次化方程</p>
<p>当存在如下边界条件时，<span class="math inline">\(w\)</span>
取以下构造</p>
<ul>
<li><span class="math inline">\(u_x(0,t)=g_1\ ,\
u(l,t)=g_2\)</span>：<span
class="math inline">\(w=(x-l)g_1+g_2\)</span></li>
<li><span class="math inline">\(u(0,t)=g_1\ ,\
u_x(l,t)=g_2\)</span>：<span
class="math inline">\(w=xg_2+g_1\)</span></li>
<li><span class="math inline">\(u_x(0,t)=g_1\ ,\
u_x(l,t)=g_2\)</span>：<span
class="math inline">\(w=xg_1+\frac{g_2-g_1}{2l}x^2\)</span></li>
</ul>
<h2 id="分离变量法">分离变量法</h2>
<h3 id="特征函数法">特征函数法</h3>
<p>即求解非齐次方程的分离变量法，将非齐次项按特征函数系展开</p>
<p>设有齐次边界条件弦振动问题：</p>
<p><span class="math display">\[
\begin{cases}
&amp; u_{tt} -a^2u_{xx}=f &amp;&amp;,\ 0&lt;x&lt;l\ ,\ t&gt;0 \newline
&amp; u|_{x=0} = 0  &amp;,\ u|_{x=l} = 0 &amp;,\ t\geq 0 \newline
&amp; u|_{t=0}=\varphi(x)&amp;,\ u_t|_{t=0} = \psi(x) &amp;,\
0&lt;x&lt;l
\end{cases}
\]</span></p>
<p>求解按如下四步进行</p>
<h4 id="假设分离变量解">假设分离变量解</h4>
<p>设 <span
class="math inline">\(u=X(x)T(t)\)</span>，代入齐次方程得</p>
<p><span class="math display">\[
XT&#39;&#39;=a^2X&#39;&#39;T \Rightarrow
\frac{X&#39;&#39;}{X}=\frac{T&#39;&#39;}{a^2T}
\equiv -\lambda
\]</span></p>
<p>有特征值问题</p>
<p><span class="math display">\[
\begin{cases}
&amp; X&#39;&#39;(x) + \lambda X(x)=0 &amp;,&amp;0&lt;x&lt;l \newline
&amp; X(0) = X(l) = 0
\end{cases}
\]</span></p>
<h4 id="求特征值问题的解">求特征值问题的解</h4>
<p>特征方程的通解为</p>
<p><span class="math display">\[
X(x)=c_1\cos\sqrt{\lambda}l+c_2\sin\sqrt{\lambda}l
\]</span></p>
<p>代入边界条件有 <span class="math inline">\(\sin\sqrt{\lambda}l=0
\Rightarrow \sqrt{\lambda}l=n\pi\)</span></p>
<p>则特征值 <span
class="math inline">\(\lambda_n=\left(\frac{n\pi}{l}\right)^2\)</span>，特征函数
<span class="math inline">\(X_n(x)=\sin\frac{n\pi}{l}x\)</span>，<span
class="math inline">\(n\geq 0\)</span></p>
<h4 id="以特征函数系展开比较">以特征函数系展开比较</h4>
<p>将 <span class="math inline">\(\varphi\)</span>，<span
class="math inline">\(\psi\)</span>，<span
class="math inline">\(f\)</span> 也按特征函数系展开叠加</p>
<p><span class="math display">\[
\begin{align}
\varphi(x)&amp;=\sum_{n=0}^\infty \varphi_n\sin\frac{n\pi}{l}(x)
\nonumber
\\
\psi(x)&amp;=\sum_{n=0}^\infty \psi_n\sin\frac{n\pi}{l}(x) \nonumber
\\
f(x,t)&amp;=\sum_{n=0}^\infty f_n(t)\sin\frac{n\pi}{l}(x) \nonumber
\end{align}
\]</span></p>
<p>代入原方程并比较各项得</p>
<p><span class="math display">\[
\begin{cases}
&amp; T&#39;&#39;(t)+a^2\lambda_nT_n(t)=f_n \newline
&amp; T_n(0) = \varphi(n) \newline
&amp; T_n&#39;(0)= \psi(n)
\end{cases}
\]</span></p>
<p>求解可得各项</p>
<h3 id="平面上泊松方程边值问题">平面上泊松方程边值问题</h3>
<h4 id="极坐标上拉普拉斯方程">极坐标上拉普拉斯方程</h4>
<p><span class="math display">\[
u_{xx}+u_{yy}=u_{\rho\rho}+\frac{1}{\rho}u_\rho+\frac{1}{\rho^2}u_{\theta\theta}=0
\]</span></p>
<p>设 <span
class="math inline">\(u(\rho,\theta)=R(\rho)\varPhi(\theta)\)</span>，<span
class="math inline">\(\varPhi(\theta +
2\pi)=\varPhi(\theta)\)</span>，有</p>
<p><span class="math display">\[
\frac{\varPhi&#39;&#39;(\theta)}{\varPhi(\theta)}
=
-\frac{R&#39;&#39;(\rho)+\frac{1}{\rho}R&#39;(\rho)}{\frac{1}{\rho^2}R(\rho)}
=
-\lambda
\]</span></p>
<p>得特征值问题</p>
<p><span class="math display">\[
\varPhi&#39;&#39;(\theta)+\lambda\varPhi(\theta)=0
\]</span></p>
<p>且有</p>
<p><span class="math display">\[
\rho^2R_n&#39;&#39;(\rho)+\rho R_n&#39;(\rho)-\lambda_nR_n(\rho)=0
\]</span> 此方程为欧拉方程，作代换 <span class="math inline">\(\rho =
\mathrm e^s\)</span>，有 <span class="math display">\[
R_{ss}&#39;&#39;-\lambda_nR_n=0
\]</span></p>
<h2 id="贝塞尔函数">贝塞尔函数</h2>
<h3 id="常系数二阶齐次线性微分方程">常系数二阶齐次线性微分方程</h3>
<p><span class="math display">\[
y&#39;&#39;+ay&#39;+by=0
\]</span></p>
<p>有特征方程</p>
<p><span class="math display">\[
\lambda^2+a\lambda + b=0
\]</span></p>
<p>基解组如下</p>
<ul>
<li><p><span class="math inline">\(\lambda\)</span> 两个不同实根 <span
class="math inline">\(\rho_1\)</span>，<span
class="math inline">\(\rho_2\)</span> <span class="math display">\[
\left\{\mathrm e^{\rho_1x},\mathrm e^{\rho_2x}\right\}
\]</span> 特别的，当 <span
class="math inline">\(\rho_1=\rho=-\rho_2\)</span> <span
class="math display">\[
\left\{
\cosh \rho x=\frac{\mathrm e^{\rho x}+\mathrm e^{-\rho x}}{2},
\sinh \rho x=\frac{\mathrm e^{\rho x} -\mathrm e^{-\rho x}}{2}
\right\}
\]</span></p></li>
<li><p><span class="math inline">\(\lambda\)</span> 两个共轭的复根 <span
class="math inline">\(\rho_{1,2}=\alpha\pm \beta\mathrm{i}\)</span>
<span class="math display">\[
\left\{
\mathrm{e}^{(\alpha+\beta\mathrm{i})x},
\mathrm{e}^{(\alpha-\beta\mathrm{i})x}
\right\}
\]</span> 利用欧拉公式 <span class="math inline">\(\mathrm{e}^{(\alpha+
\beta\mathrm{i})x}=\mathrm{e}^{\alpha x}\cos \beta x+\mathrm{e}^{\alpha
x}\mathrm{i}\sin \beta x\)</span> 并取实部后 <span
class="math display">\[
\left\{
\mathrm{e}^{\alpha x}\cos \beta x,
\mathrm{e}^{\alpha x}\sin \beta x
\right\}
\]</span></p></li>
<li><p><span class="math inline">\(\lambda\)</span> 一个重根 <span
class="math inline">\(\rho_1=\rho_2=\rho\)</span> <span
class="math display">\[
\left\{
\mathrm{e}^{\rho x},
x\mathrm{e}^{\rho x}
\right\}
\]</span></p></li>
</ul>
<h3 id="幂级数解法">幂级数解法</h3>
<p>变系数二阶线性常微分方程 <span class="math display">\[
y&#39;&#39;+p(x)y&#39;+q(x)y=0
\]</span> 若 <span class="math inline">\(p(x)\)</span>、<span
class="math inline">\(q(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 的邻域内解析，那么有如下形式的解
<span class="math display">\[
y(x)=\sum_{k=0}^\infty a_k(x-x_0)^k
\]</span> 否则若 <span class="math inline">\((x-x_0)p(x)\)</span>、<span
class="math inline">\((x-x_0)^2q(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 的邻域内解析，那么有如下形式的解
<span class="math display">\[
y(x)=(x-x_0)^\rho\sum_{k=0}^\infty a_k(x-x_0)^k
\]</span> 其中 <span class="math inline">\(a_0\neq 0\)</span>，<span
class="math inline">\(\rho\in \mathbb{R}\)</span></p>
<h3 id="γ-函数">Γ 函数</h3>
<p><span class="math display">\[
\Gamma(\alpha)=
\begin{cases}
\int_0^\infty x^{\alpha -1}\mathrm e^{-x}\mathrm d x &amp;,\ \alpha
&gt;0
\\
\frac{\Gamma(\alpha + 1)}{\alpha} &amp;,\ \alpha &lt; 0\ \wedge\ \alpha
\notin \mathbb{Z}
\\
\infty &amp;,\ \alpha\leq 0\ \wedge\ \alpha \in \mathbb{Z}
\end{cases}
\]</span></p>
<p>性质</p>
<ul>
<li><span class="math inline">\(\Gamma(1)=1\)</span>，<span
class="math inline">\(\Gamma(1/2)=\sqrt{\pi}\)</span></li>
<li><span
class="math inline">\(\Gamma(\alpha+1)=\alpha\Gamma(\alpha)\)</span></li>
<li><span class="math inline">\(\Gamma(n+1)=n!\)</span>，<span
class="math inline">\(n\in \mathbb{Z}_+\)</span></li>
</ul>
<h3 id="贝塞尔方程">贝塞尔方程</h3>
<p><span class="math inline">\(r\geq 0\)</span> 阶贝塞尔方程</p>
<p><span class="math display">\[
x^2y&#39;&#39;+xy&#39;+(x^2-r^2)y=0
\]</span></p>
<p>化为二阶变系数线性常微分方程标准形式有 <span
class="math inline">\(p(x)=x^{-1}\)</span>，<span
class="math inline">\(q(x)=1-\frac{r^2}{x^2}\)</span>，则 <span
class="math inline">\(xp(x)\)</span>，<span
class="math inline">\(x^2q(x)\)</span> 在 <span
class="math inline">\(\mathbb{R}\)</span> 上解析</p>
<p>有解的形式</p>
<p><span class="math display">\[
y(x)=x^\rho\sum_{n=0}^\infty a_nx^n
\]</span></p>
<p>代入比较系数（此处略去推导）</p>
<p>有 <span class="math inline">\(\rho_1=r\)</span>，<span
class="math inline">\(\rho_2=-r\)</span></p>
<ol type="1">
<li><p>讨论情形 <span class="math inline">\(\rho=\rho_1=r\geq0\)</span>
<span class="math display">\[
J_r(x)=\sum_{k=0}^\infty
(-1)^k\frac{1}{k!\Gamma(k+r+1)}\left(\frac{x}{2}\right)^{2k+r}
\]</span></p></li>
<li><p>讨论情形 <span
class="math inline">\(\rho=\rho_2=-r&lt;0\)</span></p>
<ul>
<li><p><span class="math inline">\(r\)</span> 不为正整数 <span
class="math display">\[
J_{-r}(x)
\]</span></p></li>
<li><p><span class="math inline">\(r\)</span> 为正整数 <span
class="math display">\[
N_n(x)=\lim_{r\to n^+}\frac{J_r(x)\cos(r\pi)-J_{-r}(x)}{\sin(r\pi)}
\]</span></p></li>
</ul></li>
</ol>
<h4 id="贝塞尔函数-1">贝塞尔函数</h4>
<p>有任意 <span class="math inline">\(r\geq 0\)</span>，<span
class="math inline">\(\{J_r(x),N_r(x)\}\)</span>
是贝塞尔方程的基解组</p>
<p>特殊地，<span class="math inline">\(r&gt; 0\)</span>
且不为整数时，<span class="math inline">\(\{J_r(x),J_{-r}(x)\}\)</span>
是贝塞尔方程的基解组</p>
<p>整数阶贝塞尔函数 <span class="math inline">\(J_n(x)\)</span>
的性质</p>
<ul>
<li>奇偶性 <span
class="math inline">\(J_n(x)=(-1)^nJ_n(-x)\)</span></li>
<li>第 <span class="math inline">\(m\)</span> 个正零点 <span
class="math inline">\(\mu_m^{(n)}\)</span></li>
</ul>
<p>递推公式</p>
<p><span class="math display">\[
\begin{align}
(x^nJ_n(x))&#39;&amp;=x^nJ_{n-1}(x) \nonumber\newline
(x^{-n}J_n(x))&#39;&amp;=-x^{-n}J_{n+1}(x) \nonumber\newline
J_{n-1}(x)+J_{n+1}(x)&amp;=\frac{2n}{x}J_n(x) \nonumber\newline
J_{n-1}(x)-J_{n+1}(x)&amp;=2J_n&#39;(x) \nonumber\newline
\end{align}
\]</span></p>
<h3 id="贝塞尔方程特征值问题">贝塞尔方程特征值问题</h3>
<p><span class="math display">\[
u_{\rho\rho}+\frac{1}{\rho}u_\rho+\frac{1}{\rho^2}u_{\theta\theta}=-\lambda
u(\rho,\theta)
\]</span></p>
<p>将 <span class="math inline">\(u\)</span> 变量分离</p>
<p>狄利克雷条件 <span class="math inline">\(u(\rho_0,\theta)=0\)</span>
下，<span class="math inline">\(n\)</span> 阶贝塞尔方程特征值问题</p>
<p><span class="math display">\[
\begin{cases}
\rho^2R&#39;&#39;(\rho)+\rho R&#39;(\rho)+(\lambda^2\rho^2-n^2)R(\rho)=0
&amp;,\ 0&lt;\rho&lt;\rho_0 \newline
R(\rho_0)=0 &amp;,\ |R(0)|&lt;+\infty
\end{cases}
\]</span></p>
<p>特征值 <span
class="math inline">\(\lambda_m=\left(\frac{\mu_m^{}(n)}{\rho_0}\right)^2\)</span>，特征函数
<span
class="math inline">\(R_m(\rho)=J_n\left(\frac{\mu_m^{}(n)}{\rho_0}\rho\right)\)</span>，<span
class="math inline">\(m\ge 1\)</span></p>
<h3
id="贝塞尔函数的正交性与贝塞尔级数">贝塞尔函数的正交性与贝塞尔级数</h3>
<p><span class="math inline">\(f(\rho)\)</span> 在 <span
class="math inline">\([0,\rho_0]\)</span> 连续且有分段连续的一阶导数
<span class="math display">\[
f(\rho)=\sum_{m=1}^\infty
A_mJ_n\left(\frac{\mu_m^{}(n)}{\rho_0}\rho\right)
\]</span> 其中 <span class="math display">\[
A_m=\frac{2}{[\rho_0J_n&#39;(\mu_m^{(n)})]^2}
\int_0^{\rho_0}\rho
f(\rho)J_n\left(\frac{\mu_m^{(n)}}{\rho_0}\rho\right)\mathrm d\rho
\]</span></p>
<h3 id="圆柱体或圆域上定解问题">圆柱体或圆域上定解问题</h3>
<p><span class="math display">\[
\begin{cases}
u_t=a^2\Delta u &amp;,\ (\rho,\theta)\in\Omega &amp;,\ t&gt;0
\\
u|_{\rho=\rho_0}=0 &amp;,\ t\ge 0
\\
u|_{t=0}=\varphi(\rho) &amp;,\ 0\le\rho\le1
\end{cases}
\]</span></p>
<p>令 <span class="math inline">\(u(\rho,t)=R(\rho)T(t)\)</span></p>
<p><span class="math display">\[
\frac{T&#39;}{a^2T}=\frac{R&#39;&#39;+\frac{1}{\rho}R&#39;}{R}=-\lambda
\]</span></p>
<p>是零阶贝塞尔方程特征值问题</p>
<p>特征值 <span
class="math inline">\(\lambda_m=(\mu_m^{(0)})^2\)</span>，特征函数 <span
class="math inline">\(R_m(\rho)=J_0(\mu_m^{(0)}\rho)\)</span>，<span
class="math inline">\(m\ge 1\)</span></p>
<p>特征值代入得 <span class="math display">\[
T_m(t)=A_m\mathrm e^{-a^2(\mu_m^{(0)})^2t}
\]</span> 则 <span class="math display">\[
u(\rho,t)=\sum_{m=1}^{\infty} A_m\mathrm e^{-a^2(\mu_m^{(0)})^2t}
J_0(\mu_m^{(0)}\rho)
\]</span> 展开 <span class="math inline">\(\varphi\)</span> 比较得 <span
class="math display">\[
A_m=\frac{2}{[\rho_0J_0&#39;(\mu_m^{(0)})]^2}
\int_0^{1}\rho
\varphi(\rho)J_0\left(\frac{\mu_m^{(0)}}{\rho_0}\rho\right)\mathrm d\rho
\]</span></p>
<h2 id="格林函数法">格林函数法</h2>
<h3 id="格林公式">格林公式</h3>
<h4 id="高斯公式">高斯公式</h4>
<p><span class="math display">\[
\iiint\limits_{\Omega} \nabla\cdot \boldsymbol F\mathrm d V
=
\iint\limits_{\partial\Omega} \boldsymbol F\cdot\boldsymbol n\mathrm d s
\]</span></p>
<p>其中汉密尔顿算子 <span
class="math inline">\(\nabla=\left(\frac{\partial}{\partial
x},\frac{\partial}{\partial y},\frac{\partial}{\partial
z}\right)\)</span></p>
<p>取 <span class="math inline">\(\boldsymbol F=u\nabla v\)</span>
得三维形式格林公式</p>
<h4 id="格林公式-1">格林公式</h4>
<p><em>《高等数学》所描述的“格林公式”</em></p>
<p>设平面场 <span class="math inline">\(F=(P,Q)\)</span></p>
<p><span class="math display">\[
\iint\limits_{D}\left(\frac{\partial Q}{\partial x}-\frac{\partial
P}{\partial y}\right)\mathrm d S
=
\int\limits_L P\mathrm dx+Q\mathrm dy
\]</span></p>
<p>若记 <span class="math inline">\(\nabla=(\frac{\partial}{\partial
x},\frac{\partial}{\partial y})\)</span>，平面区域 <span
class="math inline">\(\Omega\)</span>，<span
class="math inline">\(\boldsymbol s=(\cos\alpha,\sin\alpha)\)</span>
表示正向边界切向量，那么</p>
<p><span class="math display">\[
\iint\limits_{\Omega}\nabla\times \boldsymbol F \mathrm d \sigma
=
\int\limits_{\partial\Omega} \boldsymbol F\cdot\mathrm d\boldsymbol s
\]</span></p>
<p>有曲面外法向量 <span class="math inline">\(\boldsymbol
n=(\sin\alpha,-cos\alpha)\)</span> 取 <span
class="math inline">\(F=u\nabla
v\)</span>，<em>仔细考虑平面区域积分</em>可得二维形式格林公式</p>
<h4 id="格林第一公式">格林第一公式</h4>
<h5 id="三维">三维</h5>
<p><span class="math display">\[
\iiint\limits_{\Omega} u\Delta v \mathrm dV
=
\iint\limits_{\partial\Omega}u\frac{\partial v}{\partial \boldsymbol n}
\mathrm ds
-
\iiint\limits_{\Omega}\nabla u\cdot\nabla v\mathrm d V
\]</span></p>
<h5 id="二维">二维</h5>
<p><span class="math display">\[
\iint\limits_{\Omega}(uv_x)_x\mathrm d\sigma
=
\int\limits_{\partial\Omega}
v\frac{\partial u}{\partial\boldsymbol n}\mathrm d s
-
\iint\limits_{\Omega}(uv_y)_y\mathrm d\sigma
\]</span></p>
<h4 id="格林第二公式">格林第二公式</h4>
<h5 id="三维-1">三维</h5>
<p><span class="math display">\[
\iiint\limits_{\Omega} (u\Delta u-v\Delta u)\mathrm dV
=
\iint\limits_{\partial\Omega}\left(u\frac{\partial
v}{\partial\boldsymbol n}-v\frac{\partial u}{\partial\boldsymbol
n}\right)\mathrm d s
\]</span></p>
<h5 id="二维-1">二维</h5>
<p><span class="math display">\[
\iint\limits_{\Omega}(v\Delta u-u\Delta v)\mathrm d\sigma
=
\int\limits_{\partial\Omega}\left(v\frac{\partial u}{\partial\boldsymbol
n}-u\frac{\partial v}{\partial\boldsymbol n}\right)\mathrm d s
\]</span></p>
<h4 id="格林第三公式">格林第三公式</h4>
<p>格林第三公式的意义是（除去奇点后）<span
class="math inline">\(u\)</span> 的值仅与 <span
class="math inline">\(\Delta u\)</span> 和边界上的条件决定</p>
<h5 id="三维-2">三维</h5>
<p><span class="math display">\[
u(\xi,\eta,\zeta)
=
\iint\limits_{\partial\Omega}\left(
\varGamma\frac{\partial u}{\partial\boldsymbol n}
-
u\frac{\partial\varGamma}{\partial\boldsymbol n}
\right)
\mathrm ds
-
\iiint\limits_{\Omega}\varGamma\Delta u \mathrm d V
\]</span></p>
<p>其中 <span class="math inline">\(\varGamma=\frac{1}{4\pi
r_{P_0P}}\)</span>，<span
class="math inline">\(r_{P_0P}=\sqrt{(x-\xi)^2+(y-\eta)^2+(z-\zeta)^2}\)</span></p>
<h5 id="二维-2">二维</h5>
<p><span class="math display">\[
u(\xi,\eta)=\int\limits_{\partial\Omega}
\left(\varGamma\frac{\partial u}{\partial\boldsymbol n}
-
u\frac{\partial\varGamma}{\partial\boldsymbol n}
\right)
\mathrm d s
-
\iint\limits_{\Omega}\varGamma\Delta u\mathrm d \sigma
\]</span></p>
<p>其中 <span class="math inline">\(P_0(\xi,\eta)\in
\Omega\)</span>，<span
class="math inline">\(\varGamma(P,P_0)=\frac{1}{2\pi}\ln\frac{1}{\sqrt{(x-\xi)^2+(y-\eta)^2}}\)</span></p>
<h3 id="格林函数法-1">格林函数法</h3>
<h4 id="格林函数">格林函数</h4>
<p>设 <span class="math inline">\(\Omega\)</span>
为二维或三维区域，<span class="math inline">\(\partial\Omega\)</span>
充分光滑，<span class="math inline">\(\boldsymbol
P_0\in\Omega\)</span>，<span class="math inline">\(\varGamma(\boldsymbol
p,\boldsymbol P_0)\)</span> 为拉普拉斯方程基本解</p>
<p>考虑定解问题</p>
<p><span class="math display">\[
\begin{cases}
-\Delta u=f(\boldsymbol p) &amp;,\ \boldsymbol p\in\Omega \newline
u(\boldsymbol p)=\varphi(\boldsymbol p) &amp;,\ \boldsymbol p
\in\partial\Omega
\end{cases}
\]</span></p>
<p>若 <span class="math inline">\(h(\boldsymbol p)\)</span>
是如下定解问题的解</p>
<p><span class="math display">\[
\begin{cases}
\Delta h=0 &amp;,\ \boldsymbol p\in\Omega \newline
h(\boldsymbol p)=-\varGamma(\boldsymbol p,\boldsymbol P_0) &amp;,\
\boldsymbol p \in\partial\Omega
\end{cases}
\]</span></p>
<p>使格林函数 <span class="math inline">\(G(\boldsymbol P,\boldsymbol
P_0)=\varGamma+h\)</span></p>
<p>则 <span class="math inline">\(G\)</span> 为如下定解问题的解</p>
<p><span class="math display">\[
\begin{cases}
\Delta G=\delta(\boldsymbol p,\boldsymbol P_0) &amp;,\ \boldsymbol
p\in\Omega \newline
G(\boldsymbol p,\boldsymbol P_0)=0 &amp;,\ \boldsymbol p
\in\partial\Omega
\end{cases}
\]</span></p>
<p>那么原定解问题的解（三维）可以表示为</p>
<p><span class="math display">\[
u(\xi,\eta,\zeta)=
-\iint\limits_{\partial\Omega}\varphi\frac{\partial
G}{\partial\boldsymbol n}\mathrm ds
+\iiint\limits_{\Omega} Gf\mathrm dV
\]</span></p>
<p>（二维）</p>
<p><span class="math display">\[
u(\xi,\eta)=
-\int\limits_{\partial\Omega}\varphi\frac{\partial
G}{\partial\boldsymbol n}\mathrm ds
+\iint\limits_{\Omega} Gf\mathrm d\sigma
\]</span></p>
<h4 id="应用">应用</h4>
<p>格林函数中 <span class="math inline">\(h\)</span>
的形式仅与给定边界有关，则对于特定问题，先求出格林函数，在通过上述格林函数法的结果给出原定解问题的解</p>
<h5 id="半空间上狄利克雷问题">半空间上狄利克雷问题</h5>
<p><span class="math inline">\(\Omega=\{(x,y,z)\ |\
z&gt;0\}\)</span>，<span class="math inline">\(\partial\Omega=\{(x,y,z)\
|\ z=0\}\)</span></p>
<p>设 <span class="math inline">\(\boldsymbol
P_0\in\Omega\)</span>，<span class="math inline">\(\boldsymbol
P_1\)</span> 为对称点，有 <span
class="math inline">\(G=\varGamma(\boldsymbol P,\boldsymbol
P_0)-\varGamma(\boldsymbol P,\boldsymbol P_1)\)</span></p>
<p>计算</p>
<p><span class="math display">\[
\left.\frac{\partial G}{\partial\boldsymbol n}\right|_{\partial\Omega}
=
\left.\frac{\partial G}{\partial z}\right|_{z=0}
=
-\frac{1}{2\pi}\frac{\zeta}{[(x-\xi)^2+(y-\eta)^2+\zeta^2]^{3/2}}
\]</span></p>
<p>代入格林函数法公式求解</p>
<h5 id="平面圆域上狄利克雷问题">平面圆域上狄利克雷问题</h5>
<p><span class="math inline">\(\Omega=\{(x,y)\ |\
x^2+y^2&lt;R^2\}\)</span></p>
<p>设 <span class="math inline">\(\boldsymbol
P_0\in\Omega\)</span>，<span class="math inline">\(\boldsymbol
P_1\)</span> 为关于圆的反射点，极坐标 <span
class="math inline">\(\boldsymbol P(\rho,\theta)\)</span></p>
<p>格林函数</p>
<p><span class="math display">\[
G(\boldsymbol P,\boldsymbol P_0)=
-\frac{1}{4\pi}\ln\frac{\rho_0^2 R^2+\rho^2R^2-2\rho_0\rho
R^2\cos(\theta_0-\theta)}{R^4+\rho_0\rho^2-2\rho_0\rho
R^2\cos(\theta_0-\theta)}
\]</span></p>
<h2 id="特征线法">特征线法</h2>
<h3 id="一阶线性偏微分方程特征线法">一阶线性偏微分方程特征线法</h3>
<p>有关于 <span class="math inline">\(u(x,t)\)</span>
的一阶线性偏微分方程 <span class="math display">\[
au_t+bu_x+cu=f
\]</span> 其中 <span class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>、<span
class="math inline">\(c\)</span>、<span class="math inline">\(f\)</span>
均为 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(t\)</span> 的函数</p>
<p>特征方程：</p>
<p><span class="math display">\[
a\frac{\mathrm d x}{\mathrm dt}-b=0
\]</span></p>
<p>其积分曲线为上述方程的特征曲线（族）（带有任意常数 <span
class="math inline">\(\tau\)</span>），沿特征曲线有 <span
class="math inline">\(au_t+bu_x=\frac{\mathrm du}{\mathrm d
t}\)</span>，常微分方程求解后将 <span
class="math inline">\(\tau\)</span> 反解代回即可</p>
<h3 id="一阶拟线性偏微分方程特征线法">一阶拟线性偏微分方程特征线法</h3>
<p>一阶偏微分方程柯西问题</p>
<p><span class="math display">\[
\begin{cases}
a(x,t,u)u_x+b(x,t,u)u_t=c(x,t,u) &amp;,\ x\in \mathbb{R} &amp;,\
t&gt;t_0
\\
u(x,t_0)=\varphi(x) &amp;,\ x\in \mathbb{R}
\end{cases}
\]</span></p>
<ol type="1">
<li><p>特征向量场 <span
class="math inline">\(\boldsymbol\alpha=(a,b,c)\)</span></p></li>
<li><p>特征方程组 <span class="math display">\[
\begin{cases}
\dfrac{\mathrm d x}{\mathrm d s}=a(x,t,u) &amp;,\ x(s_0)=\tau
\newline
\dfrac{\mathrm d t}{\mathrm d s}=b(x,t,u) &amp;,\ t(s_0)=t_0
\newline
\dfrac{\mathrm d u}{\mathrm d s}=c(x,t,u) &amp;,\ u(s_0)=\varphi(\tau)
\end{cases}
\]</span></p></li>
</ol>
<p>特征方程组的解称为特征曲线族，其中 <span
class="math inline">\(s_0=t_0\)</span></p>
<p>特征曲线消去参数 <span class="math inline">\(\tau\)</span>、<span
class="math inline">\(s\)</span> 即为原问题的解</p>
<h3 id="一维波动方程特征线法">一维波动方程特征线法</h3>
<p>无界弦振动柯西问题</p>
<p><span class="math display">\[
\begin{cases}
u_{tt}-a^2u_{xx}=0 &amp;,\ -\infty&lt;x&lt;\infty &amp;,\ t&gt;0
\\
u(x,0)=\varphi(x) &amp;,\ u_t(x,0)=\psi(x) &amp;,\
-\infty&lt;x&lt;\infty
\end{cases}
\]</span></p>
<p>特征方程：</p>
<p><span class="math display">\[
\left(\frac{\mathrm du}{\mathrm dt}\right)^2-a^2=0
\]</span></p>
<p>特征线 <span class="math inline">\(x-at=c_1\)</span>，<span
class="math inline">\(x+at=c_2\)</span></p>
<p>得满足微分方程的行波解</p>
<p><span class="math display">\[
u(x,t)=f(x-at)+g(x+at)
\]</span></p>
<p>其中 <span class="math inline">\(f\)</span>，<span
class="math inline">\(g\)</span> 为有二阶连续偏导数的任意函数</p>
<p>根据初始条件有达朗贝尔公式</p>
<p><span class="math display">\[
u(x,t)=
\left[\frac{1}{2}\varphi(x-at)-\frac{1}{2a}\int_0^{x-at}\psi(\alpha)\mathrm
d\alpha\right]
+
\left[\frac{1}{2}\varphi(x+at)+\frac{1}{2a}\int_0^{x+at}\psi(\alpha)\mathrm
d\alpha\right]
\]</span></p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂网络动力学基础课程</title>
    <url>/2021/11/20/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<p>我在之前打数模的时候学了一点复杂网络，虽然学的很浅，感觉还是挺有意思的。</p>
<p>但这个考试完全打消了我对这个学科的喜爱，或者说觉得它不应该作为有考试的课程。这场考试完全就是背诵结论，弄得我毫无兴趣。现在陷入了人生的大思考。</p>
<p>考卷结构大概是 20 分名词解释（10 题），40 分填空（40
个空），余下的证明和计算。我有一个证明题没弄对，填空一堆不记得了，经验公式也不太好推出来，烦躁。</p>
<p>这个课本来是大四下的课，所以像这样背多分，不容易挂，也没人有意见，但是我基本上就惨了，祈求老师能给我分高一点吧。</p>
<p>还是把考前搞的提纲粘出来，要好好背。也有好多考了提纲里没有，要好好看课件。</p>
<h2 id="数理统计">数理统计</h2>
<h3 id="符号">符号</h3>
<p>随机变量 <span class="math inline">\(X\)</span>，观测值 <span
class="math inline">\(x\)</span>，分布函数 CDF <span
class="math inline">\(F(x)=P\{X\le x\}\)</span>，概率密度函数 PDF <span
class="math inline">\(f(x)=F&#39;(x)\)</span></p>
<p>若 <span class="math inline">\(Y=g(X)\)</span>，且 <span
class="math inline">\(\int g(x)f(x)\ \mathrm d x\)</span> 绝对收敛，则
<span class="math inline">\(E[Y]=\int g(x)f(x)\ \mathrm d x\)</span></p>
<h3 id="公式与概念">公式与概念</h3>
<h4 id="极大似然估计">极大似然估计</h4>
<p>设其分布为 <span class="math inline">\(p(x;\theta)\)</span>，似然函数
<span class="math inline">\(L(\theta)=\prod_i
p(x_i;\theta)\)</span>，极大似然估计值 <span
class="math inline">\(\hat\theta=\arg\max_\theta L(\theta)\)</span></p>
<h4 id="高斯积分">高斯积分</h4>
<p><span class="math display">\[
\int_{-\infty}^{+\infty}e^{-ax^2}=\sqrt{\dfrac{\pi}{a}}
\]</span></p>
<h4 id="伽马函数">伽马函数</h4>
<p><span class="math display">\[
\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}\ \mathrm d t
\]</span></p>
<p>有 <span class="math inline">\(\Gamma(x+1)=x\Gamma(x)\)</span>，<span
class="math inline">\(\Gamma(n+1)=n!\)</span>（<span
class="math inline">\(n\)</span> 是整数）；<span
class="math inline">\(\Gamma(1/2)=\sqrt{\pi}\)</span></p>
<h4 id="贝塔函数">贝塔函数</h4>
<p><span class="math display">\[
B(\alpha,\beta)=\int_0^1x^{\alpha-1}(1-x)^{\beta-1}\ \mathrm
dx=\dfrac{\Gamma(\alpha)\Gamma(\beta)}{\Gamma(\alpha+\beta)}
\]</span></p>
<p>其中 <span class="math inline">\(\alpha, \beta&gt;0\)</span></p>
<h3 id="矩母函数">矩母函数</h3>
<p>对一非负随机变量 <span
class="math inline">\(X\)</span>，其矩母函数定义为 <span
class="math display">\[
m_X(t)=E[e^{tX}]=\int e^{tx}f(x)\ \mathrm d x
\]</span> 其中 <span
class="math inline">\(-\infty&lt;t&lt;h\)</span>，<span
class="math inline">\(h\)</span> 是一个正数</p>
<p>样本 <span class="math inline">\(k\)</span> 阶原点矩 <span
class="math inline">\(A_k=\dfrac{1}{n}\sum_i X_i^k\)</span>，<span
class="math inline">\(v_k(X)=\int x^kf(x)\ \mathrm d x\)</span>，中心矩
<span class="math inline">\(B_k=\dfrac{1}{n}\sum_i \left(X_i-\overline
X\right)^k\)</span></p>
<p>对矩母函数（关于 <span
class="math inline">\(t\)</span>）在原点泰勒展开 <span
class="math display">\[
m_X(t)=\sum_{k=0}^\infty \dfrac{E[X^k]t^k}{k!}
\]</span> 则 <span class="math inline">\(X\)</span> 的 <span
class="math inline">\(k\)</span> 阶原点矩 <span
class="math inline">\(E[X^k]\)</span> 就是 <span
class="math inline">\(m_X(t)\)</span> 的 <span
class="math inline">\(k\)</span> 阶导数</p>
<h3 id="特征函数">特征函数</h3>
<p><span class="math display">\[
\phi_X(t)=E[e^{\mathrm i tX}]=\int e^{\mathrm i tx}f(x)
\]</span></p>
<p>类似傅里叶变换 <span
class="math inline">\(F(\omega)=\displaystyle\int f(t)e^{-\mathrm
j\omega t}\ \mathrm d t\)</span></p>
<h3 id="概率母函数">概率母函数</h3>
<p>对于非负离散随机变量 <span
class="math inline">\(X\)</span>，其概率母函数定义为 <span
class="math display">\[
g_X(t)=E[t^{X}]=\sum_{k=0} ^{\infty}t^kP\{X=k\}=\sum_{k=0}
^{\infty}t^kp(k)
\]</span> 类似 Z 变换 <span
class="math inline">\(X(Z)=\sum_{n=0}^{\infty}x(n)Z^{-n}\)</span></p>
<p>有 <span class="math inline">\(g_X(t)=m_X(\ln t)\)</span></p>
<h3 id="常用概率分布">常用概率分布</h3>
<h4 id="柯西分布">柯西分布</h4>
<p>不存在期望和方差 <span class="math display">\[
f_{x_0,\gamma}(x)=\dfrac{1}{\pi\gamma\left[1+\left(\dfrac{1-x_0}{\gamma}\right)\right]}
\]</span></p>
<h4 id="高斯分布">高斯分布</h4>
<p><span class="math display">\[
f_X(x)=\dfrac{e^{-\dfrac{(x-\mu)^2}{2\sigma^2}}}{\sqrt{2\pi}\sigma}
\]</span></p>
<p>其矩母函数 <span class="math inline">\(m_X(t)=e^{\mu
t+\dfrac{\sigma^2}{2}t^2}\)</span></p>
<h4 id="泊松分布">泊松分布</h4>
<p>离散型概率分布（<span class="math inline">\(\lambda&gt;0\)</span>）
<span class="math display">\[
P\{N=k\}=\dfrac{e^{-\lambda}\lambda^k}{k!}
\]</span> 矩母函数 <span
class="math inline">\(m_N(t)=e^{\lambda(e^t-1)}\)</span></p>
<h4 id="二项分布">二项分布</h4>
<p><span class="math inline">\(X\sim B(n,p)\)</span> <span
class="math display">\[
P\{X=k\}=\binom{n}{k}p^k(1-p)^{n-k}
\]</span></p>
<h4 id="卡方分布">卡方分布</h4>
<p>独立同分布的正态平方和 <span
class="math inline">\(X_1^2+X_2^2+\cdots+X_n^2\sim\chi^2(n)\)</span></p>
<p>期望 <span class="math inline">\(n\)</span>，方差 <span
class="math inline">\(2n\)</span></p>
<h4 id="t-分布">t 分布</h4>
<p>设 <span class="math inline">\(X\sim N(0,1)\)</span>，<span
class="math inline">\(Y\sim \chi^2(n)\)</span>，<span
class="math inline">\(t=\dfrac{X}{\sqrt{Y/n}}\sim t(n)\)</span></p>
<p>估计小样本正态分布方差未知的均值</p>
<h4 id="f-分布">F 分布</h4>
<p>设 <span class="math inline">\(U\sim \chi^2(m)\)</span>，<span
class="math inline">\(V\sim\chi^2(n)\)</span>，<span
class="math inline">\(F=\dfrac{U/m}{V/n}\sim F(m, n)\)</span></p>
<h4 id="gamma-分布">Gamma 分布</h4>
<p><span class="math display">\[
f_X(x)=\dfrac{x^{\alpha -1}e^{-x/\beta}}{\beta^\alpha\Gamma(\alpha)}
\]</span></p>
<p>其中 <span class="math inline">\(x&gt;0\)</span>，<span
class="math inline">\(\alpha,\beta&gt;0\)</span></p>
<p>若 <span class="math inline">\(\alpha=1\)</span>，其为指数分布；若
<span class="math inline">\(\beta=2\)</span>，<span
class="math inline">\(\alpha=n/2\)</span>，则是自由度 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(\chi^2\)</span> 分布</p>
<p><span class="math inline">\(\alpha=k+1\)</span>，<span
class="math inline">\(\beta=1\)</span> 时其为 Poisson 分布（<span
class="math inline">\(k\)</span> 为整数）</p>
<p>矩母函数 <span class="math inline">\(m_X(t)=\dfrac{1}{(1-\beta
t)^\alpha}\)</span>，<span class="math inline">\(k\)</span> 阶原点矩
<span
class="math inline">\(E[X^k]=\dfrac{\beta^k\Gamma(\alpha+k)}{\Gamma(\alpha)}\)</span></p>
<p>可加性：若 <span
class="math inline">\(X_i\sim\text{Gamma}(\alpha_i,\beta)\)</span>，则
<span class="math inline">\(\sum_i X_i\sim\text{Gamma}(\sum_i
\alpha_i,\beta)\)</span></p>
<h3 id="假设检验">假设检验</h3>
<h4 id="一般过程">一般过程</h4>
<ol type="1">
<li>原假设（零假设） <span class="math inline">\(H_0\)</span>，对立假设
<span class="math inline">\(H_1\)</span></li>
<li>选定检验统计量 <span
class="math inline">\(g(X_1,X_2,\cdots,X_n)\)</span>，确定 <span
class="math inline">\(H_0\)</span> 成立时统计量 <span
class="math inline">\(g\)</span> 的分布 <span
class="math inline">\(D\)</span></li>
<li>计算显著水平 <span class="math inline">\(0&lt;p&lt;1\)</span> 下
<span class="math inline">\(H_0\)</span> 的临界值 <span
class="math inline">\(g&#39;\)</span>，使 <span
class="math inline">\(F_D(g&#39;)= p\)</span>，则接受域 <span
class="math inline">\(S_0=\{g\ |\ g&gt;g&#39;\}\)</span></li>
<li>判断 <span class="math inline">\(g\)</span> 是否在接受域</li>
</ol>
<p>显著性水平 <span class="math inline">\(p=P\{\text{refuse } H_0\ |\
H_0 \text{ holds}\}\)</span>（以真为假）（第一类错误）</p>
<p>功效 <span class="math inline">\(\eta=P\{\text{accept } H_0\ |\ H_0
\text{ doesn&#39;t hold}\}\)</span>（以假为真）（第二类错误）</p>
<h4 id="q-q-plot-检验">Q-Q Plot 检验</h4>
<p>实际与理论的分位数点比较</p>
<h4 id="kolmogorov-smirnov-检验">Kolmogorov-Smirnov 检验</h4>
<p>经验分布函数 EDF <span class="math inline">\(F_n(x)\)</span>
与分布函数的距离，统计量 <span class="math display">\[
T=\sup_x |F_n(x)-F(x)|
\]</span> 临界值表</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(p\)</span></th>
<th>1%</th>
<th>5%</th>
<th>10%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T_c\)</span></td>
<td><span class="math inline">\(1.63/\sqrt{n}\)</span></td>
<td><span class="math inline">\(1.36/\sqrt{n}\)</span></td>
<td><span class="math inline">\(1.22/\sqrt{n}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="pearson-chi2-检验">Pearson-chi2 检验</h4>
<p>取检验量 <span
class="math inline">\(\chi^2=\sum_i\dfrac{(A_i-T_i)^2}{T_i}\)</span>，其中
<span class="math inline">\(A_i\)</span>，<span
class="math inline">\(T_i\)</span> 分别为区间 <span
class="math inline">\([c_{i-1},c_i)\)</span> 中的实际频数和理论频数</p>
<h3 id="矩阵">矩阵</h3>
<p>共轭转置 <span class="math inline">\(A^\mathrm H=({A^*})^\mathrm
T\)</span></p>
<p>Hermite 矩阵 <span class="math inline">\(A^{\mathrm H}=A\)</span></p>
<p>正则矩阵 <span class="math inline">\(A^{\mathrm H}A=AA^{\mathrm
H}\)</span></p>
<p>正交矩阵 <span class="math inline">\(U^{\mathrm T}U=I\)</span></p>
<p>置换矩阵 <span class="math inline">\(P\)</span>（初等矩阵）</p>
<p>可约矩阵 <span class="math inline">\(L\)</span>
存在上三角分解（满秩）</p>
<p>实对称不可约矩阵 <span class="math inline">\(L\)</span>
的每一行元素和为零，则（1）<span class="math inline">\(0\)</span>
是重特征值；（2）其他特征值小于零；（3）存在正交矩阵 <span
class="math inline">\(\Phi\)</span>，<span
class="math inline">\(L^\mathrm T\phi_i=\lambda_i\phi_i\)</span></p>
<p>Schur 分解：<span class="math inline">\(Q^\mathrm TAQ\)</span>
有上三角分块，每块阶数不大于 2，<span class="math inline">\(Q\)</span>
为正交矩阵</p>
<p>LDU 分解：<span class="math inline">\(A=LDU\)</span>，<span
class="math inline">\(L\)</span> 单位下三角，<span
class="math inline">\(D\)</span> 对角，<span
class="math inline">\(U\)</span> 单位上三角</p>
<p>Shur 补定理（线性矩阵不等式）： <span class="math display">\[
X=\begin{bmatrix}
X_{11}&amp;X_{12}\\
X_{12}^\mathrm T&amp;X_{22}
\end{bmatrix}
\]</span> 下列三个条件等价</p>
<ul>
<li><span class="math inline">\(X&lt;0\)</span></li>
<li><span class="math inline">\(X_{11}&lt;0\)</span>，<span
class="math inline">\(X_{22}-X_{12}^\mathrm
TX_{11}^{-1}X_{12}&lt;0\)</span></li>
<li><span class="math inline">\(X_{22}&lt;0\)</span>，<span
class="math inline">\(X_{11}-X_{12}^\mathrm
TX_{22}^{-1}X_{12}&lt;0\)</span></li>
</ul>
<h2 id="网络特征的数学描述">网络特征的数学描述</h2>
<h3 id="网络静态几何特征">网络静态几何特征</h3>
<h4 id="平均度">平均度</h4>
<p><span class="math display">\[
\left&lt;k\right&gt;=\dfrac{1}{N}\sum_{i=1}^{N}k_i=\dfrac{\operatorname{tr}
(A^2)}{N}
\]</span></p>
<p>其中 <span class="math inline">\(k_i\)</span> 为节点 <span
class="math inline">\(i\)</span> 的度，<span
class="math inline">\(A\)</span> 为网络的邻接矩阵</p>
<h4 id="无标度条件">无标度条件</h4>
<p>有概率分布函数 <span class="math inline">\(F(x)\)</span>，若 <span
class="math inline">\(\forall a\)</span>，<span
class="math inline">\(\exists b\)</span> 使得 <span
class="math inline">\(F(ax)=bF(x)\)</span>，则称 <span
class="math inline">\(F(x)\)</span> 满足无标度条件</p>
<p>幂律分布函数 <span
class="math inline">\(F(x)=f(1)x^{-\gamma}\)</span>，<span
class="math inline">\(\gamma=-f(1)/F(1)\)</span>
是唯一的离散无标度分布</p>
<h4 id="度分布">度分布</h4>
<p><span class="math inline">\(P(k)\)</span> 表示度为 <span
class="math inline">\(k\)</span> 的节点所占比例</p>
<p>累积度分布 <span class="math inline">\(P_k=\sum_{i=k}^{\infty}
P(i)\)</span>，若度分布为幂律分布，<span
class="math inline">\(P_k\propto k^{-(\gamma-1)}\)</span></p>
<h4 id="距离参数">距离参数</h4>
<p>直径 <span class="math inline">\(D\)</span></p>
<p>平均路径长度 <span
class="math inline">\(L=\dbinom{2}{N}^{-1}\sum\limits_{1\le i&lt;j\le
N}d_{ij}\)</span></p>
<h4 id="聚类系数">聚类系数</h4>
<p>节点 <span class="math inline">\(v_i\)</span> 度为 <span
class="math inline">\(k_i\)</span>，其聚类系数 <span
class="math display">\[
C_i=\dfrac{E_i}{\dbinom{2}{k_i}}
\]</span> 其中 <span class="math inline">\(E_i\)</span>
表示邻居之间存在的边数</p>
<p>记 <span class="math inline">\(a_{ij}^{(p)}\)</span> 为邻接矩阵 <span
class="math inline">\(A^p\)</span> 的元，则 <span
class="math inline">\(C_i=\dfrac{a^{(3)}_{ii}}{k_i(k_i-1)}\)</span>，亦有
<span class="math inline">\(k_i=a_{ii}^{(2)}\)</span></p>
<p>网络的聚类系数 <span class="math inline">\(C=\overline C\)</span></p>
<p>聚类系数分布 <span class="math inline">\(P(C)\)</span>
表示聚类系数出现的概率</p>
<h3 id="无向网络静态特性">无向网络静态特性</h3>
<h4 id="联合度分布">联合度分布</h4>
<p><span class="math display">\[
P(k_1,k_2)=\dfrac{M(k_1,k_2)}{M}
\]</span></p>
<p>其中 <span class="math inline">\(M(k_1,k_2)\)</span> 为度值 <span
class="math inline">\(k_1\)</span> 的节点与度值 <span
class="math inline">\(k_2\)</span> 的节点连接总边数</p>
<h4 id="最近邻平均度">最近邻平均度</h4>
<p>节点 <span class="math inline">\(v_i\)</span>
的最近邻平均度（节点邻居的平均度） <span class="math display">\[
k_{nn,i}=\dfrac{\sum_{j}a_{ij}k_j}{k_i}
\]</span> 度值为 <span class="math inline">\(k\)</span>
节点的最近邻平均度平均值 <span class="math display">\[
k_{nn}(k)=\dfrac{\sum_{i | k_i=k}k_{nn,i}}{N\cdot P(k)}
\]</span> 该函数增则为同配网络，否则为异配网络</p>
<h4 id="同配系数">同配系数</h4>
<p>度的 Pearson 相关系数 <span class="math display">\[
r=\dfrac{\overline{k_ik_j}-\left(\dfrac{1}{2}\overline{k_i+k_j}\right)^2}
{\dfrac{1}{2}\overline{k_i^2+k_j^2}-\left(\dfrac{1}{2}\overline{k_i+k_j}\right)^2}
\]</span> 其中 <span class="math inline">\(\overline{f(k_i,kj)}\)</span>
表示 <span class="math inline">\(M^{-1}\sum_{e_{ij}\in
E}f(k_i,k_j)\)</span></p>
<p>注：<span
class="math inline">\(\rho_{XY}=\dfrac{\text{Cov}(X,Y)}{\sqrt{\text{Var}X\cdot\text{Var}Y}}\)</span></p>
<h4 id="聚-度相关性">聚-度相关性</h4>
<p>局部聚类系数 <span class="math display">\[
C(k)=\dfrac{2\overline {M_{nn}(k)}}{k(k-1)}
\]</span> 度为 <span class="math inline">\(k\)</span>
的节点的邻居之间存在的平均边数与这些邻居之间存在的最大可能的边数的比值</p>
<p>全局聚类系数 <span class="math display">\[
C=\dfrac{\sum_{k=0}^{\infty}k(k-1)P(k)C(k)}{\overline{k^2}-\overline k}
\]</span></p>
<h4 id="介数">介数</h4>
<p>节点介数 <span class="math inline">\(B_i\)</span>
表示最短路径途径（比例）和 <span class="math display">\[
B_{i}=\sum_{1\le l&lt;m\le N\wedge l\neq m\neq
i}\dfrac{n_{lm}(i)}{n_{lm}}
\]</span> 边介数 <span class="math inline">\(\widetilde
{B_{ij}}\)</span> 表示所有最短路径经过该边的条数（比例）和 <span
class="math display">\[
\widetilde {B_{ij}}=\sum_{1\le l&lt;m\le N\wedge (l,m)\neq
(i,j)}\dfrac{N_{lm}(e_{ij})}{N_{lm}}
\]</span></p>
<h4 id="核数">核数</h4>
<p><span class="math inline">\(k\)</span>-核是指反复去掉度值小于 <span
class="math inline">\(k\)</span>
的节点及其连线后所剩余的子图，该子图的节点数就是该核的大小</p>
<p>若一个节点存在于 <span class="math inline">\(k\)</span>-核，而在
<span
class="math inline">\((k+1)\)</span>-核中被移去，那么此节点的核数为
<span class="math inline">\(k\)</span></p>
<h4 id="中心性">中心性</h4>
<p>度中心性 <span
class="math inline">\(C_D(v_i)=\dfrac{k_i}{N-1}\)</span></p>
<p>构造同节点数量星形网络，得最大网络度中心性为 <span
class="math display">\[
H=\sum_{i=1}^{N}\left[\max_{u_{\text{star}}}\{C_D(u_{\text{star}})\}-C_D(u_{\text{star},
i})\right]=N-2
\]</span> 网络度中心性 <span
class="math inline">\(C_D=H^{-1}\sum_{i=1}^{N}\left[\max_{u}\{C_D(u)\}-C_D(u_i)\right]\)</span></p>
<p>介数中心性 <span
class="math inline">\(C_B(v_i)=\dfrac{2B_i}{(N-1)(N-2)}\)</span></p>
<p>网络介数中心性 <span
class="math inline">\(C_B=(N-1)^{-1}\sum_{i=1}^{N}\left[\max_{u}\{C_B(u)\}-C_B(u_i)\right]\)</span></p>
<h4 id="pagerank">PageRank</h4>
<p><span class="math inline">\(Ax=\lambda x\)</span>，其中 <span
class="math inline">\(x\)</span>
是网络的特征向量，则节点的特征向量中心性分值 <span
class="math display">\[
C_E(v_i)=x_i=\dfrac{1}{\lambda_{\max}}\sum_{j=1}^{N}a_{ij}x_j
\]</span> Markov 链的状态转移概率矩阵 <span
class="math inline">\(P\)</span>（<span
class="math inline">\(p_{ij}\)</span> 表示由状态 <span
class="math inline">\(i\)</span> 至 <span
class="math inline">\(j\)</span> 的概率） <span class="math display">\[
p_{ij}=\dfrac{1-d}{N}+d\dfrac{b_{ij}}{r_i}
\]</span> 其中 <span class="math inline">\(d\)</span> 为模型参数（常取
<span class="math inline">\(d=0.85\)</span>），<span
class="math inline">\(r_i\)</span> 为行和（链出数目）</p>
<p>正则 Markov 链（<span class="math inline">\(\exists k\)</span>，使
<span
class="math inline">\(a_{ij}^{(k)}&gt;0\)</span>）存在平稳分布（不动点）
<span class="math inline">\(P^{T}x=x\)</span>，即存在特征值为 <span
class="math inline">\(1\)</span> 的特征向量</p>
<h3 id="赋权网络静态特性">赋权网络静态特性</h3>
<h4 id="权重">权重</h4>
<p>边权 <span class="math inline">\(w_{ij}\)</span></p>
<p>点权 <span class="math inline">\(S_i\)</span>：与它相连的边权之和
<span class="math inline">\(\sum_{j\in N_i} w_{ij}\)</span></p>
<p>单位权 <span class="math inline">\(U_i\)</span>：节点连接的平均权重
<span class="math inline">\(U_i=S_i/k_i\)</span></p>
<p>权重分布的差异性 <span
class="math inline">\(Y_i\)</span>：节点连接的边权分布的离散程度 <span
class="math inline">\(\sum_{j\in N_i} (w_{ij}/S_i)^2\)</span></p>
<h4 id="权-度相关性">权-度相关性</h4>
<h5 id="基于节点的权-度相关性">基于节点的权-度相关性</h5>
<p><span class="math display">\[
S_{vv}(k)=\dfrac{\sum_{i|k_i=k}S_i}{N\cdot P(k)}
\]</span></p>
<p>分母：度为 <span class="math inline">\(k\)</span>
的节点个数；分子：度为 <span class="math inline">\(k\)</span>
的所有节点的点权之和</p>
<h5 id="基于边的权-度相关性">基于边的权-度相关性</h5>
<p>赋权最近邻平均度 <span class="math display">\[
k_{w_{nn},i}=\dfrac{\sum_j w_{ij}k_i}{S_i}
\]</span></p>
<ul>
<li>若 <span
class="math inline">\(k_{w_{nn},i}&gt;k_{nn,i}\)</span>，则边权与度正相关</li>
<li>若 <span
class="math inline">\(k_{w_{nn},i}&lt;k_{nn,i}\)</span>，则边权与度负相关</li>
</ul>
<p>其中 <span class="math inline">\(k_{nn,i}\)</span> 为最近邻平均度</p>
<h4 id="赋权聚类系数">赋权聚类系数</h4>
<p>顶点 <span class="math inline">\(i\)</span> 的 Onnela 赋权聚类系数
<span class="math display">\[
C_{\mathrm
O,i}^w=\dfrac{1}{k_i(k_i-1)}\sum_{j,k}(w_{ij}w_{jk}w_{ki})^{\dfrac{1}{3}}
\]</span> 为三角形边权几何平均值与三元组数量的比值</p>
<p>顶点 <span class="math inline">\(i\)</span> 的 Holme 赋权聚类系数
<span class="math display">\[
C_{\mathrm
H,i}^w=\dfrac{\sum_{j,k}w_{ij}w_{jk}w_{ki}}{\max_{j}(w_{ij})\sum_{j,k}w_{ij}w_{ki}}
\]</span></p>
<h3 id="网络的其他静态特性">网络的其他静态特性</h3>
<h4 id="结构熵">结构熵</h4>
<p>节点的重要度 <span class="math inline">\(I_i=k_i/\sum_j
k_j\)</span></p>
<p>结构熵 <span class="math inline">\(E=-\sum_{i|I_i\neq0} I_i\ln
I_i\)</span></p>
<p>结构熵越大，越均匀</p>
<p>归一化结构熵 <span class="math inline">\(\hat
E=\dfrac{E-E_{min}}{E_{max}-E_{min}}\)</span></p>
<p>其中星形网络 <span class="math inline">\(E_{min}=\dfrac{\ln
(4(N-1))}{2}\)</span></p>
<p>均匀网络 <span class="math inline">\(E_{max}=\ln N\)</span></p>
<h4 id="特征谱">特征谱</h4>
<p>Wigner 半圆定理：<span class="math inline">\(A_{n_1}\in\mathbb
R^{N\times N}\)</span> 每一个非对角线元素独立同分布且服从高斯分布 <span
class="math inline">\(N(0,1)\)</span>，对角线独立同分布于 <span
class="math inline">\(N(0,2)\)</span>，Wigner 矩阵 <span
class="math inline">\(W_{n_1}=\dfrac{1}{\sqrt{N}}A_{n_1}\)</span>
的谱分布服从半圆律 <span class="math display">\[
f_{SC}(x)=\begin{cases}
\dfrac{1}{2\pi}\sqrt{4-x^2},&amp;|x|\le 2\\
0, &amp; |x|&gt;2
\end{cases}
\]</span> 网络的 Laplacian 矩阵 <span
class="math inline">\(L=D-A\)</span>，其中 <span
class="math inline">\(D\)</span> 为各节点的度的对角矩阵</p>
<p>由于 <span class="math inline">\(L\)</span>（或 <span
class="math inline">\(A\)</span>）是实对称矩阵，有 N 个实特征值 <span
class="math inline">\(\lambda_j\)</span>（有重）</p>
<p>谱密度 <span class="math display">\[
\rho(\lambda)=\dfrac{1}{N}\sum_{j=1}^N\delta(\lambda-\lambda_j)
\]</span> 谱密度的 <span class="math inline">\(p\)</span>-阶矩 <span
class="math display">\[
\begin{aligned}
M_p&amp;=\dfrac{1}{N}\int_{-\infty}^{+\infty}\lambda^p\rho(\lambda)\
\mathrm d\lambda\\
&amp;=\dfrac{1}{N}\sum_{j=1}^N\lambda_j^p\\
&amp;=\dfrac{1}{N}\operatorname{tr}(A^p)\\
&amp;=\dfrac{1}{N}\sum_{i_1,i_2,\cdots,i_p}a_{i_1i_2}a_{i_2i_3}\cdots
a_{i_pi_1}
\end{aligned}
\]</span> 右侧即长为 <span class="math inline">\(p\)</span>
的闭合回路总数</p>
<h2 id="经典复杂网络模型分析">经典复杂网络模型分析</h2>
<h3 id="规则网络">规则网络</h3>
<ul>
<li>全局耦合网络（GCN）</li>
<li>最近邻耦合网络（NCN）</li>
<li>星形耦合网络（SCN）</li>
</ul>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 20%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>网络类型</th>
<th>度</th>
<th>直径 <span class="math inline">\(D\)</span></th>
<th>平均路径长度 <span class="math inline">\(L\)</span></th>
<th>聚类系数 <span class="math inline">\(C_i\)</span>，<span
class="math inline">\(C\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>全局耦合网络</td>
<td><span class="math inline">\(N-1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(C_i=C=1\)</span></td>
</tr>
<tr class="even">
<td>最近邻耦合网络</td>
<td><span class="math inline">\(K\)</span></td>
<td><span class="math inline">\(N/K\)</span></td>
<td><span class="math inline">\(\approx N/(2K)\)</span></td>
<td><span
class="math inline">\(C_i=C=\dfrac{3(K-2)}{4(K-1)}\)</span></td>
</tr>
<tr class="odd">
<td>星形耦合网络</td>
<td><span class="math inline">\(1\)</span> 或 <span
class="math inline">\(N-1\)</span></td>
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(2-2/N\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
</tbody>
</table>
<h3 id="随机网络">随机网络</h3>
<p>ER：所有可能边中选取 <span class="math inline">\(m\)</span> 条</p>
<p>二项式模型：以概率 <span class="math inline">\(p\)</span>
连接，边数期望 <span class="math inline">\(pN(N-1)/2\)</span></p>
<p>如果 <span class="math inline">\(N\to\infty\)</span>
时产生一个具有性质 <span class="math inline">\(Q\)</span> 的 ER
随机网络的概率为 <span
class="math inline">\(1\)</span>，那么就称几乎每一个 ER
随机网络都具有性质 <span class="math inline">\(Q\)</span> ；如若 <span
class="math inline">\(p&gt;p_c\propto (\ln N)/N\)</span>，几乎每一个 ER
网络都是联通的。</p>
<p>性质：</p>
<ul>
<li>度分布为 Poisson 分布（平均度 <span
class="math inline">\(p(N-1)\)</span>）</li>
<li>平均距离 <span class="math inline">\(L_{ER}\propto\dfrac{\ln N}{\ln
\left&lt;k\right&gt;}\)</span> 短（小世界特性）</li>
<li>聚类系数 <span
class="math inline">\(C_{ER}=\dfrac{\left&lt;k\right&gt;}{N-1}=p\)</span>
小</li>
<li>特征谱半圆分布（<span
class="math inline">\(p=cN^{-z}\)</span>，<span
class="math inline">\(0&lt;z&lt;1\)</span>）(<span
class="math inline">\(z&gt;1\)</span> 时不然)</li>
</ul>
<h3 id="小世界网络">小世界网络</h3>
<p>性质</p>
<ul>
<li><span class="math inline">\(L\)</span> 短；<span
class="math inline">\(C\)</span> 高，Poisson 分布</li>
</ul>
<p>WS：NCN 网络按概率 <span class="math inline">\(p\)</span>
重新随机连接</p>
<p>NW：NCN 网络按概率 <span class="math inline">\(p\)</span>
随机加边</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>网络类型</th>
<th>度分布</th>
<th>平均路径长度 <span class="math inline">\(L\)</span></th>
<th>平均聚类系数 <span class="math inline">\(C\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WS</td>
<td>近似泊松，至少 <span class="math inline">\(K/2\)</span></td>
<td><span class="math inline">\(\dfrac{2N}{K}f(NKp/2)\)</span></td>
<td><span
class="math inline">\(\dfrac{3(K-2)}{4(K-1)}(1-p)^3\)</span></td>
</tr>
<tr class="even">
<td>NW</td>
<td></td>
<td></td>
<td><span
class="math inline">\(\dfrac{3(K-2)}{4(K-1)+4K(p+2)}\)</span></td>
</tr>
</tbody>
</table>
<p>其中 <span
class="math inline">\(f(u)\approx(2\sqrt{u^2+2u})\operatorname
{arctanh}\sqrt{\dfrac{u}{u+2}}\)</span></p>
<p>小世界网络特征谱类似尖峰</p>
<h3 id="无标度网络">无标度网络</h3>
<p>Scale-Free Network</p>
<p>BA 网络，<span class="math inline">\(P\{k=x\}\propto
x^{-\gamma}\)</span>，<span class="math inline">\(2&lt;\gamma
&lt;3\)</span></p>
<ul>
<li><p>增长，初始节点数 <span class="math inline">\(m_0\)</span>
每次增加节点连接 <span class="math inline">\(m\)</span> 条边</p></li>
<li><p>优先连接：新节点 <span class="math inline">\(v\)</span>
与已经存在的节点 <span class="math inline">\(v_i\)</span> 连接的概率
<span class="math inline">\(\Pi_i\)</span> 与度 <span
class="math inline">\(k_i\)</span> 正相关</p></li>
</ul>
<h4 id="连续场模型">连续场模型</h4>
<p><span
class="math inline">\(\Pi_i=\dfrac{k_i+1}{\sum_j(k_j+1)}\)</span>；<span
class="math inline">\(t_i\)</span> 为 <span
class="math inline">\(v_i\)</span> 加入网络的时间节点，有 <span
class="math inline">\(k_i(t_i)=m\)</span>，<span
class="math inline">\(\dfrac{\mathrm dk_i}{\mathrm
dt}=m\Pi_i(t)\)</span>：</p>
<ul>
<li>解得 <span class="math inline">\(k_i(t)=m\sqrt{t/t_i}\)</span></li>
<li>假设等时间间隔加入，该时间段 <span class="math inline">\(t\)</span>
内某节点 <span class="math inline">\(v_i\)</span> 度分布为常数 <span
class="math inline">\(P\{k_i(t)&lt;k\}=P\{t_i&gt;\dfrac{m^2}{k^2}t\}\)</span></li>
</ul>
<p>解得 BA 模型的度分布 <span class="math display">\[
P\{k_i=k\}=\dfrac{\mathrm d P\{t_i&gt;\dfrac{m^2}{k^2}t\}}{\mathrm d
k}=\dfrac{2m^2t}{m_0+t}\cdot\dfrac{1}{k^3}
\]</span></p>
<h4 id="速率方程法">速率方程法</h4>
<h5 id="求解度分布">求解度分布</h5>
<p>设 <span class="math inline">\(t\)</span> 时刻拥有 <span
class="math inline">\(k\)</span> 条边的节点数（期望）为 <span
class="math inline">\(N_k(t)\)</span>，有 <span
class="math inline">\(\sum_k kN_k(t)=2mt\)</span> <span
class="math display">\[
\dfrac{\mathrm dN_k(t)}{\mathrm d
t}=m\dfrac{(k-1)N_{k-1}(t)-kN_k(t)}{\sum_k kN_k(t)}+\delta_{km}
\]</span> 边界条件 <span class="math display">\[
\delta_{km}=\begin{cases}
1,&amp; k=m;\\
0,&amp; k\neq m.
\end{cases}
\]</span> 求解，有 <span class="math inline">\(N_k(t)\approx
tP\{k_i=k\}\)</span>（大数定律 <span class="math inline">\(t\gg
1\)</span>）</p>
<p>简化为 <span
class="math inline">\((k+2)P\{k_i=k\}=(k-1)P\{k_i=k-1\}+2\delta_{km}\)</span></p>
<p>递推得 <span
class="math inline">\(P\{k_i=k\}=\dfrac{2m(m+1)}{k(k+1)(k+2)}\propto
2m^2k^{-3}\)</span></p>
<h5 id="求解度相关性">求解度相关性</h5>
<p>令 <span class="math inline">\(m=1\)</span>，设 <span
class="math inline">\(t\)</span> 时刻连接的度分别为 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(l\)</span> 的节点对数量为 <span
class="math inline">\(N_{k,l}(t)\)</span> <span class="math display">\[
\dfrac{\mathrm dN_{kl}(t)}{\mathrm d t}=
\dfrac{(k-1)N_{k-1,l}(t)-kN_{k,l}(t)}{2t}
+
\dfrac{(l-1)N_{k,l-1}(t)-lN_{k,l}(t)}{2t}
+(l-1)N_{l-1}\delta_{kl}
\]</span> 化简为递归关系略；该递归关系证明了 <span
class="math inline">\(n_{kl}\neq n_kn_l\)</span>，即存在度相关性</p>
<h4 id="其他参数">其他参数</h4>
<p>平均路径长度 <span class="math display">\[
L\propto
\begin{cases}
\ln\ln N, &amp;2&lt;\gamma&lt;3,\\
\dfrac{\ln N}{\ln\ln N}, &amp; \gamma =3,\\
\ln N, &amp; \gamma &gt; 3,
\end{cases}
\]</span> 平均聚类系数</p>
<p>高于 ER，幂律衰减</p>
<p>特征谱</p>
<p>三角形，幂律衰减</p>
<p>随机攻击鲁棒性（无阈值现象），故意攻击脆弱性（阈值很小）</p>
<p>对于随机网络，无论是故意攻击还是随机故障，只要所移除的节点比例超过一个阈值，
网络的极大连通分支中的节点比例将近似为零</p>
<h3 id="层次网络">层次网络</h3>
<h4 id="聚-度相关性-1">聚-度相关性</h4>
<p><span class="math inline">\(C_H(k)\)</span> 表示度值为 <span
class="math inline">\(k\)</span> 的平均聚类系数</p>
<p>层次性：<span class="math inline">\(C_H(k)\propto
k^{-a}\)</span>，<span class="math inline">\(a\)</span> 为层次指数</p>
<h3 id="确定性网络">确定性网络</h3>
<h4 id="确定性小世界网络">确定性小世界网络</h4>
<p>从三角形开始，对每一条新加入的边构建一个新的三角形</p>
<p>点数 <span class="math inline">\(N_t=3\cdot 2^t\)</span>，边数 <span
class="math inline">\(M_t=3(2^{t+1}-1)\)</span></p>
<p>平均聚类系数 0.6931，度分布是指数分布</p>
<h4 id="确定性无标度网络">确定性无标度网络</h4>
<p>阿波罗网络</p>
<h4 id="waxman-随机图产生器">Waxman 随机图产生器</h4>
<p>连边概率正比于反指数距离</p>
<h2 id="传播动力学">传播动力学</h2>
<h3 id="概念">概念</h3>
<ul>
<li>S（Susceptible）</li>
<li>I（Infected）</li>
<li>R（Removed / Recovered）</li>
</ul>
<h3 id="si-模型">SI 模型</h3>
<p><span class="math inline">\(i(t)=I(t)/N\)</span>；<span
class="math inline">\(s(t)=S(t)/N\)</span>；<span
class="math inline">\(i+s=1\)</span></p>
<p>所有个体脆弱，感染永远染病，感染率（每个 <span
class="math inline">\(I\)</span> 个体单位时间感染数量与 <span
class="math inline">\(s\)</span> 的比值）不变，个体总数不变 <span
class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=-\alpha i s\\
\dfrac{\mathrm d i}{\mathrm d t}=\alpha i s\\
\end{cases}
\]</span> 分离变量解得 <span
class="math inline">\(i(t)=\dfrac{1}{1+(1/i_0-1)e^{-\alpha
t}}\)</span></p>
<h3 id="sis-模型">SIS 模型</h3>
<p>加入单位时间治愈率 <span
class="math inline">\(\beta\)</span>，会反复发作 <span
class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=-\alpha i s+\beta i\\
\dfrac{\mathrm d i}{\mathrm d t}=\alpha i s-\beta i\\
\end{cases}
\]</span> 解伯努利方程</p>
<p>有效传播率 <span
class="math inline">\(\lambda=\alpha/\beta\)</span>，阈值为 <span
class="math inline">\(\lambda_c=1\)</span></p>
<h3 id="sir-模型">SIR 模型</h3>
<p>被治愈免疫 <span class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=-\alpha i s\\
\dfrac{\mathrm d i}{\mathrm d t}=\alpha i s-\beta i\\
\dfrac{\mathrm d r}{\mathrm d t}=\beta i\\
\end{cases}
\]</span> 无解析解，<span class="math inline">\(\lambda&gt;1\)</span>
则所有人最终 R，<span class="math inline">\(\lambda\le 1\)</span>
则会剩余 S</p>
<h3 id="sirs">SIRS</h3>
<p>R 以概率 <span class="math inline">\(\gamma\)</span> 成为 S <span
class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=\gamma r-\alpha i s\\
\dfrac{\mathrm d i}{\mathrm d t}=\alpha i s-\beta i\\
\dfrac{\mathrm d r}{\mathrm d t}=\beta i-\gamma r\\
\end{cases}
\]</span></p>
<h3 id="均匀网络传播动力学">均匀网络传播动力学</h3>
<p>平均场理论 MFT</p>
<h4 id="基于-sis">基于 SIS</h4>
<p>染病密度 <span class="math inline">\(\rho(t)\)</span>，易感密度 <span
class="math inline">\(1-\rho(t)\)</span></p>
<p>假设 <span class="math inline">\(k_i\approx \left
&lt;k\right&gt;\)</span>（均匀性），<span
class="math inline">\(\lambda\propto
\rho(t)\)</span>（均匀混合），总数不变；不妨令 <span
class="math inline">\(\beta=1\)</span>（单位速率） <span
class="math display">\[
\dfrac{\mathrm d \rho}{\mathrm dt}=-\rho+\lambda
\left&lt;k\right&gt;\rho(1-\rho)
\]</span> 稳态解 <span
class="math inline">\(\rho=\dfrac{\lambda-\lambda_c}{\lambda}\)</span>，<span
class="math inline">\(\lambda_c=\dfrac{1}{\left&lt;k\right&gt;}\)</span></p>
<h4 id="基于-sir">基于 SIR</h4>
<p><span class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=-\lambda\left&lt;k\right&gt; i s\\
\dfrac{\mathrm d i}{\mathrm d t}=\lambda\left&lt;k\right&gt; i s- i\\
\dfrac{\mathrm d r}{\mathrm d t}=i\\
\end{cases}
\]</span></p>
<p>有 <span class="math inline">\(\dfrac{\mathrm d
s}{s}=-\lambda\left&lt;k\right&gt; \mathrm d r\)</span>，则 <span
class="math inline">\(s=e^{-\lambda\left&lt;k\right&gt; r}\)</span>，得
<span class="math inline">\(r(\infty)=1-e^{-\lambda\left&lt;k\right&gt;
r(\infty)}\)</span></p>
<p>存在非平凡解则满足 <span
class="math inline">\(\left.\lambda\left&lt;k\right&gt;e^{-\lambda\left&lt;k\right&gt;
r(\infty)}\right|_{r(\infty)\to0}\ge 1\)</span>，则有 <span
class="math inline">\(\lambda\ge\dfrac{1}{\left&lt;k\right&gt;}\)</span></p>
<p>泰勒展开得 <span class="math inline">\(r(\infty)\propto
(\lambda-\lambda_c)\)</span></p>
<h3 id="非均匀网络传播动力学">非均匀网络传播动力学</h3>
<h4 id="基于-sis-1">基于 SIS</h4>
<p>度为 <span class="math inline">\(k\)</span> 的节点染病密度 <span
class="math inline">\(\rho_k(t)\)</span> <span class="math display">\[
\dfrac{\mathrm d \rho_k}{\mathrm dt}
=-\rho_k+\lambda k(1-\rho_k)\sum_{k&#39;}P(k&#39; | k)\rho_{k&#39;}
\operatorname{tr}iangleq -\rho_k+\lambda k(1-\rho_k)\Theta(\rho_k)
\]</span> 求解稳态解，<span
class="math inline">\(\rho_k=\dfrac{k\lambda\Theta}{1+k\lambda\Theta}\)</span></p>
<p>对于没有度度相关性的无标度网络，<span class="math inline">\(P(k&#39;
| k)=\dfrac{k&#39;P(k&#39;)}{\left&lt;k\right&gt;}\)</span></p>
<p>稳态密度估算值 <span
class="math inline">\(\rho=\sum_kP(k)\rho_k\)</span></p>
<p>可得 <span class="math inline">\(\Theta\)</span> 的自治方程 <span
class="math inline">\(\Theta
=\dfrac{1}{\left&lt;k\right&gt;}\sum_{k&#39;}\dfrac{k&#39;^2P(k&#39;)\lambda\Theta}{1+k&#39;\lambda\Theta}\)</span></p>
<p>若要存在非平凡解，要求 <span
class="math inline">\(\dfrac{\lambda\left&lt;k^2\right&gt;}{\left&lt;k\right&gt;}\ge
1\)</span>，即 <span
class="math inline">\(\lambda_c=\dfrac{\left&lt;k\right&gt;}{\left&lt;k^2\right&gt;}\)</span></p>
<h4 id="基于-sir-1">基于 SIR</h4>
<p>类似地，<span class="math inline">\(\Theta(t)=\sum_{k&#39;}P(k&#39; |
k)i_{k&#39;}\)</span> <span class="math display">\[
\begin{cases}
\dfrac{\mathrm d s}{\mathrm d t}=-\lambda ks_k\Theta\\
\dfrac{\mathrm d i}{\mathrm d t}=\lambda ks_k\Theta- i\\
\dfrac{\mathrm d r}{\mathrm d t}=i\\
\end{cases}
\]</span> 解得传播阈值完全一致</p>
<h3 id="免疫策略">免疫策略</h3>
<h4 id="随机免疫">随机免疫</h4>
<h5 id="均匀网络-sis-模型">均匀网络 SIS 模型</h5>
<p>免疫节点密度 <span
class="math inline">\(\delta\)</span>，随机网络下，传染率 <span
class="math inline">\((1-\delta)\lambda\)</span>，代入得免疫临界值 <span
class="math inline">\(\delta_c=1-\dfrac{\lambda_c}{\lambda}\)</span></p>
<p>稳态感染密度 <span
class="math inline">\(\rho_{\delta}=\dfrac{\delta_c-\delta}{1-\delta}\)</span>，传播阈值
<span class="math inline">\(\tilde
\lambda_c=\dfrac{\lambda_c}{1-\delta}\)</span></p>
<h5 id="无标度网络-sir-模型">无标度网络 SIR 模型</h5>
<p><span
class="math inline">\(\delta_c=1-\dfrac{\lambda_c}{\lambda}\)</span>，<span
class="math inline">\(\tilde
\lambda_c=\dfrac{\lambda_c}{1-\delta}\)</span></p>
<h4 id="目标免疫">目标免疫</h4>
<h5 id="非均匀网络-sir-模型">非均匀网络 SIR 模型</h5>
<p><span class="math display">\[
\delta_k=
\begin{cases}
1 ,&amp; k&gt;\mathcal K,\\
c ,&amp; k=\mathcal K,\\
0 ,&amp; k&lt;\mathcal K.\\
\end{cases}
\]</span></p>
<p>免疫平均概率 <span class="math inline">\(\overline
\delta=\sum_k\delta_kP(k)\)</span></p>
<p>目标免疫后传播阈值 <span class="math inline">\(\hat
\lambda_c&gt;\dfrac{\lambda_c}{1-\overline \delta}\)</span></p>
<p>就无标度网络而言，免疫临界值 <span
class="math inline">\(\delta_c\propto
e^{-\dfrac{2}{m\lambda}}\)</span>，其中 <span
class="math inline">\(\delta=\sum_{k&gt;kt}P(k)\)</span></p>
<h2 id="复杂网络的同步动力学">复杂网络的同步动力学</h2>
<h3 id="li-yorke-混沌系统">Li-Yorke 混沌系统</h3>
<p>迭代：<span
class="math inline">\(f^{(n)}(x)=f(f^{(n-1)}(x))\)</span></p>
<p>周期点：对于某个 <span class="math inline">\(x_0\)</span>，有 <span
class="math inline">\(f^{(n)}(x_0)=x_0\)</span>，但对 <span
class="math inline">\(k&lt;n\)</span>，<span
class="math inline">\(f^{(k)}(x_0)\neq x_0\)</span>，则称 <span
class="math inline">\(x_0\)</span> 是一个 <span
class="math inline">\(n\)</span>-周期点</p>
<p>混沌：<span class="math inline">\(f(x)\)</span> 在闭区间 <span
class="math inline">\(X\)</span> 上连续自映射，若</p>
<ol type="1">
<li>存在任意周期的周期点，且周期无上界；</li>
<li>（不收敛不发散）<span class="math inline">\(X\)</span>
上存在不可数子集 <span class="math inline">\(S\subset X\)</span>，<span
class="math inline">\(x_0\notin S\)</span>，使
<ul>
<li><span class="math inline">\(\forall x,y\in S\)</span>，<span
class="math inline">\(x\neq y\)</span>，<span
class="math inline">\(\lim_{n\to\infty}
\inf|f^{(n)}(x)-f^{(n)}(y)|=0\)</span></li>
<li><span class="math inline">\(\forall x,y\in S\)</span>，<span
class="math inline">\(x\neq y\)</span>，<span
class="math inline">\(\lim_{n\to\infty}
\sup|f^{(n)}(x)-f^{(n)}(y)|&gt;0\)</span></li>
<li><span class="math inline">\(\forall x\in S\)</span>，<span
class="math inline">\(p\)</span> 为任意周期点，<span
class="math inline">\(\lim_{n\to\infty}
\inf|f^{(n)}(x)-f^{(n)}(p)|=0\)</span></li>
</ul></li>
</ol>
<p>则 <span class="math inline">\(f(x)\)</span> 在区间 <span
class="math inline">\(S\)</span> 上是混沌的</p>
<p>Li-York 论断：有 3-周期点则蕴涵混沌</p>
<h3 id="混沌">混沌</h3>
<p>混沌模型的特征</p>
<ul>
<li>初始值高度敏感</li>
<li>有界（整体稳定性）：不会走出混沌吸引子</li>
<li>随机性：任意区域概率密度不为零</li>
<li>遍历性：可达到吸引子内任何不稳定周期轨道的任何邻域，且不会重复</li>
<li>普适性：不依赖具体的系统方程</li>
<li>正 Lyapunov
指数：相空间相邻两条轨道按指数速度分离或聚合的平均变化率</li>
</ul>
<p>n-周期轨道：当 <span class="math inline">\(x_0\)</span> 为一个 <span
class="math inline">\(n\)</span> 周期点，称 <span
class="math inline">\(\{x_0,f^{(1)}(x_0),\cdots,f^{(n-1)}(x_0)\}\)</span>
为 <span class="math inline">\(f(x)\)</span> 的一个 n-周期轨道</p>
<p>例：Logistic 映射 <span class="math inline">\(f(x)=\alpha
x(1-x)\)</span>，<span class="math inline">\(0&lt;\alpha \le 1\)</span>
时稳定不动点 <span class="math inline">\(0\)</span>；<span
class="math inline">\(1&lt;\alpha&lt;3\)</span> 稳定不动点 <span
class="math inline">\(1-1/\alpha\)</span>；<span
class="math inline">\(\alpha=3\)</span> 产生 <span
class="math inline">\(2\)</span>-周期点；<span
class="math inline">\(\alpha&gt;3.57\)</span> 迅速产生倍周期分岔</p>
<h3 id="lyapunov-指数">Lyapunov 指数</h3>
<h4 id="一维">一维</h4>
<p>一维动力学系统 <span
class="math inline">\(x_{n+1}=F(x_n)\)</span></p>
<p>假设每次映射迭代对 <span class="math inline">\(x_{0}\)</span>，<span
class="math inline">\(x_{0}+\varepsilon\)</span> 引起指数分离 <span
class="math display">\[
\varepsilon
e^{n\sigma(x_0)}=\left|F^{(n)}(x_0+\varepsilon)-F^{(n)}(x_0)\right|
\]</span> 取极限 <span class="math display">\[
\sigma(x_0)
=\lim_{n\to\infty}\lim_{\varepsilon\to
0}\dfrac{1}{n}\ln\left|\dfrac{F^{(n)}(x_0+\varepsilon)-F^{(n)}(x_0)}{\varepsilon}\right|
=\lim_{n\to\infty}
\dfrac{1}{n}\ln\left|\dfrac{\mathrm dF^{(n)}(x)}{\mathrm d x}\right|
\]</span> 将 <span class="math inline">\(F^{(n)}(x)\)</span>
链式法则展开裂项相消得 Lyapunov 指数 <span class="math display">\[
\sigma =
\lim_{n\to\infty}\dfrac{1}{n}\sum_{i=1}^n\ln\left|\dfrac{\mathrm
dF(x)}{\mathrm d x}\right|_{x=x_i}
\]</span></p>
<h4 id="高维">高维</h4>
<p><span class="math inline">\(m\)</span> 维离散动力学系统，设 <span
class="math inline">\(F:\mathbb R^{m}\to\mathbb R^m\)</span></p>
<p>初始值选取无穷小的 <span class="math inline">\(m\)</span>
维球面，将迭代后椭球的所有主轴按长度 <span
class="math inline">\(p_i^{(n)}\)</span> 排列，第 <span
class="math inline">\(i\)</span> 个 Lyapunov 指数 <span
class="math display">\[
\sigma_i = \lim_{n\to\infty}\dfrac{1}{n}\ln\dfrac{p_i^{(n)}}{p_i^{(0)}}
\]</span> 设 <span class="math inline">\(F_J(X)\)</span> 表示 <span
class="math inline">\(F\)</span> 在 <span
class="math inline">\(X\)</span> 的 Jacobian 矩阵，<span
class="math inline">\(J_k=F_J(X_0)F_{j}(X_1)\cdots
F_J(X_{k-1})\)</span>，将 <span class="math inline">\(J_k\)</span> 的
<span class="math inline">\(m\)</span> 个复特征值取模后排列得 <span
class="math inline">\(\lambda_i^{(k)}\)</span> <span
class="math display">\[
\sigma_i = \lim_{n\to\infty}\dfrac{1}{n}\ln\left|\lambda_i^{(k)}\right|
\]</span></p>
<h3 id="混沌同步">混沌同步</h3>
<p>两个子系统构成的动力学系统 <span class="math display">\[
\begin{cases}
\dot X=F(X,Y,t)\\
\dot Y=G(X,Y,t)
\end{cases}
\]</span> 若存在时间无关映射 <span class="math inline">\(H:\mathbb
R^n\times\mathbb R^m\to\mathbb R^k\)</span> 使 <span
class="math display">\[
\lim_{t\to\infty}\|H(\phi_X,\phi_Y)\|=0
\]</span> 其中 <span class="math inline">\(\phi_X\)</span>，<span
class="math inline">\(\phi_Y\)</span>
分别为其轨道的抽象性质，引出四种同步定义：完全同步、相位同步、滞后同步、广义同步</p>
<p>仅讨论完全同步 <span class="math display">\[
\lim_{t\to\infty}\|X(t)-Y(t)\|=0
\]</span> 沿同步流形上所有条件 Lyapunov 指数小于零</p>
<h4 id="基于条件-lyapunov-指数的稳定性判据">基于条件 Lyapunov
指数的稳定性判据</h4>
<p>误差系统 <span class="math inline">\(Z=X-Y\)</span>，动力学微分方程组
<span class="math inline">\(\dot Z=F(Z)\)</span>，假设 <span
class="math inline">\(0\)</span> 是平衡点，<span
class="math inline">\(F(Z)\)</span> 在区域 <span
class="math inline">\(G=\{Z\ | \ \|Z\|\le a, a&gt;0\}\)</span>
有连续偏导数</p>
<h5 id="第一方法间接法">第一方法（间接法）</h5>
<p>线性化扰动方程 <span class="math display">\[
\dfrac{\mathrm d}{\mathrm d t}\delta Z(t)=L\delta Z(t)
\]</span> 其中 <span class="math inline">\(L\)</span> 是 <span
class="math inline">\(F(Z)\)</span> 在 <span
class="math inline">\(Z=0\)</span> 处的 Jacobi 矩阵</p>
<p>条件 Lyapunov 指数 <span class="math display">\[
\sigma_i = \lim_{n\to\infty}\dfrac{1}{n}\ln\left|\dfrac{\partial
z_i{(t)}}{\partial z_i{(0)}}\right|
\]</span> 若所有指数小于零，则趋于稳定</p>
<h5 id="第二方法直接法">第二方法（直接法）</h5>
<p>构造正定标量函数 <span class="math inline">\(V(Z)\)</span>
作为虚拟广义能量函数</p>
<p>Lyapunov 函数 <span class="math inline">\(V(Z)\)</span> 为 <span
class="math inline">\(\|Z\|\le a\)</span>
内定义的一个实连续标量函数，<span
class="math inline">\(V(0)=0\)</span>，正定。假设对所有变量偏导数存在且连续，动力学方程组解条件下对时间求导得
<span class="math inline">\(V(Z)\)</span> 关于动力学方程组的全导数 <span
class="math display">\[
\left.\dfrac{\mathrm dV(Z)}{\mathrm d t}\right|_{\dot Z=F(Z)}
=
\sum_{i=1}^{m}\left(\dfrac{\partial V(Z)}{\partial
z_i}\cdot\dfrac{\mathrm d z_i}{\mathrm d t}\right)
=
\sum_{i=1}^{m}\left(\dfrac{\partial V(Z)}{\partial z_i}\cdot
f_i(Z)\right)
\]</span> 判定定理</p>
<ul>
<li>若存在 <span
class="math inline">\(V(Z)\)</span>，其关于动力学方程组的全导数半负定或为零，则系统零解稳定</li>
<li>若存在 <span
class="math inline">\(V(Z)\)</span>，其关于动力学方程组的全导数负定，则系统零解渐进稳定</li>
<li>若存在 <span
class="math inline">\(V(Z)\)</span>，其关于动力学方程组的全导数半负定，但使全导数为零的点
<span class="math inline">\(Z\)</span> 只有 <span
class="math inline">\(Z=0\)</span>（其他解负），则系统零解渐进稳定</li>
</ul>
<h4 id="同步方法">同步方法</h4>
<p>驱动-响应法（P-C 同步法）</p>
<p>考虑 <span class="math inline">\(n\)</span> 维自治动力学系统 <span
class="math inline">\(\dot U=F(U)\)</span> 的两个子系统 <span
class="math display">\[
\begin{cases}
\dot V=G(V,W)\\
\dot W=H(V,W)
\end{cases}
\]</span>
第一个是稳定系统，第二个是混沌系统；上述系统构成驱动系统，构造响应系统
<span class="math inline">\(\dot W&#39;=H(V,W&#39;)\)</span>，则 <span
class="math inline">\(W\)</span> 与 <span
class="math inline">\(W&#39;\)</span> 受相同驱动变量 <span
class="math inline">\(V\)</span> 驱动，其误差系统 <span
class="math inline">\(\dot Z=\dot W-\dot
W&#39;=H(V,W)-H(V,Z-W)\)</span></p>
<h3 id="复杂动态网络的完全同步">复杂动态网络的完全同步</h3>
<p>考虑一个以 <span class="math inline">\(N\)</span> 个相同的动力学系统
<span class="math inline">\(\dot X_i=F(X_i)\)</span>
作为节点所构成的连续时间耗散耦合动态网络，该网络状态方程 <span
class="math display">\[
\dot X_i=F(X_i)+c\sum_{j=1}^N l_{ij}HX_j
\]</span> 其中 <span class="math inline">\(c&gt;0\)</span>
为耦合强度，<span class="math inline">\(H\)</span>
为内部耦合函数（输出函数），其为对角阵，描述进行耦合的状态变量，完全同步时
<span class="math inline">\(H=0\)</span></p>
<p><span class="math inline">\(l_{ij}\)</span> 构成外耦合矩阵 <span
class="math inline">\(L\)</span>，表示网络的拓扑结构，行和为零（可用拉普拉斯矩阵）；<span
class="math inline">\(L\)</span> 仅有一个重数为 <span
class="math inline">\(1\)</span> 的零特征值，对应特征向量为 <span
class="math inline">\(1\)</span> 向量，其他特征值均为负实数</p>
<p>网络完全同步：<span class="math inline">\(\lim_{t\to\infty}
X_i(t)=S(t)\)</span>（可达到同步状态 <span
class="math inline">\(S(t)\)</span>）</p>
<p>若耦合强度与外耦合矩阵每个负特征值的积都在同步化范围内 <span
class="math inline">\(c\lambda_k\in
U\)</span>，则渐近稳定；根据同步化区域 <span
class="math inline">\(U\)</span> 不同类型分为</p>
<ul>
<li>类型 I 网络 <span
class="math inline">\(U=(-\infty,\alpha_1)\)</span>，则 <span
class="math inline">\(c\lambda_2&lt;\alpha_1\)</span> 时稳定</li>
<li>类型 II 网络 <span
class="math inline">\(U=(\alpha_1,\alpha_2)\)</span>，则 <span
class="math inline">\(c\lambda_2&lt;\alpha_1\)</span>，<span
class="math inline">\(c\lambda_N&gt;\alpha_2\)</span> 时稳定</li>
<li>类型 III 网络 <span class="math inline">\(U=\emptyset\)</span></li>
</ul>
<h4 id="均匀网络">均匀网络</h4>
<p>最近邻网络 <span
class="math inline">\(\lim_{N\to\infty}\lambda_2=0\)</span>，当 <span
class="math inline">\(N\)</span> 很大时 <span
class="math inline">\(\lambda_N/\lambda_2\)</span> 很大</p>
<p>全局耦合网络 <span
class="math inline">\(\lambda_2=\lambda_3=\cdots=-N\)</span></p>
<p>星形网络 <span class="math inline">\(\lambda_2=-1\)</span>，<span
class="math inline">\(\lambda_N=-N\)</span></p>
<h4 id="nw-小世界网络">NW 小世界网络</h4>
<p>随着 <span class="math inline">\(p\)</span>
不断增加，第二特征值线性变小直至趋近 <span
class="math inline">\(-N\)</span></p>
<h4 id="ws-小世界网络">WS 小世界网络</h4>
<p>随着 <span class="math inline">\(p\)</span>
不断增加，第二特征值一次变小直至趋近 <span
class="math inline">\(-N\)</span></p>
<h4 id="无标度网络-1">无标度网络</h4>
<p><span class="math inline">\(\lambda_2\)</span> 随着 <span
class="math inline">\(m\)</span> 增加而下降，随 <span
class="math inline">\(N\)</span> 增加而上升，<span
class="math inline">\(\lim_{N\to\infty}\lambda_2=\tilde
\lambda_2&lt;0\)</span>（<span class="math inline">\(10^{-1}\)</span>
数量级）</p>
<p>若随机删除节点，特征值很快逼近 <span
class="math inline">\(0\)</span></p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言与编译提纲</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<h2 id="自动机理论">自动机理论</h2>
<h3 id="dfa-nfa-re">DFA-NFA-RE</h3>
<p>DFA 是五元组 <span
class="math inline">\((Q,\Sigma,\delta,q_0,F)\)</span>，分别表示状态，符号集，迁移函数，开始状态，接收状态集</p>
<p>DFA 扩展转移函数 <span
class="math inline">\(\hat\delta:Q\times\Sigma^*\to Q\)</span></p>
<p>NFA 是五元组 <span
class="math inline">\((Q,\Sigma,\delta,q_0,F)\)</span>，其中 <span
class="math inline">\(\delta:Q\times\Sigma\to2^Q\)</span></p>
<p>NFA 扩展转移函数 <span
class="math inline">\(\hat\delta:Q\times\Sigma^*\to 2^Q\)</span></p>
<p><span class="math inline">\(\mathrm \varepsilon\)</span>-NFA 是五元组
<span class="math inline">\((Q,\Sigma,\delta,q_0,F)\)</span>，其中 <span
class="math inline">\(\delta:Q\times(\Sigma\cup\{\varepsilon\})\to2^Q\)</span></p>
<ul>
<li><span class="math inline">\(\mathrm \varepsilon\)</span>-NFA 到
DFA：<span class="math inline">\(\mathrm{ECLOSE}(r)\)</span>
与子集构造</li>
<li>NFA 到 DFA：（惰性）子集构造，<span
class="math inline">\(O(n^32^n)\)</span></li>
<li>DFA 到 RE：消除状态得 GNFA，<span
class="math inline">\(O(n^34^n)\)</span>；证明：归纳法</li>
<li>RE 到 <span class="math inline">\(\varepsilon\)</span>-NFA：<span
class="math inline">\(O(n)\)</span></li>
</ul>
<p>泵引理证正则：</p>
<blockquote>
<p>存在 <span class="math inline">\(n\)</span> 使得对任意 <span
class="math inline">\(w\in L\)</span>，若 <span
class="math inline">\(|w|\ge n\)</span>，我们能写成 <span
class="math inline">\(w=xyz\)</span>，其中 <span
class="math inline">\(|xy|\le n\)</span>，<span
class="math inline">\(|y|\ge 1\)</span>，且 <span
class="math inline">\(\forall k\geq 0, xy^kz\in L\)</span></p>
</blockquote>
<p>泵引理证非正则使用反证法，由上推论引出矛盾。或者</p>
<blockquote>
<p>对于任意 <span class="math inline">\(n\)</span> 存在串 <span
class="math inline">\(w\in L\)</span>，且 <span
class="math inline">\(|w|\ge n\)</span>，使得对任意书写 <span
class="math inline">\(w=xyz\)</span>，<span
class="math inline">\(|xy|\leq n\)</span>，<span
class="math inline">\(|y|\ge 1\)</span>，存在 <span
class="math inline">\(k\ge 0\)</span> 使 <span
class="math inline">\(xy^k z\notin L\)</span></p>
</blockquote>
<p>正则语言的封闭运算：交并补、连接反向、闭包</p>
<ul>
<li>交 <span class="math inline">\(L\cap L&#39;\)</span>：状态对</li>
<li>并 <span class="math inline">\(L\cap L\)</span>：揉起来</li>
<li>补 <span class="math inline">\(L^C\)</span>：DFA
改变接收状态拒绝状态</li>
<li>连接 <span
class="math inline">\(LL&#39;\)</span>：正则表达式连接</li>
<li>逆 <span class="math inline">\(L^R\)</span>：DFA 反向</li>
<li>幂 <span class="math inline">\(L^k\)</span>：<span
class="math inline">\(k\)</span> 个表达式连接</li>
<li>闭包 <span class="math inline">\(L^*\)</span>：表达式的闭包</li>
</ul>
<p>DFA 最小化：区分状态等价类填 <span
class="math inline">\(n\times(n-1)\)</span> 的下三角表</p>
<p>DFA 等价性：放在一起填表，区分开始状态是不是等价</p>
<h3 id="pda-cfg-cfl">PDA-CFG-CFL</h3>
<p>CFG 是四元组 <span class="math inline">\(G=(V,T,\mathscr
P,S)\)</span>，分别是变元集，终结符集，产生式集，开始符号</p>
<p>产生式惯用法</p>
<ul>
<li>变元：字母表开头大写字母 A，B，C</li>
<li>终结符：字母表开头小写字母 a，b，c</li>
<li>符号（终结符或变元）：字母表结束大写字母 X，Y，Z</li>
<li>终结符串：字母表结束小写字母 w，x，y，z</li>
<li>符号串：<span class="math inline">\(\alpha\)</span>，<span
class="math inline">\(\beta\)</span>，<span
class="math inline">\(\gamma\)</span></li>
</ul>
<p>直接推导 <span class="math inline">\(\alpha A\beta\Rightarrow
\alpha\gamma\beta \iff A\to\gamma\)</span></p>
<p>连续推导 <span class="math inline">\(\alpha
A\beta\stackrel{*}{\Rightarrow} \alpha\gamma\beta \iff
A\Rightarrow\cdots\Rightarrow \gamma\)</span></p>
<p>多于一次的推导 <span class="math inline">\(\alpha
A\beta\stackrel{+}{\Rightarrow} \alpha\gamma\beta\)</span></p>
<p>最左推导 <span
class="math inline">\(\stackrel{lm}{\Rightarrow}\)</span>，最右推导
<span class="math inline">\(\stackrel{rm}{\Rightarrow}\)</span></p>
<p>句型：从开始符号推导的任意串</p>
<p>句子：从开始符号推导的终结符串</p>
<p>规约：序列 <span
class="math inline">\(\alpha_1,\cdots,\alpha_n\)</span>，其中 <span
class="math inline">\(\alpha_1=w\)</span>，<span
class="math inline">\(\alpha_n=S\)</span>，<span
class="math inline">\(\alpha_i\Leftarrow \alpha_{i+1}\)</span></p>
<p>歧义文法：该文法存在一个串是多个语法树的产物；该文法存在一个串存在两个不同最左推导</p>
<p>固有歧义的：语言的每个文法均是歧义的</p>
<p>CFG 化简：</p>
<ul>
<li>消除 <span
class="math inline">\(\varepsilon\)</span>-产生式：删去可空变元，重写产生式，若出现无用符号则消除</li>
<li>消除单位产生式：对于单位产生式推导的序列，以最后的产生式（组）替代单位产生式的产生式变元（检查所有变元序对）</li>
<li>无用符号（先消无产出后消不可达）
<ul>
<li>无产出的变元：推导不出终结符串（无候选式、死循环）</li>
<li>不可达符号：不出现在任意句型中的符号</li>
</ul></li>
</ul>
<p>乔姆斯基范式：每个产生式右侧仅有两个变元或一个终结符</p>
<p>PDA 是七元组 <span
class="math inline">\((Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)\)</span>，分别为状态集，输入字母集，栈字母集，迁移函数
<span class="math inline">\(\delta:Q\times(\Sigma\cup
\{\varepsilon\})\to 2^{Q\times
\Gamma*}\)</span>，初始状态，开始符号，终结状态集</p>
<p>PDA 的移动 <span class="math inline">\((p,\gamma)\in
\delta(q,a,X)\)</span>：状态 <span class="math inline">\(q\)</span>
移动到 <span class="math inline">\(p\)</span>，消耗输入符号 <span
class="math inline">\(a\)</span>，使用 <span
class="math inline">\(\gamma\)</span> 替代 <span
class="math inline">\(X\)</span> 作为新栈顶</p>
<p>PDA 图示边标记格式：输入符号，弹出符号/压入符号串</p>
<p>瞬时描述 ID：<span
class="math inline">\((q,w,\alpha)\)</span>，当前状态，剩余串和栈内容</p>
<p>迁移：ID <span class="math inline">\(I\)</span> 在一次移动变为 ID
<span class="math inline">\(J\)</span>，记为 <span
class="math inline">\(I\vdash J\)</span></p>
<p>定理 6.5 与 6.6：串里看不见的符号不影响迁移</p>
<p>终结状态定义语言，空栈定义语言可互相模拟</p>
<p>确定性 PDA：至多存在一个迁移（可以是 <span
class="math inline">\(\varepsilon\)</span>-迁移）</p>
<ul>
<li>CFG 到 PDA：仅三个状态，迁移模拟移入，<span
class="math inline">\(\varepsilon\)</span>-迁移模拟规约</li>
<li>PDA 到 CFG</li>
</ul>
<h2 id="编译原理">编译原理</h2>
<p>源语言、实现语言、目标语言</p>
<p>宿主机器、目标机器</p>
<p>词法分析、语法分析、语义分析、代码优化、代码生成</p>
<p>源程序、中间表示、目标代码</p>
<p>词法分析（&lt;种属，值&gt;）：关键字一符一种、全体一种</p>
<h2 id="语法分析">语法分析</h2>
<h3 id="自上而下语法分析">自上而下语法分析</h3>
<p>LL(1) 文法：无二义性，无回溯（无左递归，无左公因子，候选式 FIRST
不相交，若候选首符含空则其 FIRST 交 FOLLOW 为空）</p>
<p>LL(1) 分析：从左到右扫描，最左推导，向前查看一个</p>
<p>消除左递归：对非终结符排序，对每个终结符看前面的终结符，将代带入前面终结符的候选，消除直接左递归（<span
class="math inline">\(E\to E\alpha\ |\ \beta\)</span> 到 <span
class="math inline">\(E\to \beta E&#39;\)</span>；<span
class="math inline">\(E&#39;\to \alpha E&#39;\ |\
\varepsilon\)</span>）</p>
<p>FIRST(<span class="math inline">\(\alpha\)</span>)：串 <span
class="math inline">\(\alpha\)</span>
能推导出来的串的最左侧终结符（或空符）集合</p>
<p>求解 FIRST 迭代法：首先构造非终结符 FIRST，然后根据串构造</p>
<p>FOLLOW(A)：所有句型中符号 A 右侧的终结符（或结束符）</p>
<p>求解 FOLLOW：先求 FIRST，后遍历产生式</p>
<p>提左公因子：加变元消去公因子</p>
<p>递归下降语法分析：每个变元构造一个过程</p>
<p>构造预测分析表 <code>M[A, a]</code>，对于每一个产生式 <span
class="math inline">\(A\to\alpha\)</span>：</p>
<ul>
<li>对任意 <span
class="math inline">\(a\in\mathrm{FIRST}(\alpha)\)</span>，<code>M[A, a]</code><span
class="math inline">\(= A\to\alpha\)</span></li>
<li>若 <span class="math inline">\(\varepsilon\in
\mathrm{FIRST}(\alpha)\)</span>，<code>M[A, b]</code><span
class="math inline">\(= A\to\alpha\)</span>，<span
class="math inline">\(b\in\mathrm{FOLLOW}(A)\)</span></li>
</ul>
<p>错误处理：</p>
<ul>
<li>栈顶终结符与输入不匹配：弹出</li>
<li><code>M[A, b] == null</code>：Sync</li>
</ul>
<p>预测分析表的使用：状态栈和剩余字符串</p>
<h3 id="自下而上的分析">自下而上的分析</h3>
<p>短语：有 <span class="math inline">\(S\stackrel{*}\Rightarrow \alpha
A\delta\)</span>，且 <span
class="math inline">\(A\stackrel{+}{\Rightarrow} \beta\)</span>，则
<span class="math inline">\(\beta\)</span> 是句型 <span
class="math inline">\(\alpha\beta\delta\)</span> 相对于规则 <span
class="math inline">\(A\to\beta\)</span> 的短语</p>
<p>直接短语：若 <span class="math inline">\(A{\Rightarrow}
\beta\)</span>，则 <span class="math inline">\(\beta\)</span> 是句型
<span class="math inline">\(\alpha\beta\delta\)</span> 相对于规则 <span
class="math inline">\(A\to\beta\)</span> 的直接短语</p>
<p>句柄：句型的最左直接短语</p>
<p>规范规约（最左规约）：最右推导的逆过程</p>
<p>LR(0) 文法：项目集不包含冲突项目</p>
<p>增广文法：在 <span class="math inline">\(G\)</span> 中增加 <span
class="math inline">\(S&#39;\to S\)</span></p>
<p>活前缀 NFA：初态 <span class="math inline">\(S&#39;\to\bullet
S\)</span>，从状态 <span class="math inline">\(X\to \cdots
X_{i-1}\bullet X_{i}\cdots\)</span> 到 <span class="math inline">\(X\to
\cdots X_i\bullet X_{i+1}\cdots\)</span> 有 <span
class="math inline">\(X_i\)</span> 弧；到状态 <span
class="math inline">\(X_i\to\bullet \beta\)</span> 有 <span
class="math inline">\(\varepsilon\)</span> 弧</p>
<p>直接构造活前缀 DFA：初态 <span
class="math inline">\(p_0=\mathrm{CLOSURE(\{[S&#39;\to\bullet
S]\})}\)</span>，<span class="math inline">\(q\)</span> 的 <span
class="math inline">\(X\)</span> 迁移到 <span
class="math inline">\(p\)</span> 当且仅当 <span
class="math inline">\(p=\mathrm{CLOSURE(\{[A\to\alpha X\bullet \eta]\ |\
[A\to\alpha\bullet X\eta]\in q\})}\)</span></p>
<p>构造 LR(1) 分析表：使用活前缀 DFA，<code>ACTION</code>
为终结符迁移动作（点不在最后 shift / 点在最后
reduce），<code>GOTO</code> 为针对变元迁移动作（当 reduce 时使用）</p>
<p>SLR(1) 分析表：使用 FOLLOW 来加强规约的能力，则 SLR(1)
文法为对于所有项目集，移进项目与规约项目 FOLLOW
不相交的；重新定义项目使其带有 1 个终结符</p>
<p>LR 分析表使用：状态栈、符号栈和剩余字符串</p>
<h3 id="语义分析">语义分析</h3>
<h4 id="属性文法">属性文法</h4>
<p>综合属性、继承属性；S-属性文法：仅有综合属性（自下而上）</p>
<p>属性方程，过程调用</p>
<h4 id="中间表示">中间表示</h4>
<p>后缀式，图表示，三地址（四元式、三元式）</p>
<h4 id="翻译">翻译</h4>
<p>声明的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VarD:	TYP L			&#123;</span><br><span class="line">							typfill($2.dtype, $1.dtype);</span><br><span class="line">						&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">L	:	id Dim, L		&#123;</span><br><span class="line">							typlink($2.dtype, $$.dtype);</span><br><span class="line">						&#125;</span><br><span class="line">	|	id Dim			&#123;</span><br><span class="line">							typlink($1.dtype, $$.dtype);</span><br><span class="line">						&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">Dim	:	[num] Dim		&#123;&#125;</span><br><span class="line">	|	%empty			&#123;&#125;</span><br><span class="line">	;</span><br><span class="line">	</span><br><span class="line">Proc:	M Pdef			&#123;&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">M	:	%empty			&#123;&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">Pdef:	Pdef; Pdef		&#123;&#125;</span><br><span class="line">	|	procid</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<p>嵌套过程声明：<code>mktab(father)</code>
建表，<code>addwidth(tab,name,typr,offset)</code>
填表，<code>fillwidth(tab, width)</code>
填表长，<code>enterproc(tab, name, chtab)</code> 建子表登记</p>
<p>函数调用的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S	:	procid &#x27;(&#x27; args &#x27;)&#x27;	&#123;</span><br><span class="line">								for (auto arg : $3.q) &#123;</span><br><span class="line">									emit(par, arg, _, _);</span><br><span class="line">								&#125;</span><br><span class="line">								emit(call, entry(procid), $3.q.size(), _);</span><br><span class="line">							&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">args:	args, E				&#123; $1.q.push(E.place); $$.q = $1.q; &#125;</span><br><span class="line">	|	E					&#123; $$.q = queue&lt;void*&gt;(); q.push(E.place); &#125;</span><br><span class="line">	；</span><br></pre></td></tr></table></figure>
<p>数组引用的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E	:	L	&#123;</span><br><span class="line">				// and much more</span><br><span class="line">			&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">L	:	EList &#x27;]&#x27;		&#123;</span><br><span class="line">							</span><br><span class="line">						&#125;</span><br><span class="line">	|	id				&#123;</span><br><span class="line">							</span><br><span class="line">						&#125;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">EList	:	EList&#x27;,&#x27; E	&#123;</span><br><span class="line">							</span><br><span class="line">						&#125;</span><br><span class="line">		|	id &#x27;[&#x27; E	&#123;</span><br><span class="line">							</span><br><span class="line">						&#125;</span><br><span class="line">		;</span><br></pre></td></tr></table></figure>
<p><code>&amp;A[i,j]=base+((i-l_1)*(u_2-l_2)+j-l_2)*w</code> <span
class="math display">\[
\begin{align}
base - C + (\cdots(((i_1)d_2+i_2)d_3+i_3)d_4\cdots)d_n + i_n
\nonumber\newline
l_k\le i_k\le u_k\nonumber\\
d_k = u_l-l_k\nonumber\\
C=((\cdots(((l_1)d_2+l_2)d_3+l_3)d_4\cdots)d_n+l_n)w\nonumber
\end{align}
\]</span> 布尔表达式的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E	:	E_1 or M E_2	&#123;</span><br><span class="line">							backpatch($$.falselist, M.quad);</span><br><span class="line">							$$.truelist = merge($1.truelist, $4.truelist);</span><br><span class="line">							$$.falselist = $4.falselist;</span><br><span class="line">						&#125;</span><br><span class="line">	|	E_1 and M E_2	&#123;</span><br><span class="line">							backpatch($$.truelist, M.quad);</span><br><span class="line">							$$.falselist = merge($1.falselist, $4.falselist);</span><br><span class="line">							$$.truelist = $4.truelist;</span><br><span class="line">						&#125;</span><br><span class="line">	|	not E_1			&#123;</span><br><span class="line">							$$.falselist = $2.truelist;</span><br><span class="line">							$$.truelist = $2.falselist;</span><br><span class="line">						&#125;</span><br><span class="line">	|	&#x27;(&#x27; E_1 &#x27;)&#x27;		&#123;</span><br><span class="line">							$$.falselist = $2.falselist;</span><br><span class="line">							$$.truelist = $2.truelist;</span><br><span class="line">						&#125;</span><br><span class="line">	|	id_1 rop id_2	&#123;</span><br><span class="line">							$$.truelist = makelist(nextquad);</span><br><span class="line">							emit($2.jop, $1.place, $3.place, NULL);</span><br><span class="line">							$$.falselist = makelist(nextquad);</span><br><span class="line">							emit(j, NULL, NULL, NULL);</span><br><span class="line">						&#125;</span><br><span class="line">	|	id				&#123;</span><br><span class="line">							$$.truelist = makelist(nextquad);</span><br><span class="line">							emit(jnz, $1.place, NULL, NULL);</span><br><span class="line">							$$.falselist = makelist(nextquad);</span><br><span class="line">							emit(j, NULL, NULL, NULL);</span><br><span class="line">						&#125;</span><br><span class="line">	;</span><br><span class="line">	</span><br><span class="line">M	:	%empty			&#123;</span><br><span class="line">							$$.quad = nextquad;</span><br><span class="line">						&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<p>控制语句的翻译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contr	: 	if E then		&#123;</span><br><span class="line">								bp($2.tc, nxq);</span><br><span class="line">								$$.chain = $2.fc;</span><br><span class="line">							&#125;</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">Stmts	:	Contr Stmts		&#123; $$.chain = merg($1.chain, $2.chain); &#125;</span><br><span class="line">		|	ConEl Stmts		&#123; $$.chain = merg($1.chain, $2.chain); &#125;</span><br><span class="line">		|	A				&#123; $$.chain = 0; &#125;</span><br><span class="line">		|	Wd Stmts		&#123;</span><br><span class="line">								bp($2.chain, $1.quad);</span><br><span class="line">								Gen(j, _, _, $1.quad);</span><br><span class="line">								$$.chain = $1.chain;</span><br><span class="line">							&#125;</span><br><span class="line">        |	begin L end		&#123; $$.chain = $2.chain; &#125;</span><br><span class="line">        ;</span><br><span class="line">	</span><br><span class="line">ConEl	:	Contr Stmts else&#123;</span><br><span class="line">                                q = nxq; Gen(j, , , 0);</span><br><span class="line">                                bp($1.chain ,nxq);</span><br><span class="line">                                $$.chain = merge($2.chain, q);</span><br><span class="line">                            &#125;</span><br><span class="line">        ;</span><br><span class="line">	</span><br><span class="line">W		:	while			&#123; $$.quad = nxq; &#125;</span><br><span class="line">Wd		:	W E do			&#123;</span><br><span class="line">                                bp($2.tc, nxq);</span><br><span class="line">                                $$.chain = $2.fc;</span><br><span class="line">                                $$.quad = $1.quad;</span><br><span class="line">                            &#125;</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">L		:	Stmts			&#123; $$.chain = $1.chain; &#125;</span><br><span class="line">		|	Ls Stmts		&#123; $$.chain = $2.chain; &#125;</span><br><span class="line"></span><br><span class="line">Ls		:	L &#x27;;&#x27;			&#123; bp($1.chain, nxq); &#125;</span><br><span class="line">		;</span><br></pre></td></tr></table></figure>
<h3 id="符号表">符号表</h3>
<p>名字、类型（整、实、双精、布尔、字符、复、标号、指针等）、种属、变量地址长度、标号标志位置、形式参数标志；</p>
<p>局部变量（包括形式参数）占用的存储空间、返回结果类型、局部过程名及符号表指针、嵌套外层过程</p>
<p>内情向量表</p>
<p>Dim，base，Type/w， C，<span
class="math inline">\(l_i\)</span>，<span
class="math inline">\(u_i\)</span>，<span
class="math inline">\(d_i=u_i-l_i\)</span></p>
<h3 id="运行时空间组织">运行时空间组织</h3>
<table>
<thead>
<tr class="header">
<th>offset</th>
<th>chain</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td></td>
<td>形参</td>
</tr>
<tr class="even">
<td>99</td>
<td></td>
<td>……形参</td>
</tr>
<tr class="odd">
<td>98</td>
<td></td>
<td>参数个数</td>
</tr>
<tr class="even">
<td>97</td>
<td></td>
<td>访问链</td>
</tr>
<tr class="odd">
<td>96</td>
<td>fp</td>
<td>控制链</td>
</tr>
<tr class="even">
<td>95</td>
<td></td>
<td>返回地址</td>
</tr>
<tr class="odd">
<td>94</td>
<td></td>
<td>局部变量</td>
</tr>
<tr class="even">
<td>93</td>
<td></td>
<td>……局部变量</td>
</tr>
<tr class="odd">
<td>92</td>
<td></td>
<td>超长数据</td>
</tr>
<tr class="even">
<td>91</td>
<td>sp</td>
<td>超长数据</td>
</tr>
</tbody>
</table>
<p>函数 <code>&lt;ip, ep&gt;</code> 作为参数，<code>ip</code>
代码入口，<code>ep</code> 实参求值的过程的活动记录</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">p</span><span class="params">(<span class="keyword">procedure</span> a)</span>;</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        	a;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">q</span>;</span></span><br><span class="line">        <span class="keyword">var</span> x:integer;</span><br><span class="line">        <span class="function"><span class="keyword">procedure</span> <span class="title">r</span>;</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            writeln(x);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x:=<span class="number">2</span>;</span><br><span class="line">        p(r);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	q;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p>认为过程 <code>r</code> 的调用者是过程 <code>q</code>，则在
<code>p</code> 使用 <code>r</code> 时走 <code>l_r-l_p+1</code>
层访问链</p>
<p>Display
表：过程的嵌套层次显示表，记录该过程的各外层过程的最新活动记录的起始地址</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大雾下公式合集</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%A7%E9%9B%BE%E4%B8%8B%E5%85%AC%E5%BC%8F%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p><em>rev0.3.1</em></p>
<h2 id="disclaimer">Disclaimer</h2>
<p>本文档照例应用于考前记诵</p>
<p>但现在内容多得已经可以用来饱和式学习了</p>
<p>本文强调值的运算矢量性时利用箭头符号 <span class="math inline">\(\vec
a\)</span>，描绘一般原则时则使用加粗体 <span
class="math inline">\(\mathbf a\)</span></p>
<p>所有常量均使用正体（如玻尔兹曼常量 <span
class="math inline">\(\mathrm k\)</span>）</p>
<p>电子电量 <span class="math inline">\(\mathrm e\)</span> 与自然底数
<span class="math inline">\(\mathrm e\)</span>
写法一致，但易于从上下文判断</p>
<p>rev 0.1，波动光学还没完善好！</p>
<p>rev 0.2，差不多该可以用了，但也快要考试了，加了一些没什么用的东西</p>
<p>rev 0.3，修正了一些已知错误</p>
<p>rev 0.3，修正了一些微不足道的错误，增加了“平均自由程”</p>
<h2 id="waiver">Waiver</h2>
<p>采用 <a
href="https://creativecommons.org/about/cclicenses/">cc-by-nc-sa
4.0</a></p>
<p>不完全对本文摘要内容的严谨性与正确性负责</p>
<h2 id="数学基础">数学基础</h2>
<h3 id="积化和差与和差化积">积化和差与和差化积</h3>
<p>请不要尝试记住 8 个公式，反之（在考场上）启发式地从以下二式推导 <span
class="math display">\[
\begin{align}
\cos(\alpha + \beta) &amp;+ \cos(\alpha - \beta)
\nonumber \newline
&amp;= \cos(\alpha)\cos(\beta)-\sin(\alpha)\sin(\beta) +
\cos(\alpha)\cos(\beta) + \sin(\alpha)\sin(\beta)
\nonumber \newline
&amp;= 2\cos(\alpha)\cos(\beta)
\nonumber \newline
\sin(\alpha+\beta) &amp;+ \sin(\alpha - \beta)
\nonumber \newline
&amp;= \sin(\alpha)\cos(\beta) + \sin(\beta)\cos(\alpha) +
\sin(\alpha)\cos(\beta) - \sin(\beta)\cos(\alpha)
\nonumber \newline
&amp;= 2\sin(\alpha)\cos(\beta)
\nonumber
\end{align}
\]</span></p>
<h3 id="旋转矢量法解二阶线性微分方程">旋转矢量法解二阶线性微分方程</h3>
<p>类似相量法，设复位移 <span class="math inline">\(x=A\mathrm
e^{\mathrm i(\omega t+\phi)}\)</span> 的实部表示位移，则微分关系</p>
<p><span class="math display">\[
\begin{align}
\frac{\mathrm d}{\mathrm dt} x &amp;= \mathrm i\omega A \mathrm
e^{\mathrm i(\omega t+\phi)}
= \omega A \mathrm e^{\mathrm i(\omega t+\phi+\frac{\pi}{2})}
\nonumber\newline
\frac{\mathrm d^2}{\mathrm dt^2} x &amp;= -\omega^2 A \mathrm e^{\mathrm
i(\omega t+\phi)}
= \omega^2 A \mathrm e^{\mathrm i(\omega t+\phi+\pi)}\nonumber
\end{align}
\]</span></p>
<p>将复位移转化为极坐标形式 <span class="math inline">\(\vec
x=A\angle\phi\)</span>，微分算符几何意义</p>
<p><span class="math display">\[
\begin{align}
\frac{\mathrm d}{\mathrm dt} = \omega\angle\frac{\pi}{2}
\nonumber\newline
\frac{\mathrm d^2}{\mathrm dt^2} = \omega^2\angle\pi \nonumber
\end{align}
\]</span></p>
<h4 id="谐振子">谐振子</h4>
<p>微分方程 <span class="math display">\[
-kx + F_0\cos(\omega t) = m\frac{\mathrm d^2}{\mathrm dt^2}x +
\mu\frac{\mathrm d}{\mathrm dt}x
\]</span> 其中驱动力项 <span class="math inline">\(F_0\cos(\omega
t)\)</span>，阻尼项 <span class="math inline">\(\mu\frac{\mathrm
d}{\mathrm dt}x\)</span>，恢复力项 <span
class="math inline">\(-kx\)</span></p>
<p>旋转矢量形式 <span class="math display">\[
-kA\angle\phi+F_0\angle0=m\omega^2 A\angle(\pi+\phi)+\mu\omega
A\angle(\frac{\pi}{2}+\phi)
\]</span> 画图求解即可</p>
<p>结论： <span class="math display">\[
\begin{align}
\omega_0 &amp;= \sqrt\frac{k}{m} \nonumber\newline
n&amp;=\frac{\mu}{2m} \nonumber\newline
f &amp;= \frac{F_0}{m} \nonumber\newline
A &amp;= \frac{f}{\sqrt{(\omega_0^2-\omega^2)^2+4n^2\omega^2}}
\nonumber\newline
\tan\phi &amp;= \frac{2n\omega}{\omega_0^2-\omega^2}\nonumber
\end{align}
\]</span></p>
<hr />
<h2 id="热力学">热力学</h2>
<h3 id="状态方程">状态方程</h3>
<p><span class="math display">\[
\begin{align}
pV=\nu \mathrm R T \nonumber\newline
p = n\mathrm k T \nonumber
\end{align}
\]</span></p>
<p>其中 <span class="math inline">\(\nu\)</span>
为物质的量（摩尔数），<span class="math inline">\(n\)</span>
为分子数密度，<span class="math inline">\(\mathrm k = \frac{\mathrm
R}{\mathrm {N_A}}\)</span></p>
<h3 id="微观状态量">微观状态量</h3>
<h4 id="分子平均平动动能">分子平均平动动能</h4>
<p><span class="math display">\[
\overline\varepsilon \triangleq \frac{1}{2}m_0\overline{v^2} =
\frac{3}{2}\mathrm k T
\]</span></p>
<p>其中 <span class="math inline">\(m_0\)</span>
为分子质量，由状态方程可得 <span class="math inline">\(p =
\frac{2}{3}n\overline\varepsilon\)</span></p>
<h4 id="麦克斯韦分布">麦克斯韦分布</h4>
<p><span class="math display">\[
f(v) = 4\pi\left(\frac{m_0}{2\pi\mathrm k
T}\right)^{\frac{3}{2}}v^2\mathrm e^{-\frac{m_0v^2}{2\mathrm kT}}
\]</span></p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>平均速率 <span class="math inline">\(\overline v\)</span></th>
<th>方均根速率 <span class="math inline">\(\sqrt{\bar
{v^2}}\)</span></th>
<th>最概然速率 <span class="math inline">\(v_p\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\sqrt{\frac{8}{\pi}}\sqrt{\frac{\mathrm
RT}{M}}\)</span></td>
<td><span class="math inline">\(\sqrt{3}\sqrt{\frac{\mathrm
RT}{M}}\)</span></td>
<td><span class="math inline">\(\sqrt{2}\sqrt{\frac{\mathrm
RT}{M}}\)</span></td>
</tr>
</tbody>
</table>
<p>其中 <span class="math inline">\(M=m_0 \mathrm {N_A}\)</span>
为分子量（注意单位 <span class="math inline">\(\mathrm{g\cdot
mol^{-1}}\)</span>）</p>
<h4 id="玻尔兹曼分布">玻尔兹曼分布</h4>
<p><span class="math display">\[
n=n_0 \mathrm e^{-\frac{\varepsilon_p}{\mathrm k T}}
\]</span></p>
<h4 id="平均自由程">平均自由程</h4>
<p>平均碰撞频率 <span class="math inline">\(\overline Z\)</span></p>
<p><span class="math display">\[
\overline Z = \sqrt{2}n\pi d^2\overline v
\]</span> 其中 <span class="math inline">\(d\)</span> 为分子直径</p>
<p>平均自由程 <span class="math inline">\(\overline \lambda\)</span></p>
<p><span class="math display">\[
\overline \lambda=\frac{1}{\sqrt{2}\pi d^2n}=\frac{\mathrm
kT}{\sqrt{2}\pi d^2p}
\]</span></p>
<h3 id="内能">内能</h3>
<p><span class="math display">\[
E = \nu \frac{i}{2}\mathrm R T
\]</span></p>
<p>其中 <span class="math inline">\(i\)</span> 为分子自由度</p>
<h3 id="热容">热容</h3>
<p>等体摩尔热容 <span class="math inline">\(C_{V,m}=\frac{i}{2}\mathrm
R\)</span></p>
<p>等压摩尔热容 <span class="math inline">\(C_{p,m}= C_{V,m} + R
=\frac{i+2}{2}\mathrm R\)</span></p>
<p>摩尔热容比 <span class="math inline">\(\gamma \triangleq
\frac{C_{p,m}}{C_{V,m}} = \frac{i+2}{i}\)</span></p>
<h3 id="热力学第一定律">热力学第一定律</h3>
<p><span class="math display">\[
Q = \Delta E + A
\]</span></p>
<p>其中 <span class="math inline">\(Q\)</span> 为系统向外界吸热，<span
class="math inline">\(\Delta E = E_2-E_1\)</span> 为系统内能增量，<span
class="math inline">\(A\)</span> 为系统对外做功</p>
<h3 id="热机">热机</h3>
<h4 id="热机效率">热机效率</h4>
<p><span class="math display">\[
\eta \triangleq \frac{A}{Q_1}
\]</span></p>
<p>其中 <span class="math inline">\(A\)</span> 为热机循环对外做功，<span
class="math inline">\(Q_1\)</span> 为系统向高温热源吸热</p>
<p>当热机为卡诺热机或可逆热机时， <span class="math inline">\(\eta =
\eta_{\text{max}}=1-\frac{T_2}{T_1}\)</span>，其中 <span
class="math inline">\(T_1\)</span>，<span
class="math inline">\(T_2\)</span> 分别为高温、低温热源温度</p>
<h4 id="致冷效率">致冷效率</h4>
<p><span class="math display">\[
\omega = \frac{Q_2}{A}
\]</span></p>
<p>其中 <span class="math inline">\(A\)</span> 为外界对致冷机做功，<span
class="math inline">\(Q_2\)</span> 为系统向低温冷库吸热，<span
class="math inline">\(\omega_\text{max} =
\frac{T_2}{T_1-T_2}\)</span></p>
<h4 id="热力学第二定律">热力学第二定律</h4>
<p><span class="math inline">\(\eta &lt; 1\)</span>，并有 <span
class="math inline">\(\omega \neq +\infty\)</span></p>
<h3 id="熵">熵</h3>
<p>在可逆过程中有</p>
<p><span class="math display">\[
\mathrm d S=\frac{\mathrm d Q}{T}
\]</span> 其中 <span class="math inline">\(Q\)</span>
为进入系统的热量</p>
<h4 id="热力学第三定律">热力学第三定律</h4>
<p><span class="math inline">\(T=0 \ \mathrm K\)</span> 时有 <span
class="math inline">\(S = 0\)</span></p>
<h3 id="过程公式">过程公式</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 24%" />
<col style="width: 34%" />
<col style="width: 11%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>过程</th>
<th>特征方程</th>
<th><span class="math inline">\(Q\)</span></th>
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(\Delta E\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>等体过程</td>
<td><span class="math inline">\(V=V_0\)</span></td>
<td><span class="math inline">\(\nu C_{V,m}\Delta T\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(=Q\)</span></td>
</tr>
<tr class="even">
<td>等压过程</td>
<td><span class="math inline">\(p=p_0\)</span></td>
<td><span class="math inline">\(\nu C_{p,m}\Delta T\)</span></td>
<td><span class="math inline">\(p\Delta V\)</span></td>
<td><span class="math inline">\(\nu C_{V,m}\Delta T\)</span></td>
</tr>
<tr class="odd">
<td>等温过程</td>
<td><span class="math inline">\(pV=p_0V_0\)</span></td>
<td><span class="math inline">\(\nu \mathrm R
T\ln\frac{V_2}{V_1}\)</span></td>
<td><span class="math inline">\(=Q\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>绝热过程</td>
<td><span class="math inline">\(pV^\gamma=p_0V_0^\gamma\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(=-\Delta E\)</span></td>
<td><span class="math inline">\(\nu C_{V,m}\Delta T\)</span></td>
</tr>
<tr class="odd">
<td>多方过程</td>
<td><span class="math inline">\(pV^n=p_0V_0^n\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="机械波">机械波</h2>
<h3 id="miscellaneous">miscellaneous</h3>
<p>频率 <span class="math inline">\(\nu\)</span>，周期 <span
class="math inline">\(T\)</span>，波速 <span
class="math inline">\(u\)</span>，波长 <span
class="math inline">\(\lambda\)</span>，频率 <span
class="math inline">\(f\)</span>，圆频率 <span
class="math inline">\(\omega\)</span>，振幅 <span
class="math inline">\(A\)</span></p>
<p><span class="math display">\[
\begin{align}
\nu = \frac{1}{T} \nonumber\newline
u = \frac{\lambda}{T} = \nu\lambda \nonumber\newline
\omega = 2\pi f = \frac{2\pi}{T} \nonumber
\end{align}
\]</span></p>
<h3 id="平面简谐波方程">平面简谐波方程</h3>
<p><span class="math display">\[
y(x,t)=A\cos\left(\omega\left(t-\frac{x}{u}\right)+\phi_0\right)
\]</span></p>
<p>其中 <span class="math inline">\(y\)</span> 表示 <span
class="math inline">\(x\)</span> 处质点偏离平衡位置的位移</p>
<h4 id="波动微分方程">波动微分方程</h4>
<p><span class="math display">\[
\frac{\partial^2 y}{\partial x^2}=\frac{1}{u^2}\frac{\partial^2
y}{\partial t^2}
\]</span></p>
<h3 id="波状态量">波状态量</h3>
<h4 id="波能量">波能量</h4>
<p>设质点 <span class="math inline">\((x,t)\)</span> 处小段质元 <span
class="math inline">\(\Delta x\)</span> 的动能为 <span
class="math inline">\(E_k\)</span>，势能为 <span
class="math inline">\(E_p\)</span> <span class="math display">\[
E_k=E_p=\frac{1}{2}\rho\Delta x
A^2\omega^2\sin^2\left[\omega\left(t-\frac{x}{u}\right)+\phi_0\right]=\frac{1}{2}\rho\Delta
x \omega^2 y_{\phi}^2
\]</span> 其中 <span class="math inline">\(y_\phi\)</span> 表示以 <span
class="math inline">\(\frac{\pi}{2}\)</span> 相位超前 <span
class="math inline">\(y\)</span> 的位移，<span
class="math inline">\(\rho\)</span> 为质量密度</p>
<h4 id="能量密度">能量密度</h4>
<p>单位体积中波的能量 <span class="math display">\[
w = \frac{E}{\Delta V}=\frac{E_k+E_p}{\Delta x\Delta S} = \rho\omega^2
y_{\phi}^2
\]</span> 其中 <span class="math inline">\(V\)</span> 为体积，<span
class="math inline">\(S\)</span> 为对于平面波所考虑的面积</p>
<h4 id="平均能量密度">平均能量密度</h4>
<p><span class="math display">\[
\overline w = \frac{1}{2}\rho A^2\omega^2
\]</span></p>
<h4 id="能流密度波强">能流密度/波强</h4>
<p><span class="math display">\[
\vec I\triangleq \overline w\vec u =\frac{1}{2}\rho A^2\omega^2\vec u
\]</span></p>
<h5 id="波功率非平面波振幅">波功率/非平面波振幅</h5>
<p><span class="math display">\[
P = \vec I\cdot\vec S
\]</span></p>
<p>在取 <span class="math inline">\(\vec S /\kern -0.3 em/ \vec
u\)</span>
时可不考虑矢量性，利用波功率守恒可推导出非平面波振幅（平方与面积反比）</p>
<h5 id="波的吸收">波的吸收</h5>
<p>即波功率的吸收</p>
<p><span class="math display">\[
\begin{align}
\mathrm d I &amp;= -\alpha I \mathrm d x \nonumber\\
I&amp;=I_0\mathrm e^{-\alpha x} \nonumber
\end{align}
\]</span></p>
<h4 id="波的合成">波的合成</h4>
<h5 id="相干波">相干波</h5>
<ul>
<li>频率相同</li>
<li>振动方向相同</li>
<li>相位差恒定</li>
</ul>
<p>设两波相位差为 <span
class="math inline">\(\Delta\phi=(\phi_2-\phi_1)-2\pi\frac{r_2-r_1}{\lambda}\)</span>，合成波满足
<span class="math display">\[
A^2=A_1^2+A_2^2+2A_1A_2\cos\Delta\phi
\]</span> <span class="math inline">\(A_\text{max} =A_1+A_2 \Rightarrow
I_\text{max} = I_1+I_2+2\sqrt{I_1I_2}\)</span></p>
<p><span class="math inline">\(A_\text{min} =\left|A_1-A_2\right|
\Rightarrow I_\text{min} = I_1+I_2-2\sqrt{I_1I_2}\)</span></p>
<h5 id="驻波">驻波</h5>
<p>固定端反射存在<strong>半波损失</strong>（反射点必为波节） <span
class="math display">\[
\begin{align}
y&amp;=y_1+y_2=A\left[\cos2\pi\left(\nu t-\frac{x}{\lambda}\right) +
\cos2\pi\left(\nu t+\frac{x}{\lambda}\right) \right]
\nonumber \newline
&amp;= 2A\cos\left(2\pi\frac{x}{\lambda}\right)\cdot\cos2\pi\nu t
\nonumber
\end{align}
\]</span></p>
<h5 id="拍频波">拍频波</h5>
<p>圆频率相近（<span class="math inline">\(|\omega_1-\omega_2|\ll
\omega_1\)</span>）的两列振动方向相同波合成（利用和差化积推导）</p>
<figure>
<img src="/images/UndergradPhysics/Beat.svg" alt="拍频波" />
<figcaption aria-hidden="true">拍频波</figcaption>
</figure>
<p>合成波振幅（包络）的圆频率 <span
class="math inline">\(\omega=\left|\frac{\omega_1-\omega_2}{2}\right|\)</span></p>
<p><strong>拍频</strong> <span class="math inline">\(f =
\left|f_1-f_2\right|\)</span>，为两个振幅峰值出现频率</p>
<h5 id="振动方向垂直的波合成"><em>振动方向垂直的波合成</em></h5>
<p>利用李萨如图形分析</p>
<h4 id="多普勒效应">多普勒效应</h4>
<p>设波速率 <span class="math inline">\(u\)</span>，波源相对介质速度为
<span class="math inline">\(\vec v_s\)</span>，观察者相对介质速度 <span
class="math inline">\(\vec v_0\)</span>，波源相对观察者位移单位向量
<span class="math inline">\(\vec r_0=\frac{\vec r}{|\vec
r|}\)</span></p>
<p>原频率 <span class="math inline">\(\nu_0\)</span> 与观察频率 <span
class="math inline">\(\nu\)</span> 的关系</p>
<p><span class="math display">\[
\nu = \frac{u + \vec v_0 \cdot \vec r_0}{u+\vec v_s\cdot \vec r_0}\nu_0
\]</span> 若观察者相对波源速度平行且相反</p>
<p><span class="math display">\[
\nu = \frac{u+v_0}{u-v_s}\nu_0
\]</span></p>
<h5 id="马赫锥">马赫锥</h5>
<p><span class="math display">\[
\sin\theta = \frac{u}{v_s}
\]</span></p>
<h2 id="波动光学">波动光学</h2>
<h3 id="光强">光强</h3>
<p><span class="math display">\[
\mathbf I=\left&lt;\mathbf S\right&gt;=\left&lt;\mathbf{E\times
H}\right&gt; \propto \frac{1}{2}E_0^2
\]</span></p>
<p>其中<strong>坡印廷矢量</strong> <span class="math inline">\(\mathbf
S=\mathbf{E\times H}\)</span>，<span class="math inline">\(\mathbf
E\)</span>，<span class="math inline">\(\mathbf H\)</span>
分别为电场强度矢量，磁场强度矢量，<span
class="math inline">\(E_0\)</span>，<span
class="math inline">\(H_0\)</span> 为其振幅</p>
<p>有 <span
class="math inline">\(\sqrt{\varepsilon_0}E_0=\sqrt{\mu_0}H_0\)</span>，光速
<span class="math inline">\(\mathrm
c=\sqrt{\frac{1}{\varepsilon_0\mu_0}}\)</span>，<span
class="math inline">\(\varepsilon_0\)</span> 为真空电介常数，<span
class="math inline">\(\mu_0\)</span> 为真空磁介常数</p>
<p>算符 <span class="math inline">\(\left&lt;\right&gt;\)</span>
为平均算符</p>
<h3 id="相干性">相干性</h3>
<h4 id="空间相干性">空间相干性</h4>
<p>光源线度对相干性的影响 <span class="math display">\[
b = \frac{B}{d}\lambda
\]</span> 其中 <span class="math inline">\(b\)</span> 为光源线度，<span
class="math inline">\(B\)</span> 为光源与双缝的距离（观测距离），<span
class="math inline">\(d\)</span> 为双缝间距（相干性度量）</p>
<h4 id="时间相干性">时间相干性</h4>
<p><span class="math display">\[
L=\frac{\lambda^2}{\Delta \lambda}
\]</span></p>
<p><span class="math inline">\(L\)</span> 表示相干长度，<span
class="math inline">\(\Delta \lambda\)</span> 为单色性的度量</p>
<h3 id="光的干涉">光的干涉</h3>
<h4 id="干涉条纹条件">干涉条纹条件</h4>
<p><span class="math display">\[
\delta(x) =
\begin{cases}
\pm 2k\cdot\frac{\lambda}{2}        &amp;, &amp; k \in
\mathbb{N}_+     &amp;, \text{ center of light stripes} \newline
\pm (2k+1)\cdot\frac{\lambda}{2}    &amp;, &amp; k \in
\mathbb{N}       &amp;, \text{ center of dark stripes}
\end{cases}
\]</span></p>
<p>其中 <span class="math inline">\(\delta(x)\)</span>
为使用分波阵面法或分振幅法时，在成像位置 <span
class="math inline">\(x\)</span> 形成的光程差</p>
<h4 id="举例">举例</h4>
<p>以下举例不同干涉实验中光程差的具体计算</p>
<h5 id="双缝干涉">双缝干涉</h5>
<p>当缝宽度 <span class="math inline">\(a \ll\)</span> 双缝间距 <span
class="math inline">\(d\)</span> 时</p>
<p><span class="math display">\[
\delta = \frac{xd}{D}
\]</span> 其中 <span class="math inline">\(D\)</span>
为光屏与双缝距离，<span class="math inline">\(D \gg d\)</span> 或 <span
class="math inline">\(D= f\)</span>（凸透镜汇聚）</p>
<h5
id="劈尖干涉牛顿环薄膜干涉迈克尔逊干涉仪">劈尖干涉/牛顿环/薄膜干涉/迈克尔逊干涉仪</h5>
<p>设单色光以入射角 <span class="math inline">\(\gamma\)</span>
入射折射率为 <span class="math inline">\(n_2\)</span>
的材料，入射处厚度为 <span class="math inline">\(d\)</span></p>
<p>假设入射方向观察干涉对象（反射光干涉），且环境折射率 <span
class="math inline">\(n_1 &lt;
n_2\)</span>，一次反射光有半波损失，则</p>
<p><span class="math display">\[
\delta = 2n_2d\cos\gamma + \frac{\lambda}{2}
\]</span> 若光源（可近似）为平行光，即关注 <span
class="math inline">\(d\)</span> 对 <span
class="math inline">\(\delta\)</span>
的影响时，形成<strong>等厚干涉</strong>条纹：同一条纹厚度相等，形成“等高线”</p>
<p>若光源（可近似）为无限大面光源，即关注 <span
class="math inline">\(\gamma\)</span> 对 <span
class="math inline">\(\delta\)</span>
的影响时，形成<strong>等倾干涉</strong>条纹：同一条纹倾角相等</p>
<h6 id="牛顿环入射处厚度近似">牛顿环入射处厚度近似</h6>
<p>设凸透镜曲率半径 <span
class="math inline">\(R\)</span>，条纹距接触点距离 <span
class="math inline">\(r\)</span>，该位置空气隙厚度 <span
class="math inline">\(d\)</span>，有 <span class="math display">\[
R^2=r^2+(R-d)^2=r^2+R^2-2Rd+d^2
\]</span> 由于 <span class="math inline">\(d \ll R\)</span>，<span
class="math inline">\(d^2 \ll Rd \ll R^2\)</span>，则 <span
class="math display">\[
d = \frac{r^2}{2R}
\]</span></p>
<h6 id="迈克尔逊干涉仪">迈克尔逊干涉仪</h6>
<p>可以同时体现等厚、等倾干涉的仪器，有</p>
<p><span class="math display">\[
\delta = 2d
\]</span> 其中 <span class="math inline">\(d\)</span> 为反射镜 <span
class="math inline">\(M_1\)</span> 与 <span
class="math inline">\(M_2&#39;\)</span>（<span
class="math inline">\(M_2\)</span> 关于分光板 <span
class="math inline">\(G_1\)</span> 的像）在反射位置的距离</p>
<h4 id="衍射的干涉化处理">衍射的干涉化处理</h4>
<h5 id="半波带法">半波带法</h5>
<p>可以利用“半波带法”将单缝夫琅禾费衍射以干涉形式计算</p>
<p>设单缝衍射缝宽 <span
class="math inline">\(a\)</span>，考虑衍射角（与法向夹角）为 <span
class="math inline">\(\phi\)</span> 的出射光线</p>
<p>将波面分为宽度为 <span class="math inline">\(\Delta S\)</span>
的窄条，使得窄条上下光线相位差为 <span
class="math inline">\(\pi\)</span></p>
<figure>
<img src="/images/UndergradPhysics/fresnel-h-zone.jpg" alt="半波带法" />
<figcaption aria-hidden="true">半波带法</figcaption>
</figure>
<p>半波带数量 <span class="math inline">\(N =
\frac{a\sin\phi}{\frac{\lambda}{2}}\)</span>，则当 <span
class="math inline">\(N\)</span>
为奇数时明纹，偶数时暗纹，此结论形式上与将</p>
<p><span class="math display">\[
\delta=a\sin\phi
\]</span> 代入干涉条件时一致</p>
<h5 id="半波带法的局限"><em>半波带法的局限</em></h5>
<p>由菲涅尔积分法，得到暗纹条件一致，真实明纹条件 <span
class="math inline">\(\phi\)</span> 略小于半波带法的结果</p>
<p>设 <span class="math inline">\(\alpha = \frac{\pi
a\sin\phi}{\lambda}\)</span>，有次极大条件 <span
class="math inline">\(\tan\alpha=\alpha\)</span></p>
<p>设中央明纹亮度 <span class="math inline">\(I_m\)</span>，有 <span
class="math inline">\(I =
I_m\left(\frac{\sin\alpha}{\alpha}\right)\)</span></p>
<h4 id="光栅">光栅</h4>
<h5 id="干涉成分">干涉成分</h5>
<p>假设光在每缝的衍射是均匀的，考虑干涉条纹</p>
<p>设光栅缝（透光部分）宽 <span
class="math inline">\(a\)</span>，不透光部分宽度 <span
class="math inline">\(b\)</span>，光栅常量 <span class="math inline">\(d
= a + b\)</span>，缝总数 <span
class="math inline">\(N\)</span>，平行光以于光栅法线夹角 <span
class="math inline">\(\theta\)</span> 斜入射，考虑衍射角为 <span
class="math inline">\(\phi\)</span> 的衍射光</p>
<p><strong>光栅明纹方程</strong> <span class="math display">\[
d(\sin\phi+\sin\theta)=\pm k\lambda\ ,\ k = 0, 1, 2,\cdots
\]</span> 其中 <span class="math inline">\(k\)</span> 称为“明纹级数”</p>
<p><strong><em>次极大光强分布</em></strong></p>
<p>利用振幅矢量法推导，存在次极大 <span class="math display">\[
Nd(\sin\phi+\sin\theta)=\pm m\lambda
\]</span></p>
<p>考虑衍射时，设 <span class="math inline">\(\delta\)</span>
为相邻两光线相位差 <span class="math display">\[
I =
I_m\left(\frac{\sin\alpha}{\alpha}\right)^2\left(\frac{\sin\frac{N\delta}{2}}{\sin\frac{\delta}{2}}\right)^2
\]</span></p>
<figure>
<img src="/images/UndergradPhysics/grating.jpg"
alt="光栅次极大分布合成示意图" />
<figcaption aria-hidden="true">光栅次极大分布合成示意图</figcaption>
</figure>
<h5 id="衍射成分">衍射成分</h5>
<p>造成了光栅条纹的“缺级”，当</p>
<p><span class="math display">\[
\frac{a}{a+b}k=k&#39;\ ,\ k&#39; = 1,2,\cdots
\]</span> 或 <span class="math display">\[
k = \frac{a+b}{a}k&#39;
\]</span> 时，第 <span class="math inline">\(k\)</span> 级明纹不存在</p>
<h3 id="光学系统最小分辨角">光学系统最小分辨角</h3>
<p><span class="math display">\[
\phi = 1.22\frac{\lambda}{D}
\]</span></p>
<p>其中 <span class="math inline">\(\phi\)</span> 为最小分辨角，<span
class="math inline">\(D\)</span> 为光学系统孔径</p>
<h3 id="偏振光">偏振光</h3>
<h4 id="马吕斯定律">马吕斯定律</h4>
<p><span class="math display">\[
I=I_0\cos^2\alpha
\]</span></p>
<p>其中 <span class="math inline">\(\alpha\)</span>
为两偏振片偏振化方向夹角</p>
<h4 id="布儒斯特定律">布儒斯特定律</h4>
<p>以入射角 <span class="math inline">\(i\)</span> 由介质折射率 <span
class="math inline">\(n_1\)</span> 入射晶体 <span
class="math inline">\(n_2\)</span>
的自然光，当反射光垂直于折射光时入射角为 <span
class="math inline">\(i_b\)</span>，此时反射光为线偏振光，且偏振化方向垂直于主平面</p>
<p><span class="math display">\[
\tan i_b=\frac{n_2}{n_1}
\]</span></p>
<h4 id="晶体双折射">晶体双折射</h4>
<ul>
<li>o 光：波阵面各向同性，折射率 <span
class="math inline">\(n_o\)</span>，偏振化方向垂直于自身主平面</li>
<li>e 光：波阵面各向异性，折射率 <span
class="math inline">\(n_e\)</span>，偏振化方向在自身主平面内</li>
</ul>
<p><span class="math inline">\(n_e &gt; n_o\)</span>
<strong>正晶体</strong>，反之<strong>负晶体</strong></p>
<h5 id="光轴">光轴</h5>
<p>o 光与 e 光波阵面同向的方向</p>
<p>垂直于光轴入射时，e 光偏振化方向平行光轴，o 光偏振化方向垂直光轴</p>
<h5 id="分离两类光">分离两类光</h5>
<ul>
<li>尼科尔棱镜：加拿大树胶可使 o 光全反射</li>
<li>沃拉斯顿棱镜：两个光轴方向垂直的双折射晶体</li>
</ul>
<h5 id="偏振干涉"><em>偏振干涉</em></h5>
<p>利用偏振片将两个出射光成分调整至同一偏振化方向形成干涉的现象，<span
class="math inline">\(d\)</span> 为波片厚度</p>
<p><span class="math display">\[
\delta=\frac{2\pi}{\lambda}\left|n_o-n_e\right|d + \Delta\phi
\]</span> 当利用偏振片调整后两偏振化方向相反时有 <span
class="math inline">\(\Delta\phi=\pi\)</span></p>
<h2 id="近代物理">近代物理</h2>
<h3 id="相对论">相对论</h3>
<h4 id="基本公式">基本公式</h4>
<p><span class="math inline">\(\beta = \frac{v}{\mathrm c}\)</span></p>
<p>能量 <span class="math inline">\(E = m\mathrm c^2\)</span></p>
<p>相对论质量 <span class="math inline">\(m =
\frac{m_0}{\sqrt{1-\beta^2}}\)</span></p>
<p>动能 <span class="math inline">\(E_k = m\mathrm c^2 - m_0\mathrm
c^2\)</span></p>
<p>动量 <span class="math inline">\(\vec p = m\vec
v=\frac{m_0}{\sqrt{1-\beta^2}} \vec v\)</span></p>
<h4 id="洛伦兹变换">洛伦兹变换</h4>
<p>设参考系 <span class="math inline">\(S&#39;\)</span> 相对 <span
class="math inline">\(S\)</span> 以速度 <span class="math inline">\(\vec
u = (u, 0, 0)\)</span> 运动，则原参考系 <span
class="math inline">\(S\)</span> 下坐标 <span class="math inline">\((x,
y, z)\)</span>，与变换参考系 <span class="math inline">\(S&#39;\)</span>
下坐标 <span class="math inline">\((x&#39;,y&#39;,z&#39;)\)</span>
满足：</p>
<p><span class="math display">\[
\begin{cases}
&amp; x&#39; &amp; = &amp; \frac{x-ut}{\sqrt{1-\beta^2}} \newline
&amp; y&#39; &amp; = &amp; y \newline
&amp; z&#39; &amp; = &amp; z \newline
&amp; t&#39; &amp; = &amp; \frac{t-\frac{u}{\mathrm
c^2}x}{\sqrt{1-\beta^2}}
\end{cases}
\ \ \ \ \ \ \ \
\begin{cases}
&amp; x &amp; = &amp; \frac{x&#39;+ut}{\sqrt{1-\beta^2}} \newline
&amp; y &amp; = &amp; y&#39; \newline
&amp; z &amp; = &amp; z&#39; \newline
&amp; t &amp; = &amp; \frac{t&#39;+\frac{u}{\mathrm
c^2}x&#39;}{\sqrt{1-\beta^2}}
\end{cases}
\]</span></p>
<h4 id="速度变换">速度变换</h4>
<p>设 <span class="math inline">\(\xi = 1-\frac{u}{\mathrm
c^2}v_x\)</span>，<span class="math inline">\(\eta = 1+\frac{u}{\mathrm
c^2}v_x&#39;\)</span></p>
<p><span class="math display">\[
\begin{cases}
&amp; v_x&#39; &amp; = &amp; \frac{v_x-u}{\xi} \newline
&amp; v_y&#39; &amp; = &amp; \frac{v_y\sqrt{1-\beta^2}}{\xi} \newline
&amp; v_z&#39; &amp; = &amp; \frac{v_z\sqrt{1-\beta^2}}{\xi} \newline
\end{cases}
\ \ \ \ \ \ \ \
\begin{cases}
&amp; v_x &amp; = &amp; \frac{v_x&#39;+u}{\eta} \newline
&amp; v_y &amp; = &amp; \frac{v_y&#39;\sqrt{1-\beta^2}}{\eta} \newline
&amp; v_z &amp; = &amp; \frac{v_z&#39;\sqrt{1-\beta^2}}{\eta} \newline
\end{cases}
\]</span></p>
<h3 id="量子物理">量子物理</h3>
<h4 id="黑体辐射">黑体辐射</h4>
<h5 id="斯特藩-玻尔兹曼定律">斯特藩-玻尔兹曼定律</h5>
<p><span class="math display">\[
M_B(T)=\int_0^{+\infty} M_B(T,\lambda) \mathrm d \lambda = \sigma T^4
\]</span></p>
<p>其中 <span class="math inline">\(M_B\)</span> 为黑体辐出度，<span
class="math inline">\(\sigma = 5.670373\times10^{-8}\
\mathrm{Wm^{-2}K^{-4}}\)</span> 为斯特藩-玻尔兹曼常量</p>
<h5 id="维恩位移定律">维恩位移定律</h5>
<p><span class="math display">\[
T\lambda_m = \mathrm b
\]</span></p>
<p>其中 <span class="math inline">\(\lambda_m\)</span>
表示峰值波长，<span class="math inline">\(\mathrm b = 2898 \ \mathrm{\mu
m\cdot K}\)</span> 为一常数</p>
<h5 id="普朗克公式">普朗克公式</h5>
<p><span class="math display">\[
M_B(T,\lambda)=\frac{2\pi\mathrm {hc^2}\lambda^{-5}}{\mathrm
e^{\frac{\mathrm {hc}}{\lambda\mathrm k T}} - 1}
\]</span></p>
<h4 id="光电效应">光电效应</h4>
<h5 id="爱因斯坦光电效应方程">爱因斯坦光电效应方程</h5>
<p><span class="math display">\[
\mathrm h\nu = A+\frac{1}{2}mv_m^2
\]</span></p>
<p>其中 <span class="math inline">\(A\)</span> 为逸出功，<span
class="math inline">\(\frac{1}{2}mv_m^2\)</span> 为电子的最大初动能</p>
<p>可得截止频率 <span class="math inline">\(\nu_0=\frac{A}{\mathrm
h}\)</span>，遏止电压 <span
class="math inline">\(U_a=\mathrm{\frac{h}{e}}\nu -
\mathrm{\frac{A}{e}}\)</span>，其中 <span class="math inline">\(\mathrm
e\)</span> 为电子电量</p>
<h4 id="康普顿散射">康普顿散射</h4>
<p><span class="math display">\[
\Delta \lambda = \lambda
-\lambda_0=\mathrm{\frac{h}{m_0c}}(1-\cos\theta)
\]</span></p>
<p>其中 <span class="math inline">\(\mathrm {m_0}\)</span>
为电子静质量，<span class="math inline">\(\lambda\)</span>
为散射波波长，<span class="math inline">\(\lambda_0\)</span>
为入射光波长</p>
<h4 id="初步原子模型">初步原子模型</h4>
<h5 id="里德伯-里兹并合原则">里德伯-里兹并合原则</h5>
<p><span class="math display">\[
\sigma=\frac{1}{\lambda}=\mathrm{R_H}\left(\frac{1}{k^2}-\frac{1}{n^2}\right)\
,\ n&gt;k\in\mathbb{Z}_+
\]</span></p>
<p>其中 <span class="math inline">\(\sigma\)</span> 称为波数，里德伯常量
<span class="math inline">\(\mathrm{R_H}=1.0973731\times10^{-7}\
\mathrm{m^{-1}}\)</span></p>
<h5 id="玻尔氢原子模型">玻尔氢原子模型</h5>
<ul>
<li>定态假设 <span class="math inline">\(E = E_n=
-\frac{1}{n^2}\left(\frac{m\mathrm e^4}{8\varepsilon_0^2\mathrm
h^2}\right)\ ,\ n\in \mathbb{Z}_+\)</span></li>
<li>辐射频率公式 <span
class="math inline">\(\nu_{kn}=\frac{|E_k-E_n|}{\mathrm h}\)</span></li>
<li>角动量量子化条件 <span class="math inline">\(L = mvr =
n\frac{\mathrm h}{2\pi}= n\hbar\ ,\ n\in\mathbb{Z}_+\)</span></li>
<li>定态轨道半径 <span
class="math inline">\(r_n=n^2\left(\frac{\varepsilon_0\mathrm h^2}{\pi
m\mathrm e^2}\right) = n^2r_1\ ,\ n\in\mathbb{Z}_+\)</span></li>
</ul>
<h5 id="索末菲椭圆轨道理论">索末菲椭圆轨道理论</h5>
<ul>
<li>长半轴 <span class="math inline">\(a=n^2r_1\)</span></li>
<li>短半轴 <span class="math inline">\(b= nn_\phi r_1 =
\frac{n_\phi}{n}a\ ,\ n_\phi &lt; n\in\mathbb{Z}_+\)</span></li>
</ul>
<h4 id="量子力学原子模型">量子力学原子模型</h4>
<ul>
<li>电子能量量子化 <span
class="math inline">\(E_n=-\frac{1}{n^2}\left(\frac{m\mathrm
e^4}{8\varepsilon_0^2\mathrm h^2}\right)\ ,\ n\in
\mathbb{Z}_+\)</span></li>
<li>电子角动量量子化 <span
class="math inline">\(L=\sqrt{l(l+1)}\hbar\)</span>，磁矩 <span
class="math inline">\(\mu = -\mathrm{\frac{e}{2me}}L\)</span></li>
<li>角动量空间取向量子化 <span
class="math inline">\(L_z=m_l\hbar\)</span></li>
<li>自旋角动量量子化 <span class="math inline">\(S=\sqrt{s(s+1)}\hbar =
\sqrt{\frac{1}{2}(\frac{1}{2}+1)}\hbar\)</span>，角动量（取向）在 <span
class="math inline">\(z\)</span> 方向分量 <span
class="math inline">\(S_z=m_z\hbar\)</span></li>
</ul>
<h5 id="量子数">量子数</h5>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 6%" />
<col style="width: 32%" />
<col style="width: 27%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>量子数</th>
<th>符号</th>
<th>取值范围</th>
<th>意义</th>
<th>本层最高容纳电子数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>主量子数</td>
<td><span class="math inline">\(n\)</span></td>
<td><span class="math inline">\(1, 2, 3, \cdots\)</span></td>
<td>大体上的能量（壳层）</td>
<td><span class="math inline">\(2n^2\)</span></td>
</tr>
<tr class="even">
<td>副量子数</td>
<td><span class="math inline">\(l\)</span></td>
<td><span class="math inline">\(0, 1, 2,\cdots,n-1\)</span></td>
<td>角动量与能量（支壳层）</td>
<td><span class="math inline">\(2(2l+1)\)</span></td>
</tr>
<tr class="odd">
<td>磁量子数</td>
<td><span class="math inline">\(m_l\)</span></td>
<td><span class="math inline">\(0,\pm1,\pm2,\cdots,\pm l\)</span></td>
<td>角动量的取向</td>
<td><span class="math inline">\(2l+1\)</span></td>
</tr>
<tr class="even">
<td>自旋量子数</td>
<td><span class="math inline">\(m_s\)</span></td>
<td><span class="math inline">\(\pm\frac{1}{2}\)</span></td>
<td>电子角动量的取向</td>
<td><span class="math inline">\(2\)</span></td>
</tr>
</tbody>
</table>
<h4 id="德布罗意物质波">德布罗意物质波</h4>
<p>动量 <span class="math inline">\(p=mv=\frac{\mathrm
h}{\lambda}\)</span></p>
<p>能量 <span class="math inline">\(E=m\mathrm c^2 = \mathrm
h\nu\)</span></p>
<h4 id="不确定性关系">不确定性关系</h4>
<p><span class="math display">\[
\begin{align}
\Delta x\Delta p_x \geq \frac{\hbar}{2} \nonumber\newline
\Delta E\Delta t \geq \frac{\hbar}{2} \nonumber
\end{align}
\]</span></p>
<p>后者表示能级宽度与能级稳定性的关系</p>
<h4 id="薛定谔方程">薛定谔方程</h4>
<p><span class="math display">\[
\left[V-\frac{\hbar}{2m}\Delta\right]\Psi=\mathrm
i\hbar\frac{\partial\Psi}{\partial t}
\]</span></p>
<p>其中波函数 <span class="math inline">\(\Psi(\vec r,t)\)</span>
满足单值、有限、连续且有平方归一化条件</p>
<p>拉普拉斯算子 <span
class="math inline">\(\Delta=\nabla\cdot\nabla=\frac{\partial^2}{\partial
x^2}+\frac{\partial^2}{\partial y^2}+\frac{\partial^2}{\partial
z^2}\)</span></p>
<p><span class="math inline">\(V(\vec r,t)\)</span> 为空间势函数</p>
<h5 id="定态薛定谔方程">定态薛定谔方程</h5>
<p>在粒子总能量 <span class="math inline">\(E=V+\frac{p^2}{2m}\)</span>
不随 <span class="math inline">\(t\)</span> 变化的条件下，有分离变量形式
<span class="math inline">\(\Psi(\vec r,t)=\Psi(\vec r)\mathrm
e^{-\frac{2\pi\mathrm i}{\mathrm h} Et}\)</span>，则</p>
<p><span class="math display">\[
\Delta\Psi+\frac{2m}{\hbar^2}(E-V)\Psi=0
\]</span></p>
<h5 id="一维无限深势阱">一维无限深势阱</h5>
<p><span class="math display">\[
\begin{cases}
&amp; V(x) &amp; = &amp; 0      &amp;, &amp; x\in(0, a) \newline
&amp; V(x) &amp; = &amp;\infty  &amp;, &amp;
x\in(-\infty,0]\cup[a,+\infty)
\end{cases}
\]</span></p>
<p>一维定态薛定谔方程的解：</p>
<p><span class="math display">\[
\Psi_n(x)=\pm\sqrt{\frac{2}{a}}\sin\frac{n\pi}{a}x\ ,\ n=1,2,3,\cdots
\]</span> 能量 <span class="math inline">\(E_n=n^2\frac{\mathrm
h^2}{8ma^2}\)</span></p>
<p>驻波条件 <span
class="math inline">\(a=n\frac{\lambda_n}{2}\)</span></p>
<h3 id="激光与固体物理">激光与固体物理</h3>
<h4 id="格波">格波</h4>
<p>声子能量 <span class="math inline">\(E=\hbar\omega\)</span>，其中
<span class="math inline">\(\omega\)</span> 为格波角频率</p>
<h4 id="固体能带">固体能带</h4>
<p>原子能级分裂数 <span class="math inline">\(N\)</span>
为晶体原子数，形成满带、禁带、空带（导带）、价带（导带）</p>
<h5 id="导体">导体</h5>
<p>存在价带/空带满带重叠/价带空带重叠</p>
<h5 id="绝缘体">绝缘体</h5>
<p>满带与最近空带间禁带宽度 <span class="math inline">\(\Delta
E_g=3\sim6\ \mathrm{eV}\)</span></p>
<h5 id="半导体">半导体</h5>
<p>满带与最近空带间禁带宽度 <span class="math inline">\(\Delta
E_g=0.1\sim1.5\ \mathrm{eV}\)</span></p>
<ul>
<li>n 型半导体：掺入五价元素（砷 As、磷 P、锑 Sb）</li>
<li>p 型半导体：参入三价元素（硼 B、镓 Ga、铟 In、铝 Al）</li>
</ul>
<h4 id="激光原理">激光原理</h4>
<h5 id="玻尔兹曼分布-1">玻尔兹曼分布</h5>
<p>设系统热平衡状态温度 <span class="math inline">\(T\)</span>
下处于能级 <span class="math inline">\(i\)</span> 的原子数为 <span
class="math inline">\(N_i\)</span> <span class="math display">\[
N_i \propto g_i e^{-\frac{E_i}{\mathrm kT}}
\]</span> 其中 <span class="math inline">\(g_i\)</span>
为该能级的简并数</p>
<p>粒子数反转：高能级原子数大于低能级原子数的现象</p>
<h5 id="自发辐射系数">自发辐射系数</h5>
<p><span class="math display">\[
\left(\frac{\mathrm dN_{21}}{\mathrm dt}\right)_{\text{ spontaneous}} =
A_{21}N_2
\]</span></p>
<p>其中 <span class="math inline">\(N_{21}\)</span> 为能级 <span
class="math inline">\(2\)</span> 转移至能级 <span
class="math inline">\(1\)</span> 的粒子数，<span
class="math inline">\(A_{21}\)</span> 为自发辐射系数</p>
<h5 id="受激辐射系数">受激辐射系数</h5>
<p><span class="math display">\[
\left(\frac{\mathrm dN_{21}}{\mathrm dt}\right)_{\text{ motivated}} =
kN_2IB
\]</span></p>
<p>其中 <span class="math inline">\(k\)</span> 为比例系数，<span
class="math inline">\(I\)</span> 为激发光强，<span
class="math inline">\(B\)</span> 为受激辐射系数</p>
<h5 id="受激吸收系数">受激吸收系数</h5>
<p><span class="math display">\[
\left(\frac{\mathrm dN_{12}}{\mathrm dt}\right)_{\text{ motivated}} =
kN_1IB&#39;
\]</span></p>
<p>其中 <span class="math inline">\(k\)</span> 为比例系数，<span
class="math inline">\(I\)</span> 为激发光强，<span
class="math inline">\(B&#39;\)</span> 为受激吸收系数，简并度相同时 <span
class="math inline">\(B&#39;=B\)</span></p>
<h5 id="光增益">光增益</h5>
<p>光在经过增益介质时光强 <span class="math inline">\(I\)</span>
随经过距离 <span class="math inline">\(z\)</span> 的变化</p>
<p><span class="math display">\[
\mathrm dI(z)=GI(z)\mathrm dz
\]</span> 或 <span class="math display">\[
I(z)=I_0\mathrm e^{Gz}
\]</span> 其中 <span class="math inline">\(G\)</span> 为光增益系数</p>
<h4 id="激光器">激光器</h4>
<p>设增益介质长度 <span
class="math inline">\(L\)</span>，两反射镜反射率分别为 <span
class="math inline">\(r_1\)</span>，<span
class="math inline">\(r_2\)</span></p>
<h5 id="阈值条件">阈值条件</h5>
<p><span class="math display">\[
r_1r_2\mathrm e^{2GL}\geq 1
\]</span></p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析笔记</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文向量、矩阵符号均不以粗体标识，从上下文推断</p>
<h2 id="线性代数">线性代数</h2>
<h3 id="特征值">特征值</h3>
<p>求矩阵 <span class="math inline">\(A\)</span> 的特征值 <span
class="math inline">\(\lambda_i\)</span> 以及特征向量 <span
class="math inline">\(x\)</span>：求解方程 <span
class="math inline">\(|A-\lambda I|=0\)</span></p>
<h3 id="二次型">二次型</h3>
<p>设 <span class="math inline">\(A\)</span> 是对称正定阵，<span
class="math inline">\(\forall x\neq 0 \in R^n\)</span> 二次型 <span
class="math inline">\(x^{\mathrm T}Ax &gt; 0\)</span></p>
<p>存在可逆矩阵 <span class="math inline">\(L\)</span> 使 <span
class="math inline">\(A = LL^T\)</span></p>
<p><span class="math inline">\(A\)</span> 特征值、顺序主子式均大于零</p>
<h2 id="范数">范数</h2>
<h3 id="向量范数">向量范数</h3>
<p>向量范数 <span class="math inline">\(f(x)=\|x\|\)</span> 定义：</p>
<ol type="1">
<li>非负 <span class="math inline">\(\|x\|\geq 0, \|x\|=0\iff
x=0\)</span></li>
<li>线性 <span class="math inline">\(\forall \alpha \in R, \|\alpha
x\|=|\alpha|\|x\|\)</span></li>
<li>三角不等式 <span
class="math inline">\(\|x+y\|\leq\|x\|+\|y\|\)</span></li>
</ol>
<p>常用向量范数</p>
<ul>
<li>1 范数 <span class="math inline">\(\|x\|_1=\sum_{i=1}^{n}
|x_i|\)</span></li>
<li>2 范数 <span class="math inline">\(\|x\|_2=\left(\sum_{i=1}^{n}
x_i^2\right)^{\frac{1}{2}}\)</span></li>
<li><span class="math inline">\(\infty\)</span> 范数 <span
class="math inline">\(\|x\|_{\infty}=\max_{1\leq i\leq
n}|x_i|\)</span></li>
</ul>
<p>向量范数等价性：<span class="math inline">\(\exists c_1&gt;0,
c_2&gt;0, \mathrm{s.t.} \forall x\in R^n, c_1\|x\|_q\leq\|x\|_p\leq
c_2\|x\|_q\)</span></p>
<h3 id="矩阵范数">矩阵范数</h3>
<p>定义：</p>
<ol type="1">
<li>非负</li>
<li>线性</li>
<li>三角不等式</li>
<li><span class="math inline">\(\|AB\|\leq\|A\|\|B\|\)</span></li>
</ol>
<p>相容性：<span class="math inline">\(\|Ax\|\leq
\|A\|\|x\|\)</span></p>
<p>算子范数（与对应向量范数相容）</p>
<p><span class="math display">\[
\|A\|_p=\max_{x\neq
0}\frac{\|Ax\|_p}{\|x\|_p}=\max_{\|x\|_p=1}{\|Ax\|_p}
\]</span> 常用矩阵范数</p>
<ul>
<li>列范数 <span class="math inline">\(\|A\|_1=\max_{1\le j \le
n}\left\{\sum_{i=1}^n|a_{ij}|\right\}\)</span></li>
<li>谱范数 <span
class="math inline">\(\|A\|_2=\sqrt{\lambda_{max}(A^{\mathrm
T}A)}\)</span>，矩阵 <span class="math inline">\(A^{\mathrm T}A\)</span>
最大的特征值开根号</li>
<li>行范数 <span class="math inline">\(\|A\|_\infty=\max_{1\le i \le
n}\left\{\sum_{j=1}^n|a_{ij}|\right\}\)</span></li>
<li>F 范数（与 2 范数相容）<span
class="math inline">\(\|A\|_F=\sqrt{\sum_{a_{ij}\in
A}a_{ij}^2}\)</span></li>
</ul>
<h3 id="谱半径">谱半径</h3>
<p>对于矩阵 <span class="math inline">\(A\)</span>，<span
class="math inline">\(\lambda_i\)</span> 是它的特征值，谱半径 <span
class="math inline">\(\rho(A)=\max_{1\le i\le
n}\{|\lambda_i|\}\)</span></p>
<p>谱半径不超过任意一种范数</p>
<h3 id="条件数">条件数</h3>
<p><span class="math display">\[
\mathrm{Cond}(A)\triangleq \|A\|\|A^{-1}\|
\]</span></p>
<p>条件数大的矩阵称为“病态”矩阵，反之“良态”</p>
<h2 id="线性方程组">线性方程组</h2>
<h3 id="高斯消元">高斯消元</h3>
<p>高斯消元的第 <span class="math inline">\(k-1\)</span> 步：</p>
<p><span class="math display">\[
A^{(k-1)}x=b^{(k-1)}
\]</span></p>
<p>其中 <span class="math display">\[
A^{(k-1)}=
\begin{pmatrix}
a_{11}^{(0)} &amp; a_{12}^{(0)} &amp; \cdots &amp; a_{1k}^{(0)} &amp;
\cdots &amp; a_{1n}^{(0)} \newline
&amp; a_{22}^{(1)} &amp; \cdots &amp; a_{2k}^{(1)} &amp; \cdots &amp;
a_{2n}^{(1)} \newline
&amp; &amp; \ddots &amp; \vdots &amp; &amp; \vdots \newline
&amp; &amp; &amp; a_{kk}^{(k-1)} &amp; \cdots &amp; a_{kn}^{(k-1)}
\newline
&amp; &amp; &amp; \vdots &amp; &amp; \vdots \newline
&amp; &amp; &amp; a_{nk}^{(k-1)} &amp; \cdots &amp; a_{nn}^{(k-1)}
\newline
\end{pmatrix}
,
b^{(k-1)}=
\begin{pmatrix}
b_1^{(0)} \newline
b_2^{(1)} \newline
\vdots \newline
b_k^{(k-1)} \newline
b_n^{(k-1)} \newline
\end{pmatrix}
\]</span></p>
<p>有</p>
<p><span class="math display">\[
a_{ij}^{(k)} =
a_{ij}^{(k-1)}-\frac{a_{ik}^{(k-1)}}{a_{kk}^{(k-1)}}a_{kj}^{(k-1)} =
a_{ij}^{(k-1)}-l_{ik}a_{kj}^{(k-1)}
\]</span></p>
<p>回代过程公式很显然</p>
<p>消元过程乘除法运算量 <span
class="math inline">\(\frac{n^3}{3}+\frac{n^2}{2}-\frac{5n}{6}\)</span></p>
<p>回代过程乘除法运算量 <span
class="math inline">\(\frac{n^2}{2}+\frac{n}{2}\)</span></p>
<p>高斯消元顺利进行的条件：<span
class="math inline">\(a_{kk}^{(k-1)}\neq 0 \iff D_k \neq
0\)</span>，其中 <span class="math inline">\(D_k\)</span> 为 <span
class="math inline">\(k\)</span> 阶顺序主子式</p>
<p>另外的充分条件：<span class="math inline">\(A\)</span>
是对称正定阵；<span class="math inline">\(A\)</span>
是严格对角占优阵</p>
<p>列主元高斯消元法：将最大方程与当前方程交换</p>
<h3 id="lu-分解">LU 分解</h3>
<p>高斯消元每一步其实是乘单位下三角矩阵 <span
class="math inline">\(L_k\)</span></p>
<p>LU 分解的唯一性：<span class="math inline">\(L=\prod_k
L_k\)</span></p>
<p>杜利特尔分解：单位下三角矩阵 <span class="math inline">\(L\)</span>
与上三角矩阵 <span
class="math inline">\(U\)</span>；反之为克劳特分解</p>
<p><span class="math display">\[
\begin{cases}
u_{1j}=a_{1j} &amp;, j = 1, 2, \cdots,n, \newline
l_{i1}=\dfrac{a_{i1}}{u_{11}} &amp;, i = 2,3,\cdots,n, \newline
u_{ij}=a_{ij}-\sum\limits_{k=1}^{i-1}l_{ik}u_{kj} &amp;, i =
2,3,\cdots,n; j=i,i+1,\cdots, n,\\
l_{ij}=\dfrac{a_{ij}-\sum\limits_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}
&amp;,j=2,3,\cdots,n-1;i=j+1,j+2,\cdots,n.
\end{cases}
\]</span></p>
<p>LU 分解解方程组 <span class="math inline">\(Ax=b \iff LUx=b \iff
Ly=b,Ux=y\)</span>，均类似回代；乘除法运算次数与高斯消元法相同</p>
<p>LU 分解时分解增广矩阵即可直接解出 <span
class="math inline">\(y\)</span></p>
<h3 id="平方根法">平方根法</h3>
<p>对称正定阵 <span class="math inline">\(A=LDL^{\mathrm
T}\)</span>，其中 <span class="math inline">\(D\)</span> 为 LU 分解中
<span class="math inline">\(U\)</span> 取对角元的矩阵</p>
<p>楚列斯基分解：<span class="math inline">\(A=LDL^{\mathrm
T}=LD^{\frac{1}{2}}D^{\frac{1}{2}}L^{\mathrm
T}=(LD^{\frac{1}{2}})(LD^{\frac{1}{2}})^{\mathrm T}\triangleq
GG^{\mathrm T}\)</span></p>
<p><span class="math display">\[
G\triangleq
\begin{pmatrix}
g_{11} \newline
g_{21} &amp; g_{22} \newline
g_{31} &amp; g_{32} &amp; g_{33} \newline
\vdots &amp; \vdots &amp; &amp; \ddots \newline
g_{n1} &amp; g_{n2} &amp; \cdots &amp; g_{n,n-1} &amp; g_{nn} \newline
\end{pmatrix}
\]</span></p>
<p>分解公式</p>
<p><span class="math display">\[
\begin{cases}
g_{11}=\sqrt{a_{11}} &amp;, \newline
g_{i1}=\dfrac{a_{i1}}{g_{11}} &amp;, i = 2,3,\cdots,n, \newline
g_{jj}=\left(a_{jj}-\sum\limits_{k=1}^{j-1} g_{jk}^2\right)^\frac{1}{2}
&amp;, i = 2,3,\cdots,n,\\
g_{ij}=\dfrac{a_{ij}-\sum\limits_{k=1}^{j-1}g_{ik}g_{jk}}{g_{jj}}
&amp;,j=2,3,\cdots,n-1;i=j+1,j+2,\cdots,n \newline
\end{cases}
\]</span></p>
<p>发现 <span class="math inline">\(y_i\)</span> 与 <span
class="math inline">\(g_{ij}\)</span> 的计算方式一致，可以在 LU
分解时分解增广阵直接算出 <span class="math inline">\(y\)</span></p>
<p>该分解是稳定的，平方根法回代同 LU 分解，总乘除法次数 <span
class="math inline">\(\frac{n^3}{6}+n^2-\frac{n}{6}\)</span></p>
<h3 id="改进平方根法">改进平方根法</h3>
<p>对称正定阵 <span class="math inline">\(A=LDD^{-1}U=LDL^{\mathrm
T}\)</span>，</p>
<p><span class="math display">\[
\begin{cases}
u_{1j}=a_{1j} &amp;, j = 1, 2, \cdots,n, \newline
l_{i1}=\dfrac{a_{i1}}{u_{11}} &amp;, i = 2,3,\cdots,n, \newline
u_{ij}=a_{ij}-\sum\limits_{k=1}^{i-1}l_{ik}u_{kj} &amp;, i =
2,3,\cdots,n; j=i,i+1,\cdots, n,\\
l_{ij}= \dfrac{u_{ji}}{u_{ii}}
&amp;,j=2,3,\cdots,n-1;i=j+1,j+2,\cdots,n.
\end{cases}
\]</span></p>
<p>总乘除法次数 <span
class="math inline">\(\frac{n^3}{6}+\frac{3n^2}{2}-\frac{2n}{3}\)</span></p>
<h3 id="追赶法">追赶法</h3>
<p>三对角方程组 <span class="math inline">\(Ax=d\)</span> 的 LU 分解</p>
<p><span class="math display">\[
A=
\begin{pmatrix}
    b_1 &amp; c_1 &amp; &amp; &amp; \newline
    a_2 &amp; b_2 &amp; c_2 &amp; &amp; \newline
    &amp; \ddots &amp; \ddots &amp; \ddots &amp; \newline
    &amp; &amp; a_{n-1} &amp; b_{n-1} &amp; c_{n-1} \newline
    &amp; &amp; &amp; a_{n} &amp; b_n \newline
  \end{pmatrix}
  =
  \begin{pmatrix}
    1 &amp;  &amp; &amp; &amp; \newline
    l_2 &amp; 1 &amp;  &amp; &amp; \newline
    &amp; \ddots &amp; \ddots &amp;  &amp; \newline
    &amp; &amp; l_{n-2} &amp; 1 &amp;  \newline
    &amp; &amp; &amp; l_{n-1} &amp; 1 \newline
  \end{pmatrix}
  \begin{pmatrix}
    u_1 &amp; c_1 &amp; &amp; &amp; \newline
     &amp; u_2 &amp; c_2 &amp; &amp; \newline
    &amp;  &amp; \ddots &amp; \ddots &amp; \newline
    &amp; &amp;  &amp; u_{n-2} &amp; c_{n-1} \newline
    &amp; &amp; &amp;  &amp; u_{n-1} \newline
  \end{pmatrix}
\]</span></p>
<p>公式</p>
<p><span class="math display">\[
\begin{cases}
u_1 = b_1 &amp;, \newline
l_i = \dfrac{a_i}{u_{i-1}} &amp;, i = 2, 3, \cdots, n, \newline
u_i=b_i-l_ic_{i-1} &amp;, i = 2, 3, \cdots, n. \newline
\end{cases}
\]</span></p>
<p><span class="math inline">\(Ly=b,Ux=y\)</span>，回代得</p>
<p><span class="math display">\[
\begin{cases}
y_1=d_1\\
y_i=d_i-l_iy_{i-1}
\end{cases}
,
\begin{cases}
x_n=\dfrac{y_n}{u_n}\\
x_i=\dfrac{y_i-c_ix_{i+1}}{u_i}
\end{cases}
\]</span></p>
<p>发现 <span class="math inline">\(y_i\)</span> 与 <span
class="math inline">\(u_i\)</span> 的计算方式一致，可以在 LU
分解时分解增广阵直接算出 <span class="math inline">\(y\)</span></p>
<p>乘除法次数 <span class="math inline">\(5n-4\)</span></p>
<h2 id="插值法">插值法</h2>
<p>多项式插值法截断误差估计式：设 <span
class="math inline">\(f^{(n)}(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上连续，<span
class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 上存在，<span
class="math inline">\(p_n(x)\)</span> 是满足插值条件的 <span
class="math inline">\(n\)</span> 次插值多项式，则存在 <span
class="math inline">\(\xi=\xi(x)\in(a,b)\)</span>，使</p>
<p><span class="math display">\[
R_n(x)=f(x)-p_n(x)=\frac{f^{(n+1)(\xi)}}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)
=\frac{f^{(n+1)(\xi)}}{(n+1)!}\pi_{n+1}(x)
\]</span></p>
<p>截断误差实用估计式：设 <span
class="math inline">\(p_n(x)\)</span>，<span
class="math inline">\(\tilde p_n(x)\)</span> 分别是节点 <span
class="math inline">\(x_0,x_1,\cdots,x_n\)</span>，<span
class="math inline">\(x_1,x_2,\cdots,x_{n+1}\)</span>
构造的插值多项式</p>
<p><span class="math display">\[
\begin{cases}
f(x)-p_n(x)\approx \dfrac{\tilde
p_n(x)-p_n(x)}{x_{n+1}-x_0}(x-x_0)  \newline
f(x)-\tilde p_n(x)\approx \dfrac{\tilde
p_n(x)-p_n(x)}{x_{n+1}-x_0}(x-x_{n+1})
\end{cases}
\]</span></p>
<h3 id="拉格朗日插值多项式">拉格朗日插值多项式</h3>
<p>有形式 <span class="math inline">\(L_n(x)=\sum_{i=1}^n
l_i(x)y_i\)</span>，其中 <span class="math inline">\(l_i(x)\)</span> 为
<span class="math inline">\(n\)</span> 次多项式且只在 <span
class="math inline">\(x_i\)</span> 处为一，其他插值节点处为零点 <span
class="math display">\[
L_n(x)=\sum_{i=1}^n
\frac{(x-x_0)(x-x_1)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)}{(x_i-x_0)(x_i-x_1)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_n)}y_i
\]</span></p>
<h3 id="牛顿插值多项式">牛顿插值多项式</h3>
<p>差商</p>
<p><span class="math display">\[
\begin{cases}
f[x_i]=f(x_i) \newline
f[x_i,x_{i+1},\cdots,x_{i+k}]=\dfrac{f[x_{i+1},\cdots,x_{i+k}]-f[x_i,\cdots,x_{i+k-1}]}{x_{i+k}-x_i}
\end{cases}
\]</span></p>
<p>差商表</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 17%" />
<col style="width: 29%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(f[x_i]\)</span></th>
<th><span class="math inline">\(f[x_{i-1},x_i]\)</span></th>
<th><span class="math inline">\(f[x_{i-2},x_{i-1},x_{i}]\)</span></th>
<th><span
class="math inline">\(f[x_{i-3},x_{i-2},x_{i-1},x_{i}]\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(x_0\)</span></td>
<td><span class="math inline">\(f[x_0]\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x_1\)</span></td>
<td><span class="math inline">\(f[x_1]\)</span></td>
<td><span class="math inline">\(f[x_0,x_1]\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(x_2\)</span></td>
<td><span class="math inline">\(f[x_2]\)</span></td>
<td><span class="math inline">\(f[x_1,x_2]\)</span></td>
<td><span class="math inline">\(f[x_{0},x_{1},x_{2}]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x_3\)</span></td>
<td><span class="math inline">\(f[x_3]\)</span></td>
<td><span class="math inline">\(f[x_2,x_3]\)</span></td>
<td><span class="math inline">\(f[x_{1},x_{2},x_{3}]\)</span></td>
<td><span class="math inline">\(f[x_{0},x_{1},x_{2},x_{3}]\)</span></td>
</tr>
</tbody>
</table>
<p>牛顿插值多项式 <span class="math inline">\(N_n(x)\)</span>，（其中
<span class="math inline">\(\pi_{0}(x)=1\)</span>） <span
class="math display">\[
N_n(x)=\sum_{i=0}^{n}f[x_0,\cdots,x_i]\pi_{i}(x)
\]</span> 误差与实用误差估计式</p>
<p><span class="math display">\[
R_n(x)=f(x)-N_n(x)=f[x_0,x_1,\cdots,x_n,x]\pi_{n+1}(x)\approx
f[x_0,x_1,\cdots,x_n,x_{n+1}]\pi_{n+1}(x) = N_{n+1}(x)-N_n(x)
\]</span></p>
<p>差商的性质 <span class="math display">\[
f[x_0,x_i,\cdots,x_n]=\sum_{i=0}^n\frac{f(x_i)}{(x-x_0)(x-x_1)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)}
\]</span> 差商与导数的关系（误差项相等） <span class="math display">\[
f[x_i,x_i,\cdots,x_{i+k}]=\frac{f^{(k)}(\xi)}{k!}
\]</span> 其中 <span class="math inline">\(\xi\)</span> 在 <span
class="math inline">\(x_i,x_{i+1},\cdots,x_{i+k}\)</span> 之间</p>
<p><span class="math inline">\(k\)</span> 阶差商对应 <span
class="math inline">\(k\)</span> 阶导数</p>
<p>设 <span class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(k\)</span> 次多项式，<span
class="math inline">\(f[x_0,x_1,\cdots,x_{k-1}, x]\)</span> 是 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(n-k\)</span> 次多项式（<span
class="math inline">\(k&gt;n\)</span> 时为零）</p>
<h3 id="埃尔米特多项式">埃尔米特多项式</h3>
<p>牛顿型：利用差商和导数的关系填入差商表不定式位置，该表有多重节点</p>
<h3 id="三次样条插值">三次样条插值</h3>
<p>二阶导数连续</p>
<p>在子区间 <span class="math inline">\([x_{i-1},x_{i}]\)</span>
上的表达式</p>
<p><span class="math display">\[
  S(x)= \frac{(x_i-x)^3}{6h_i}M_{i-1} + \frac{(x-x_{i-1})^3}{6h_i}M_{i}
+ \left(y_{i-1}-\frac{h_i^2}{6}M_{i-1}\right)\frac{x_i-x}{h_i}  +
\left(y_{i}-\frac{h_i^2}{6}M_{i}\right)\frac{x_i-x_{i-1}}{h_i}
\]</span></p>
<p>其中 <span class="math inline">\(h_i=x_i-x_{i-1}\)</span>，<span
class="math inline">\(f&#39;&#39;(x_i)=M_{i}\)</span></p>
<p>第一种边界条件三弯矩方程（边界二阶导已知）</p>
<p><span class="math display">\[
\begin{bmatrix}
    2 &amp; \lambda_1 &amp; &amp; &amp; \newline
    \mu_2 &amp; 2 &amp; \lambda_2 &amp; &amp; \newline
    &amp; \ddots &amp; \ddots &amp; \ddots &amp; \newline
    &amp; &amp; \mu_{n-2} &amp; 2 &amp; \lambda_{n-2} \newline
    &amp; &amp; &amp; \mu_{n-1} &amp; 2 \newline
  \end{bmatrix}
  \begin{bmatrix}
    M_1 \newline
    M_2 \newline
    \vdots \newline
    M_{n-2} \newline
    M_{n-1} \newline
  \end{bmatrix}
  =
  \begin{bmatrix}
    d_1 - \mu_1 M_0 \newline
    d_2 \newline
    \vdots \newline
    d_{n-2} \newline
    d_{n-1} - \lambda_{n-1} M_n \newline
  \end{bmatrix}
\]</span></p>
<p>其中 <span class="math inline">\(\mu_i =
\dfrac{h_i}{h_i+h_{i+1}}\)</span>，<span
class="math inline">\(\lambda_i=1-\mu_i\)</span>，<span
class="math inline">\(d_i=6f[x_{i-1},x_{i},x_{i+1}]\)</span></p>
<p>第二种边界条件三弯矩方程（边界一阶导已知）</p>
<p><span class="math display">\[
\begin{bmatrix}
2&amp; 1\\
\mu_1&amp;    2 &amp; \lambda_1 &amp; &amp; &amp; &amp; \newline
&amp;   \mu_2 &amp; 2 &amp; \lambda_2 &amp; &amp; &amp; \newline
&amp;   &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp;  \newline
&amp;   &amp; &amp; \mu_{n-2} &amp; 2 &amp; \lambda_{n-2}&amp;  \newline
&amp;   &amp; &amp; &amp; \mu_{n-1} &amp; 2 &amp; \lambda_{n-1} \newline
&amp; &amp; &amp; &amp; &amp; 1 &amp; 2
  \end{bmatrix}
  \begin{bmatrix}
  M_0\\
    M_1 \newline
    M_2 \newline
    \vdots \newline
    M_{n-2} \newline
    M_{n-1} \newline
    M_n\\
  \end{bmatrix}
  =
  \begin{bmatrix}
  d_0\\
    d_1\\
    d_2 \newline
    \vdots \newline
    d_{n-2} \newline
    d_{n-1}\\
    d_n
  \end{bmatrix}
\]</span></p>
<p>其中 <span
class="math inline">\(d_0=6f[x_{0},x_{0},x_{1}]\)</span>，<span
class="math inline">\(d_n=6f[x_{n-1},x_{n},x_{n}]\)</span></p>
<p>第三种边界条件三弯矩方程（周期函数二阶导连续）</p>
<p><span class="math display">\[
\begin{bmatrix}
    2 &amp; \lambda_1 &amp; &amp; &amp; \lambda_1 \newline
    \mu_2 &amp; 2 &amp; \lambda_2 &amp; &amp; \newline
    &amp; \ddots &amp; \ddots &amp; \ddots &amp; \newline
    &amp; &amp; \mu_{n-1} &amp; 2 &amp; \lambda_{n-1} \newline
    \mu_n &amp; &amp; &amp; \mu_{n} &amp; 2 \newline
  \end{bmatrix}
  \begin{bmatrix}
    M_1 \newline
    M_2 \newline
    \vdots \newline
    M_{n-1} \newline
    M_{n} \newline
  \end{bmatrix}
  =
  \begin{bmatrix}
    d_1 \newline
    d_2 \newline
    \vdots \newline
    d_{n-1} \newline
    d_{n} \newline
  \end{bmatrix}
\]</span></p>
<p>其中 <span
class="math inline">\(d_n=6f[x_{n-1},x_{n},x_{1}]\)</span></p>
<h2 id="函数最优逼近">函数最优逼近</h2>
<p>函数线性相关定义（略）</p>
<p><span class="math inline">\(n+1\)</span> 维线性子空间 <span
class="math inline">\(V=\mathrm{span}\{\phi_0(x),\phi_1(x),\cdots,\phi_n(x)\}\)</span></p>
<p>连续函数 <span class="math inline">\(f,g\in C[a,b]\)</span> 内积
<span class="math display">\[
(f,g)=\int_a^b w(x)f(x)g(x)\ \mathrm dx
\]</span> 内积性质：交换律，线性，分配律，自乘非负性</p>
<p>内积定义函数范数（略）</p>
<h3 id="正交多项式">正交多项式</h3>
<p><span
class="math inline">\(g_0(x),g_1(x),\cdots,g_k(x),\cdots\)</span>，称为正交函数族，若
<span class="math display">\[
(g_i,g_j)=\begin{cases}
0&amp;, j\neq i,\\
\gamma_i &gt; 0&amp;, j=i.
\end{cases}
\]</span> 标准正交函数族：<span
class="math inline">\(\gamma_i=1\)</span>；正交多项式：<span
class="math inline">\(g_k\)</span> 是 <span
class="math inline">\(k\)</span> 次多项式</p>
<p>最高项系数为 <span class="math inline">\(1\)</span>
的正交多项式三项递推关系</p>
<p><span class="math display">\[
\begin{cases}
g_0=1\\
g_1(x)=x-\frac{\beta_0}{\gamma_0}\\
g_{k+1}(x)=\left(x-\frac{(xg_k,g_k)}{(g_k,g_k)}\right)g_k(x)-\frac{(g_k,g_k)}{(g_{k-1},g_{k-1})}g_{k-1}(x)
\end{cases}
\]</span></p>
<p>常记 <span class="math inline">\(\gamma_k=(g_k,g_k)\)</span>，<span
class="math inline">\(\beta_k=(xg_k,g_k)\)</span>，<span
class="math inline">\(b_k=\dfrac{\beta_k}{\gamma_k}\)</span>，<span
class="math inline">\(c_k=\dfrac{\gamma_k}{\gamma_{k-1}}\)</span></p>
<p>常用正交多项式</p>
<ul>
<li>三角函数系 <span class="math inline">\(1,\cos x,\sin x,\cos 2x, \sin
2x,\cdots\)</span>：<span class="math inline">\([-\pi,\pi]\)</span>
上关于 <span class="math inline">\(w(x)=1\)</span></li>
<li>勒让德多项式：<span class="math inline">\([-1,1]\)</span> 上关于
<span class="math inline">\(w(x)=1\)</span></li>
<li>拉盖尔多项式：<span class="math inline">\([0,+\infty]\)</span>
上关于 <span class="math inline">\(w(x)=\mathrm e^{-x}\)</span></li>
<li>埃尔米特多项式：<span
class="math inline">\((-\infty,+\infty)\)</span> 上关于 <span
class="math inline">\(w(x)=\mathrm e^{-x^2}\)</span></li>
<li>切比雪夫多项式：<span class="math inline">\([-1,+1]\)</span> 上关于
<span class="math inline">\(w(x)=\frac{1}{\sqrt{1-x^2}}\)</span></li>
</ul>
<h3 id="最优平方逼近">最优平方逼近</h3>
<p>使用广义多项式 <span
class="math inline">\(p(x)=c_0\phi_0(x)+c_1\phi_1(x)+\cdots\)</span>
逼近给定函数 <span class="math inline">\(f(x)\)</span>，若 <span
class="math inline">\(f(x)\)</span> 是列表函数则是最小二乘逼近，误差
<span class="math inline">\(\|p-f\|_2\)</span> 最小</p>
<p>正规方程组（对称正定阵）</p>
<p><span class="math display">\[
\begin{pmatrix}
(\phi_0,\phi_0) &amp; (\phi_0,\phi_1) &amp; \cdots &amp; (\phi_0,\phi_n)
\newline
(\phi_1,\phi_0) &amp; (\phi_1,\phi_1) &amp; \cdots &amp; (\phi_1,\phi_n)
\newline
\vdots &amp; \vdots &amp;  &amp; \vdots \newline
(\phi_n,\phi_0) &amp; (\phi_n,\phi_1) &amp; \cdots &amp; (\phi_n,\phi_n)
\newline
\end{pmatrix}
\begin{pmatrix}
c_0\\
c_1\\
\vdots\\
c_n
\end{pmatrix}=
\begin{pmatrix}
(\phi_0,f)\\
(\phi_1,f)\\
\vdots\\
(\phi_n,f)
\end{pmatrix}
\]</span></p>
<p>选取广义多项式的方法：</p>
<ol type="1">
<li>选取一组线性无关的基函数</li>
<li>利用三项递推关系构造</li>
<li>利用已知正交多项式变量替换</li>
</ol>
<h3 id="最优一致逼近">最优一致逼近</h3>
<p>使用广义多项式逼近使偏差 <span
class="math inline">\(E=\|f-p_n\|_\infty\)</span> 达到最小</p>
<p>偏差点 <span class="math inline">\(\tilde x\)</span>：<span
class="math inline">\(|f(\tilde x)-p_n(\tilde x)|=E\)</span></p>
<p>切比雪夫定理：<span class="math inline">\(p_n(x)\)</span> 是 <span
class="math inline">\(f(x)\)</span> 的最优一致逼近，充分必要条件是在
<span class="math inline">\([a,b]\)</span> 上至少有 <span
class="math inline">\(n+2\)</span>
个依次正负的偏差点（切比雪夫交错点组）</p>
<p>定理：若 <span class="math inline">\([a,b]\)</span>
上连续则唯一性；若 <span class="math inline">\([a,b]\)</span> 上 <span
class="math inline">\(n+1\)</span> 阶可导且 <span
class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 定号则端点属于交错点组</p>
<p>构造方法为求解极值方程组：</p>
<p><span class="math display">\[
\begin{cases}
f(\tilde x_i)-p_n(\tilde x_i)=(-1)^{i}\mu &amp;, i=0,2,\cdots,n+1,
\newline
f&#39;(\tilde x_i)-p&#39;(\tilde x_i)=0 &amp;, i=1,2,\cdots, n.
\end{cases}
\]</span></p>
<h3 id="近似最优一致逼近">近似最优一致逼近</h3>
<p>最大误差达到最小的多项式</p>
<p>切比雪夫插值多项式法</p>
<p>所使用的插值节点是 <span class="math inline">\(n+1\)</span>
次切比雪夫多项式 <span class="math inline">\(T_{n+1}(x)\)</span>
的零点时，<span class="math inline">\(\max\limits_{-1\le x\le 1}
|\pi_{n+1}(x)|\)</span> 取最小值 <span
class="math inline">\(\dfrac{1}{2^n}\)</span>，误差估计式 <span
class="math inline">\(\dfrac{f^{(n+1)}(\xi)}{(n+1)!}\dfrac{1}{2^n}\)</span></p>
<p><span class="math inline">\(T_{n+1}(x),\ x\in[-1,1]\)</span> 的零点
<span
class="math inline">\(x_i=\cos\left[\dfrac{2i+1}{2(n+1)\pi}\right],\  i=0,1,\cdots,n\)</span></p>
<h2 id="数值积分">数值积分</h2>
<p><span class="math display">\[
I[f]=\int_a^b f(x)\ \mathrm dx=\int_a^b p(x)\ \mathrm dx+\int_a^b R(x)\
\mathrm dx = Q[f]+R[f]
\]</span></p>
<h3 id="牛顿-科茨求积公式">牛顿-科茨求积公式</h3>
<p><span class="math inline">\(p(x)\)</span> 为等距节点插值多项式</p>
<p>令 <span class="math inline">\(h=\dfrac{b-a}{n}\)</span>，<span
class="math inline">\(x_i=a+ih,\ i-0,1,\cdots,n\)</span></p>
<p>求积系数 <span class="math inline">\(A_i\)</span>：<span
class="math inline">\(Q[f]=\sum_i\left(\int_a^bl_i(x)\ \mathrm
dx\right)f(x_i)=\sum_iA_if(x_i)\)</span></p>
<p>梯形求积公式（<span class="math inline">\(n=1\)</span>）</p>
<p><span class="math display">\[
Q[f]=\frac{b-a}{2}[f(a)+f(b)]
\]</span></p>
<p>截断误差（使用广义积分中值定理）</p>
<p><span class="math display">\[
R_1[f]=\int_a^b\frac{f&#39;&#39;(\xi)}{2!}(x-a)(x-b)\ \mathrm
dx=-\frac{(b-a)^3}{12}f&#39;&#39;(\eta)
\]</span></p>
<p>辛普森求积公式（<span class="math inline">\(n=2\)</span>）</p>
<p><span class="math display">\[
Q[f]=\frac{h}{3}[f(x_0)+4f(x_1)+f(x_2)]=\frac{b-a}{6}\left[f(a)+4\left(\frac{a+b}{2}\right)+f(b)\right]
\]</span></p>
<p>截断误差 <span
class="math inline">\(R_2[f]=-\frac{h^5}{90}f^{(4)}(\eta)=-\frac
{(b-a)^5} {2880}f^{(4)}(\eta)\)</span>，代数精度 <span
class="math inline">\(m=3\)</span></p>
<p>科茨求积公式（<span class="math inline">\(n=4\)</span>）</p>
<p><span class="math display">\[
Q[f]=\frac{b-a}{90}\left[7f(a)+32f(x_1)+12f(x_2)+32f(x_3)+7f(b)\right]
\]</span></p>
<p>截断误差 <span
class="math inline">\(R_4[f]=-\frac{8h^7}{945}f^{(6)}(\eta)=-\frac
{(b-a)^7}{1935360}f^{(6)}(\eta)\)</span></p>
<h3 id="复化求积公式">复化求积公式</h3>
<p>设 <span class="math inline">\([a,b]\)</span> 划分 <span
class="math inline">\(n\)</span> 个等长子区间，<span
class="math inline">\(nh=b-a\)</span>，分别使用牛顿-科茨求积公式</p>
<p>连续函数介值定理得截断误差，复化梯形 <span
class="math inline">\(R_{T_n}[f]=\frac{h^3}{12}nf&#39;&#39;(\eta)\)</span>；其他类似</p>
<p>变步长积分法：<span class="math inline">\(n\)</span> 翻倍直到 <span
class="math inline">\(|T_{2n}-T_n|\le \varepsilon\)</span></p>
<h3 id="龙贝格积分法">龙贝格积分法</h3>
<p><span class="math display">\[
\begin{align}
  T_0 &amp; =\frac{b-a}{2}(f(a)+f(b))  \nonumber\newline
  T_{2^{k+1}} &amp; =\frac{1}{2} T_{2^k}+\frac{b-a}{2^{k+1}}\sum
_{i=1}^{2^{k}}f\left(a+(2i-1)\frac{b-a}{2^{k+1}}\right)  \nonumber\newline
  S_{2^k} &amp; =T_{2^{k+1}}+ \frac{1}{4^{1}-1}
(T_{2^{k+1}}-T_{2^k})  \nonumber\newline
  C_{2^k} &amp; =S_{2^{k+1}}+ \frac{1}{4^{2}-1}
(S_{2^{k+1}}-S_{2^k})  \nonumber\newline
  R_{2^k} &amp; =C_{2^{k+1}}+ \frac{1}{4^{3}-1} (C_{2^{k+1}}-C_{2^k})
\nonumber
\end{align}
\]</span></p>
<p>直到 <span
class="math inline">\(|R_{2^{k+1}}-R_{2^k}|&lt;\varepsilon\)</span></p>
<h3 id="待定系数法">待定系数法</h3>
<p>代数精度 <span class="math inline">\(m\)</span>：对于任意次数小于等于
<span class="math inline">\(m\)</span> 的多项式截断误差为零而对 <span
class="math inline">\(m+1\)</span> 次多项式不为零</p>
<p>待定系数法：节点 <span class="math inline">\(x_i\)</span>
给定后，求解方程组 <span class="math inline">\(R[x^k]=0,\
k=0,1,\cdots,m\)</span></p>
<p>广义皮亚诺定理：<span
class="math inline">\(R[f(x)]=R[e(x)]\)</span>，其中 <span
class="math inline">\(e(x)=\dfrac{f^{(m+1)}(\xi)}{(m+1)!}(x-\tilde
x_0)\cdots(x-\tilde x_m)\)</span>，其中 <span
class="math inline">\(\tilde x_i\)</span> 为任意插值节点，<span
class="math inline">\(\xi\)</span> 为区间内与 <span
class="math inline">\(x,\tilde x_i\)</span> 有关的点；计算时选取 <span
class="math inline">\(\tilde x_i\)</span> 为插值节点可以使 <span
class="math inline">\(Q[e]=0\)</span></p>
<h3 id="高斯型求积公式">高斯型求积公式</h3>
<p>有 <span class="math inline">\(n+1\)</span> 个插值节点且代数精度达到
<span class="math inline">\(2n+1\)</span> 的求积公式</p>
<p>求解方法：</p>
<ul>
<li>取 <span class="math inline">\(f(x)=1,x,\cdots,x^{2n+1}\)</span>
求解非线性方程组</li>
<li>节点 <span class="math inline">\(x_i\)</span> 为 <span
class="math inline">\([a,b]\)</span> 上关于权函数 <span
class="math inline">\(w(x)\)</span> 正交的 <span
class="math inline">\(n+1\)</span> 次正交多项式 <span
class="math inline">\(g_{n+1}\)</span> 的零点</li>
</ul>
<p>求积系数 <span class="math display">\[
A_i=\frac{\gamma_n}{g&#39;_{(n+1)}(x_i)g_n(x_i)}
\]</span> 截断误差 <span class="math display">\[
R[f]=\frac{\gamma_{n+1}}{(2n+2)!}f^{(2n+2)}(\eta),\ a\le \eta\le b
\]</span></p>
<h3 id="数值积分稳定性">数值积分稳定性</h3>
<p>当求积系数均为正时是稳定的，例外如：<span
class="math inline">\(n&gt;8\)</span> 的牛顿-科茨求积公式</p>
<h2 id="数值微分">数值微分</h2>
<h3 id="插值型数值微分公式">插值型数值微分公式</h3>
<p>两点型</p>
<p><span class="math display">\[
\begin{cases}
f&#39;(x_0)=\dfrac{f(x_1)-f(x_0)}{h}-\dfrac{h}{2}f&#39;&#39;(\xi)
\newline
f&#39;(x_1)=\dfrac{f(x_0)-f(x_1)}{h}+\dfrac{h}{2}f&#39;&#39;(\xi)
\newline
\end{cases}
\]</span></p>
<p>三点型</p>
<p><span class="math display">\[
\begin{cases}
f&#39;(x_0)=\dfrac{-3f(x_0)+4f(x_1)-f(x_2)}{2h}+\dfrac{h^2}{3}f&#39;&#39;(\xi)
\newline
f&#39;(x_1)=\dfrac{f(x_2)-f(x_0)}{2h}+\dfrac{h^2}{6}f&#39;&#39;&#39;(\xi)
\newline
f&#39;(x_2)=\dfrac{f(x_0)-4f(x_1)+3f(x_2)}{2h}+\dfrac{h^2}{3}f&#39;&#39;(\xi)
\newline
\end{cases}
\]</span></p>
<p>求二阶导</p>
<p><span class="math display">\[
\begin{cases}
f&#39;&#39;(x_0)=\dfrac{f(x_0)+-2f(x_1)+f(x_2)}{h^2}-hf&#39;&#39;&#39;(\xi)+\dfrac{h^2}{6}f^{(4)}(\bar
\xi) \newline
f&#39;&#39;(x_1)=\dfrac{f(x_0)+-2f(x_1)+f(x_2)}{h^2}+\dfrac{h^2}{12}f^{(4)}(\bar
\xi) \newline
f&#39;&#39;(x_2)=\dfrac{f(x_0)+-2f(x_1)+f(x_2)}{h^2}+hf&#39;&#39;&#39;(\xi)+\dfrac{h^2}{6}f^{(4)}(\bar
\xi) \newline
\end{cases}
\]</span></p>
<h3 id="待定系数法-1">待定系数法</h3>
<p>代数精度与数值积分定义一致 <span class="math display">\[
R[f]=f^{(k)}-\sum_{i=0}^kA_kf(x_k)
\]</span> 或埃尔米特插值（略）</p>
<h3 id="外推求导法">外推求导法</h3>
<p>由泰勒公式导出</p>
<p><span class="math display">\[
\begin{cases}
h_i = \dfrac{h}{2^i} \newline
T_0^i = T(h_i)=\dfrac{f(x+h_i)-f(x-h_i)}{2h_i}\\
T_k^i=T_{k-1}^{i+1}+\dfrac{1}{4^k-1}(T_{k-1}^{i+1}-T^i_{k-1})
\end{cases}
\]</span></p>
<p>截断误差 <span class="math display">\[
R[f]=O(h^{2(k+1)})
\]</span></p>
<h3 id="三次样条求导法">三次样条求导法</h3>
<p>顾名思义</p>
<h2 id="非线性方程组迭代法">非线性方程（组）迭代法</h2>
<p>解单变量方程 <span class="math inline">\(f(x)=0\)</span> 的迭代法，记
<span class="math inline">\(x^*\)</span> 为该方程的根</p>
<p>局部收敛定理：根邻域内选取 <span class="math inline">\(x_0\)</span>
收敛</p>
<p>全局收敛定理：含根区间 <span class="math inline">\([a,b]\)</span>
内选取 <span class="math inline">\(x_0\)</span> 收敛</p>
<p>收敛速度：若 <span
class="math inline">\(\lim\limits_{k\to\infty}\dfrac{|x^*-x_{k+1}|}{|x^*-x_k|^p}=c\ne
0\)</span> 则称迭代序列 <span class="math inline">\(p\)</span>
阶收敛；<span class="math inline">\(p=1\)</span> 线性收敛；<span
class="math inline">\(p&gt;1\)</span> 超线性收敛；<span
class="math inline">\(p=2\)</span> 二阶/平方收敛</p>
<p>收敛阶定理：<span class="math inline">\(\phi(x)\)</span>
在不动点邻域内有连续的 <span class="math inline">\(p&gt;1\)</span>
阶导数，则迭代序列 <span class="math inline">\(p\)</span>
阶收敛的充分必要条件是 <span
class="math inline">\(\phi&#39;(x^*)=\phi&#39;&#39;(x^*)=\cdots=\phi^{(p-1)}(x^*)=0,\
\phi^{(p)}\ne 0\)</span></p>
<h3 id="二分法">二分法</h3>
<p>收敛速度慢</p>
<h3 id="简单迭代法">简单迭代法</h3>
<p>修改为同解方程 <span
class="math inline">\(x=\phi(x)\)</span>，构造迭代格式 <span
class="math inline">\(x_{k+1}=\phi(x_k)\)</span></p>
<p>收敛定理：<span class="math inline">\(\phi(x)\)</span> 一阶连续可微且
<span class="math inline">\(x\in[a,b]\)</span> 时 <span
class="math inline">\(\phi(x)\in [a,b]\)</span>；<span
class="math inline">\(\exists\ 0&lt;L&lt;1, \ \mathrm{s.t.}\ \forall\
x\in[a,b]\ |\phi&#39;(x)|\le L &lt; 1\)</span></p>
<p>后验误差估计式：<span
class="math inline">\(|x^*-x_k|\le\dfrac{1}{1-L}|x_{k+1}-x_k|\le\dfrac{L}{1-L}|x_{k}-x_{k-1}|\)</span></p>
<p>先验误差估计式：<span
class="math inline">\(|x^*-x_k|\le\dfrac{L^k}{1-L}|x_{1}-x_0|\)</span></p>
<h3 id="牛顿迭代法">牛顿迭代法</h3>
<p>迭代格式 <span
class="math inline">\(x_{k+1}=x_k-\dfrac{f(x_k)}{f&#39;(x_k)}\)</span></p>
<p>改进牛顿法 1：泰勒公式忽略三阶导得 <span
class="math inline">\((x^*-x_k)\)</span>
的二次方程，取近根作迭代格式</p>
<p>改进牛顿法 2：设反函数 <span class="math inline">\(g(y)\)</span>
三阶连续可微，将其展开得迭代格式 <span
class="math inline">\(x_{k+1}=x_k-\dfrac{f(x_k)}{f&#39;(x_k)}-\dfrac{f&#39;&#39;(x_k)}{2f&#39;^3(x_k)}f^2(x_k)\)</span></p>
<p>简化牛顿法：将导数代换为常数</p>
<p>牛顿下山法：<span
class="math inline">\(x_{k+1}=x_k-\lambda\dfrac{f(x_k)}{f&#39;(x_k)}\)</span>，试算下山因子
<span class="math inline">\(\lambda\)</span> 使 <span
class="math inline">\(|f(x_{k+1})|&lt;|f(x_k)|\)</span> 成立</p>
<p>局部收敛定理：二阶连续可微，<span class="math inline">\(f&#39;(x)\ne
0\)</span></p>
<p>全局收敛定理：二阶连续可微且</p>
<ol type="1">
<li><span class="math inline">\(f(a)f(b)&lt; 0\)</span></li>
<li><span class="math inline">\(f&#39;(x)\ne 0,\ \forall\
x\in[a,b]\)</span></li>
<li><span class="math inline">\(f&#39;&#39;(x)\)</span> 不变号 <span
class="math inline">\(,\ \forall\ x\in[a,b]\)</span></li>
<li><span class="math inline">\(x_0\in[a,b]\ \wedge\
f(x_0)f&#39;&#39;(x_0)&gt;0\)</span></li>
</ol>
<p>由收敛定理及收敛阶定理得牛顿法二阶收敛</p>
<h3 id="弦割法">弦割法</h3>
<p>两点弦割法：<span
class="math inline">\(x_{k+1}=x_k-\dfrac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})}\)</span>，应用中改写避免相近数相减</p>
<p>单点弦割法：<span
class="math inline">\(x_{k+1}=x_k-\dfrac{f(x_k)(x_k-x_{0})}{f(x_k)-f(x_{0})}\)</span></p>
<p>改进弦割法：作反函数的二次牛顿插值多项式</p>
<p>局部收敛定理：二阶连续可微，<span class="math inline">\(f&#39;(x)\ne
0\)</span></p>
<p>全局收敛定理：在牛顿法全局收敛定理的条件下 <span
class="math inline">\(f(x_1)f&#39;&#39;(x_1)&lt;0\)</span></p>
<p>收敛阶 <span
class="math inline">\(p=\dfrac{1+\sqrt{5}}{2}\)</span></p>
<h3 id="加速收敛技术">加速收敛技术</h3>
<p>松弛加速法，应选取松弛因子 <span
class="math inline">\(\omega\)</span> 使 <span
class="math inline">\(\psi&#39;(x^*)=0\)</span> <span
class="math display">\[
x_{k+1}=\psi(x_{k+1})=\frac{\phi(x_k)-\omega x_k}{1-\omega}
\]</span> 艾特肯加速法，由于 <span
class="math inline">\(\dfrac{x^*-x_{k+1}}{x^*-x_k}\approx
\dfrac{x^*-x_k}{x^*-x_{k-1}}\)</span></p>
<p><span class="math display">\[
\bar x_{k+1}=x_{k+1}-\frac{(x_{k+1}-x_k)^{2}}{x_{k+1}-2x_k+x_{k-1}}
\]</span></p>
<h3 id="非线性方程组迭代法-1">非线性方程组迭代法</h3>
<p>记 <span class="math inline">\(x=(x_1,x_2,\cdots,x_n)^{\mathrm
T}\)</span>，<span
class="math inline">\(f(x)=(f_1(x),f_2(x),\cdots,f_n(x))^{\mathrm
T}\)</span></p>
<p>简单迭代法（雅可比迭代法）：<span
class="math inline">\(x^{(k+1)}=\phi(x^{(k)})\)</span></p>
<p>高斯-赛德尔迭代格式：<span
class="math inline">\(x_i^{(k+1)}=\phi_i(x_1^{(k+1)},\cdots,x_{i-1}^{(k+1)},x_i^{(k)},\cdots,x_n^{(k)})\)</span></p>
<p>牛顿法：先求解关于 <span class="math inline">\(\Delta
x^{(k)}\)</span> 的方程组 <span class="math inline">\(J_f(x^{(k)})\Delta
x^{(k)}=-f(x^{(k)})\)</span>，再按下式计算</p>
<p><span class="math display">\[
\begin{cases}
J(x^{(k)})\Delta x^{(k)}=-f(x^{(k)}),\\
x^{(k+1)}=x^{(k)}+\Delta x^{(k)}.\\
\end{cases}
\]</span></p>
<p>全局收敛性定理：空间 <span class="math inline">\(D\subset
R^n\)</span>，<span class="math inline">\(\phi: D\to
D\)</span>，在闭区域 <span class="math inline">\(D_0\subset D\)</span>
满足</p>
<ol type="1">
<li><span class="math inline">\(\phi(x)\subset D_0\)</span>，<span
class="math inline">\(\forall\ x \in D_0\)</span></li>
<li><span class="math inline">\(\exists\ 0 &lt;L&lt;1\)</span>，<span
class="math inline">\(\forall\ x, y\in D_0\)</span>，<span
class="math inline">\(\|\phi(x)-\phi(y)\|\le L\|x-y\|\)</span></li>
</ol>
<p>局部收敛定理：设映射 <span class="math inline">\(\phi\)</span>
有不动点 <span class="math inline">\(x^*\)</span>，谱半径 <span
class="math inline">\(\rho(J_\phi(x^*)) &lt;1\)</span></p>
<p>弦割法：（略）</p>
<p>布洛依登法：使用矩阵 <span class="math inline">\(A_k\)</span>
代替牛顿法雅可比矩阵得 <span
class="math inline">\(x^{(k+1)}=x^{(k)}-A^{-1}f(x^{k})\)</span></p>
<h2 id="常微分方程数值解法">常微分方程数值解法</h2>
<p>一阶常微分方程初值问题</p>
<p><span class="math display">\[
\begin{cases}
y&#39;(x)=f(x,y(x)) &amp;, a\le x\le b\\
y(a)=y_0.
\end{cases}
\]</span> 解存在且唯一性定理（Lipschitz 条件）：<span
class="math inline">\(f(x,y)\)</span> 在区域 <span
class="math inline">\(D=\{(x,y)|a\le x\le b,
-\infty&lt;y&lt;\infty\}\)</span> 且 <span class="math inline">\(\exists
L\)</span> 使 <span class="math display">\[
|f(x,y)-f(x,\bar y)|\le \left|\frac{\partial f}{\partial y}(y-\bar
y)\right|\le L|y-\bar y|
\]</span> 对任意 <span class="math inline">\(x,y,\bar y\)</span>
均成立</p>
<p>高阶常微分方程化为一阶常微分方程组</p>
<p><span class="math display">\[
\begin{cases}
y^{m}=f(x,y&#39;,y&#39;&#39;,\cdots,y^{(m-1)}) &amp;, a\le x\le b\\
y(a)=y_0,y&#39;(a)=y_0&#39;,\cdots,y^{(m-1)}(a)=y_0^{(m-1)}
\end{cases}
\iff
\begin{cases}
y_1&#39;=y_2 \newline
y_2&#39;=y_3 \newline
\ \ \ \ \ \ \vdots \newline
y_{m-1}&#39;=y_m \newline
y&#39;_m=f(x,y_1,\cdots,y_m)\\
y_1(a)=y_0,y_2(a)=y_0&#39;,\cdots,y_m(a)=y_0^{(m-1)}.
\end{cases}
\]</span></p>
<p><span class="math inline">\(p\)</span> 阶方法：局部截断误差 <span
class="math inline">\(R[f]=O(h^{p+1})\)</span></p>
<p>隐式法无法直接得迭代格式，则使用简单迭代法、牛顿法、改进欧拉法（预测-校正）得到格式</p>
<p>收敛性：格式 <span class="math inline">\(y=\phi(x,y,h)\)</span> 关于
<span class="math inline">\(y\)</span> 满足 Lipschitz 条件</p>
<p>绝对稳定性：每一步误差引起的后续误差缩小 <span
class="math inline">\(|e_j|&lt;|e_i|\)</span></p>
<p>绝对稳定区域：一般考察求解试验方程 <span
class="math inline">\(y&#39;=\lambda y\)</span>，<span
class="math inline">\(\mathrm{Re}(\lambda)&lt;0\)</span> 关于 <span
class="math inline">\(\lambda,h\)</span> 的稳定性</p>
<h3 id="数值微分法">数值微分法</h3>
<p>欧拉法（一阶） <span class="math display">\[
y_{i+1}=y_i+hf(x_i,y_i)
\]</span> 局部截断误差 <span
class="math inline">\(R[y]=\dfrac{h^2}{2}y&#39;&#39;(\xi_i)\)</span></p>
<p>后退欧拉法（一阶） <span class="math display">\[
y_{i+1}=y_i+hf(x_{i+1},y_{i+1})
\]</span> 隐式法，写出格式后反解 <span
class="math inline">\(y_{i+1}\)</span>，局部截断误差 <span
class="math inline">\(R[y]=-\dfrac{h^2}{2}y&#39;&#39;(\xi_i)\)</span></p>
<p>中点法（二阶） <span class="math display">\[
y_{i+1}=y_{i-1}+2hf(x_i,y_i)
\]</span> 局部截断误差 <span
class="math inline">\(R[y]=-\dfrac{h^3}{3}y&#39;&#39;&#39;(\xi_i)\)</span></p>
<h3 id="数值积分法">数值积分法</h3>
<p>使用求积公式求解</p>
<p>梯形法（二阶） <span class="math display">\[
y_{i+1}=y_{i}+\frac{h}{2}[f(x_i,y_i)+f(x_{i+1},y_{i+1})]
\]</span> 辛普森法（四阶） <span class="math display">\[
y_{i+1}=y_{i-1}+\frac{h}{3}[f(x_{i-1},y_{i-1})+4f(x_i,y_i)+f(x_{i+1},y_{i+1})]-\frac{h^5}{90}y^{(5)}(\xi_i)
\]</span> 亚当斯显式法（设 <span class="math inline">\(k+1\)</span>
个数据点，插值 <span class="math inline">\(f(x,y)=L_k(x)+R_k(x)\)</span>
积分） <span class="math display">\[
y_{i+1}=y_i+\frac{h}{A}(b_0f_i+b_1f_{i-1}+\cdots+b_kf_{i-k})+B_kh^{k+2}y^{(k+2)}(\xi_i)
\]</span> 亚当斯隐式法 <span class="math display">\[
y_{i+1}=y_i+\frac{h}{A^*}(b_0^*f_{i+1}+b_1^*f_{i}+\cdots+b_k^*f_{i-k+1})+B_k^*h^{k+2}y^{(k+2)}(\xi_i)
\]</span> 经典四级四阶 R-K 法（将局部截断误差 <span
class="math inline">\(R[y]=y(x_{i+1})-y_{i+1}\)</span> 在 <span
class="math inline">\(x_i\)</span> 处泰勒展开）</p>
<p><span class="math display">\[
\begin{align}
y_{i+1}&amp;=  y_i +
\frac{1}{6}\left(  K_1+2  K_2+2  K_3+  K_4\right)  \nonumber\newline
    K_1&amp;=h  f\left(x_i,  y_i\right) \nonumber\\
    K_2&amp;=h  f\left(x_i+\frac{1}{2}h,  y_i+\frac{1}{2}  K_1\right)
\nonumber\\
    K_3&amp;=h  f\left(x_i+\frac{1}{2}h,  y_i+\frac{1}{2}  K_2\right)
\nonumber\\
    K_4&amp;=h  f\left(x_i+h,  y_i+  K_3\right)  \nonumber\newline
\end{align}
\]</span></p>
<h3 id="边值问题数值解法">边值问题数值解法</h3>
<p>二阶常微分方程</p>
<p><span class="math display">\[
y&#39;&#39;=f(x,y,y&#39;),\ a &lt; x &lt; b
\]</span> 第一边值条件 <span
class="math inline">\(y(a)=\alpha\)</span>，<span
class="math inline">\(y(b)=\beta\)</span></p>
<p>第二边值条件 <span
class="math inline">\(y&#39;(a)=\alpha\)</span>，<span
class="math inline">\(y&#39;(b)=\beta\)</span></p>
<p>第三边值条件 <span
class="math inline">\(y&#39;(a)-\alpha_0y(a)=\alpha_1\)</span>，<span
class="math inline">\(y&#39;(b)-\beta_0y(b)=\beta_1\)</span></p>
<p>有限差分法：区间 <span class="math inline">\([a,b]\)</span>
划分为有限小区间使用数值微分法给出三对角方程组</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习与数据挖掘复习笔记</title>
    <url>/2022/05/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>结构按照著名坑导 BJP 的 PPT
整理，不代表作者同意其中任何内容，重要部分（如 BP）以及 PPT
啥都没讲的（如 OPTICS）按我的知识而不是 PPT 整理</p>
<h2 id="考试回忆">考试回忆</h2>
<p>很水，感觉是拍脑袋出题。六个大题</p>
<ol type="1">
<li>欠拟合怎么发现怎么解决</li>
<li>举三个人脸识别的算法，简单描述过程</li>
<li>KNN 优缺点？K 值过大过小怎么办</li>
<li>你的机器学习方法精度上不去怎么办</li>
<li>给一个单隐层网络，算 BP 后权重更新值的形式</li>
<li>给四条离散数据，求最大信息增益的属性</li>
</ol>
<h2 id="概述">概述</h2>
<p>大数据：在可接受的时间内，无法用单机系统完整处理的数据</p>
<ul>
<li>大数据处理：分治，特定场景优化，并行，异构，弹性，横向扩展，容错</li>
<li>Hadoop 离线 Map Reduce；Spark 迭代式；Storm 流式在线实时</li>
</ul>
<p>机器学习（ML），数据挖掘（DM），知识发现（KDD）</p>
<p>数据挖掘基本任务：描述性（挖掘模式），预测性（给出值）</p>
<p>机器学习基本任务：分类，聚类，预测，联想，优化；生成一个数据空间到目标空间的映射
<span class="math inline">\(S\to Z\)</span></p>
<ul>
<li>分类：目标空间已知有限离散</li>
<li>聚类：目标空间位置有限离散</li>
<li>预测：目标空间是连续值空间</li>
<li>联想：目标空间是数据空间，需要发现数据本身的联系</li>
<li>优化：目标是数据空间上的函数 <span
class="math inline">\(F(S)\)</span>，需要 <span
class="math inline">\(\max{d[F(S)]}\)</span>，<span
class="math inline">\(d\)</span> 为一种度量</li>
</ul>
<p>机器学习基本过程：收集数据，清洗数据，提取特征，训练模型，获得知识</p>
<h2 id="数据和度量">数据和度量</h2>
<p>概念：</p>
<ul>
<li>数据集，数据对象和属性的集合</li>
<li>数据属性，又叫变量，字段，特征或特性；属性类型（名词，有序，区间，比值）</li>
<li>数据对象，又叫记录，点，案例，样本，实体或事件</li>
</ul>
<p>数据常见类型：记录数据（数据矩阵，词向量，事务数据），图数据，有序数据</p>
<h3 id="归一化方法">归一化方法</h3>
<p>线性（离差标准化法，最大最小法），其中 <span
class="math inline">\(min\)</span>，<span
class="math inline">\(max\)</span> 分别为数据集最小，最大值 <span
class="math display">\[
v=\frac{x-min}{max-min}
\]</span> Z-Score，其中 <span class="math inline">\(\mu\)</span>，<span
class="math inline">\(\sigma\)</span> 为数据集均值和方差 <span
class="math display">\[
v=\frac{x-\mu}{\sigma}
\]</span> 其他从 <span class="math inline">\((-\infty,+\infty)\)</span>
映射到 <span class="math inline">\([0,1]\)</span>
的函数：高斯，Sigmoid</p>
<h3 id="度量方法">度量方法</h3>
<p>相异性</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 46%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>计算</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>欧几里得</td>
<td><span class="math inline">\(\sqrt{\sum_k(p_k-q_k)^2}\)</span></td>
<td>各维尺度敏感，不识别相关维</td>
</tr>
<tr class="even">
<td>闵可夫斯基距离</td>
<td><span class="math inline">\((\sum_k|p_k-q_k|^r)^{1/r}\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td>马氏距离</td>
<td><span
class="math inline">\(\sqrt{(p-q)^T\Sigma^{-1}(p-q)}\)</span>，其中
<span
class="math inline">\(\Sigma=1/n((\boldsymbol{X}-\boldsymbol{\mu})^T(\boldsymbol{X}-\boldsymbol{\mu}))\)</span>
为所有 <span class="math inline">\(n\)</span> 个样本的协方差矩阵，<span
class="math inline">\(\boldsymbol{X}\)</span> 是 <span
class="math inline">\(n\times m\)</span> 的样本矩阵， <span
class="math inline">\(\boldsymbol{\mu}\)</span> 为 <span
class="math inline">\(1\times m\)</span> 样本均值</td>
<td>各维尺度无关，要求样本数量大于维数且满秩，要求总体一致</td>
</tr>
</tbody>
</table>
<p>相似性</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>计算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>余弦相似度</td>
<td><span class="math inline">\(\cos(p,
q)=\dfrac{pq}{|p||q|}\)</span></td>
</tr>
<tr class="even">
<td>距离倒数</td>
<td><span class="math inline">\(\dfrac{1}{1+d}\)</span></td>
</tr>
<tr class="odd">
<td>杰卡德系数（离散集合）</td>
<td><span class="math inline">\(J(A,B)=\dfrac{|A\cap B|}{|A\cup
B|}\)</span></td>
</tr>
<tr class="even">
<td>Tanimoto 系数</td>
<td><span
class="math inline">\(f(A,B)=\dfrac{\sum_kA_kB_k}{|A|^2+|B|^2-\sum_kA_kB_k}\)</span></td>
</tr>
<tr class="odd">
<td>Dice 系数</td>
<td><span class="math inline">\(S(A,B)=\dfrac{2|A\cap
B|}{|A|+|B|}\)</span></td>
</tr>
<tr class="even">
<td>皮尔森相关系数</td>
<td><span
class="math inline">\(\dfrac{\mathrm{cov}(X,Y)}{\sigma_x\sigma_y}\)</span></td>
</tr>
<tr class="odd">
<td>斯皮尔曼相关系数</td>
<td>排序重新按序赋值后的变量的皮尔森相关系数</td>
</tr>
<tr class="even">
<td>交叉熵</td>
<td><span class="math inline">\(CE(p,q)=-\sum_{i=1}^{k}p_i\log
q_i\)</span></td>
</tr>
<tr class="odd">
<td>KL 散度</td>
<td><span
class="math inline">\(KL(p|q)=\sum_{i=1}^kp_i\log(p_i/q_i)\)</span></td>
</tr>
<tr class="even">
<td>互信息</td>
<td><span
class="math inline">\(I(X,Y)=H(Y)-H(Y|X)=\sum_{x,y}p(x,y)\log(p(x,y)/p(x)/p(y))\)</span></td>
</tr>
</tbody>
</table>
<p>度量公理：非负，对称，三角不等式；Tanimoto，Dice 距离不是度量</p>
<h3 id="机器学习结果评价">机器学习结果评价</h3>
<p>鲁棒性，适应性，简洁性，可解释性</p>
<p>测试数据分割：保留法，交叉验证法，随机法</p>
<p>各指标：</p>
<ul>
<li>误差 <span
class="math inline">\(Error(T)=\sum_{i=1}^{|T|}P_i\|E_i-L_i\|\)</span></li>
<li>正确率 <span
class="math inline">\(Accuracy(T)=|T_{error&lt;\varepsilon}|/|T|\)</span></li>
<li>精度 <span class="math inline">\(TP/(TP+FP)\)</span></li>
<li>召回率 <span class="math inline">\(TP/(TP+FN)\)</span></li>
<li>正确率 <span
class="math inline">\((TP+TN)/(TP+TN+FP++FN)\)</span></li>
<li><span class="math inline">\(F_\beta=(\beta^2+1)precision\cdot
recall/(\beta^2precision + recall)\)</span></li>
<li>假阳率 <span
class="math inline">\(FPR=1-Specificity=TNR=FP/(FP+TN)\)</span></li>
<li>灵敏度 <span
class="math inline">\(Sensitivity=Recall=TPR=TP/(TP+FN)\)</span></li>
<li>特异度 <span
class="math inline">\(Specificity=TNR=TN/(TN+FP)\)</span></li>
</ul>
<p>多分类问题指标处理：宏平均（各类别平均），微平均（先平均每个类别的
<span class="math inline">\(TP\)</span>，<span
class="math inline">\(TN\)</span>，<span
class="math inline">\(FP\)</span>，<span
class="math inline">\(FN\)</span>）</p>
<h2 id="分类">分类</h2>
<h3 id="小样本学习理论">小样本学习理论</h3>
<p>参数 <span class="math inline">\(a\)</span>，被学习函数 <span
class="math inline">\(f(x,a)\)</span>，训练器输出联合概率 <span
class="math inline">\(F(x,y)\)</span>（样本满足该分布），损失函数 <span
class="math inline">\(L(y,y&#39;)\)</span></p>
<p>期望风险 <span class="math display">\[
R(a)=\iint L(y,(f(x,a))\ \mathrm d F(x,y)
\]</span> 经验风险 <span class="math display">\[
R_{\text{empirical}}(a)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i,a))
\]</span> 经验风险最小化原则 ERM</p>
<p>VC 维：对于一个函数集 <span
class="math inline">\(\{f(x,a_1,a_2,\cdots,a_n)|a_i\in
A_i\}\)</span>，如果 <span class="math inline">\(h\)</span>
个样本能由该函数集中的不同函数分类为 <span
class="math inline">\(2^h\)</span> 种不同可能，则 <span
class="math inline">\(f\)</span> 的 VC 维为 <span
class="math inline">\(h\)</span></p>
<ul>
<li><span class="math inline">\(n\)</span> 维超平面的 VC 维为 <span
class="math inline">\(n+1\)</span></li>
<li><span class="math inline">\(R_{\text{emp}} -R(a)=
\varPhi\)</span>，其中随机变量 <span
class="math inline">\(\varPhi\)</span> 满足</li>
</ul>
<p><span class="math display">\[
F_{\varPhi}\left(\sqrt{\dfrac{h\ln(2N/h)+h-\ln(\eta/4)}{N}}\right)=\eta
\]</span></p>
<p>结构风险最小化原则：考虑经验风险和置信界限</p>
<p>过拟合：给定一个假设空间 <span
class="math inline">\(H\)</span>，一个假设 <span
class="math inline">\(h\in H\)</span>，如果存在其他的假设 <span
class="math inline">\(h&#39;\in H\)</span>，使得在训练样例上 <span
class="math inline">\(h\)</span> 的错误率比 <span
class="math inline">\(h&#39;\)</span> 小，但在整个实例分布上 <span
class="math inline">\(h&#39;\)</span> 的错误率 <span
class="math inline">\(h\)</span> 比小，那么就说假设 <span
class="math inline">\(h\)</span> 过度拟合训练数据</p>
<h3 id="knn">KNN</h3>
<p>距离输入对象最近的 <span class="math inline">\(k\)</span>
个对象的属性投票</p>
<h3 id="决策树">决策树</h3>
<p>每次选一个最优属性作为当前节点，去掉该属性分支成两个或多个子节点，递归</p>
<p>ID3 算法评估属性：信息增益 <span
class="math inline">\(IG(S,A)=H(S)-\sum_{v\in
Values(A)}|S_v|/|S|H(S_v)\)</span>，其中 <span
class="math inline">\(S_v\)</span> 表示 <span
class="math inline">\(S\)</span> 中属性 <span
class="math inline">\(A\)</span> 的值为 <span
class="math inline">\(v\)</span> 的样本集</p>
<p>样本集的熵是 <span class="math display">\[
H(S)=\sum_{s\in Classes}-P(s\in S)\log P(s\in S)
\]</span> <span class="math inline">\(P(s\in S)\)</span>
表示该样本在集合 <span class="math inline">\(S\)</span> 中类别为 <span
class="math inline">\(s\)</span> 的概率，用频率计算</p>
<p>搜索策略：优先选择小树防过拟合，早停止法（编码树复杂性），后修剪法</p>
<p>剪枝：将该子树所有后继去掉，把树根变成叶，类别是本节点出现最多的类别</p>
<p>规则后修剪：先变成规则，再删规则</p>
<p>其他的最优属性标准，惩罚值多（<span class="math inline">\(D\)</span>
大）的属性：</p>
<ul>
<li>增益属性：<span
class="math inline">\(GainRatio(S,A)=Gain(S,A)/SplitInformation(S,A)\)</span>，<span
class="math inline">\(SplitInformation(S,A)=\sum_{v\in
D}-|S_v|/|D|\log(|S_v|/|D|)\)</span>；启发式：可以仅对增益过高的属性做惩罚</li>
<li>Mantaras 基于距离的度量（选择最接近理想划分的划分）：设 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 都表示数据集的划分，<span
class="math inline">\(P(A_iB_j)\)</span> 表示一个数据划分在 <span
class="math inline">\(A_i\)</span> 类和 <span
class="math inline">\(B_j\)</span> 类的概率，条件熵 <span
class="math inline">\(H(B|A)=\sum_{i,j}-P(A_iB_j)\log\dfrac{P(A_iB_j)}{P(A_i)}\)</span>，联合熵
<span class="math inline">\(H(A,B)=\sum_{i,j}-P(A_iB_j)\log
P(A_iB_j)\)</span>，距离 <span
class="math inline">\(d(A,B)=H(A|B)+H(B|A)\)</span>，归一化 <span
class="math inline">\(d_N(A,B)=d(A,B)/H(A,B)\)</span></li>
</ul>
<h3 id="随机森林">随机森林</h3>
<p>使用多个基本方法（随机选数据，随机选特征，多个决策树），最后投票或加权平均</p>
<h3 id="朴素贝叶斯">朴素贝叶斯</h3>
<p>事件 <span
class="math inline">\(D=\{A_1,A_2,\cdots,A_n\}\)</span>，<span
class="math inline">\(h\in H\)</span> 为假设，训练数据是一组 <span
class="math inline">\(\left&lt;D_i,h_i\right&gt;\)</span>，<span
class="math inline">\(P(h)\)</span> 称为先验概率，<span
class="math inline">\(P(D|h)\)</span> 为似然度，<span
class="math inline">\(P(h|D)\)</span> 为后验概率</p>
<p>贝叶斯公式 <span class="math display">\[
P(h|D)=\frac{P(D|h)P(h)}{P(D)}
\]</span> 极大后验假设 <span
class="math inline">\(h_{\text{MAP}}=\arg\max_{h}P(D|h)P(h)\)</span></p>
<p>极大似然假设 <span
class="math inline">\(h_{ML}=\arg\max_{h}P(D|h)\)</span></p>
<p>朴素贝叶斯，假设 <span
class="math inline">\(P(a_1,a_2,\cdots,a_n|h)=\prod_i
P(a_i|h)\)</span>，对于事件 <span class="math inline">\(X\)</span>
的估计： <span class="math display">\[
h_{NB}=\arg\max_h P(h)\prod_{a\in X} P(a|h)
\]</span> 对于 <span class="math inline">\(P(h)\)</span> 和 <span
class="math inline">\(P(a|h)\)</span> 的 <span
class="math inline">\(m\)</span>-估计方法 <span class="math display">\[
p=\frac{n_{\text{satisfy}}+mp_{priori}}{n+m}
\]</span></p>
<h3 id="svm">SVM</h3>
<p>固定经验风险，最小化置信界限 <span class="math display">\[
g(\boldsymbol x)=\boldsymbol w^T\boldsymbol x + \boldsymbol b
\]</span> 对于支持向量 <span class="math inline">\(\boldsymbol
x_s\)</span>，<span class="math inline">\(g(\boldsymbol x_s)=\pm
1\)</span>，两个类别的间隔 <span
class="math inline">\(\dfrac{2}{\|\boldsymbol w\|}\)</span></p>
<p>等价于求 <span class="math inline">\(\|\boldsymbol w\|^2\)</span>
最大，加入松弛变量 <span class="math inline">\(\boldsymbol \xi\)</span>
<span class="math display">\[
\begin{aligned}
\min_{\boldsymbol w, \boldsymbol b} \,\,&amp; \|\boldsymbol
w\|^2+\sum_{i=1}^n \xi_i \\
\mathrm{s.t.} \,\,&amp; y_i(\boldsymbol w^T\boldsymbol x + \boldsymbol
b) &gt; 1-\xi_i \text{  and  } \xi_i \ge 0
\end{aligned}
\]</span> 拉格朗日乘子 <span class="math inline">\(\boldsymbol
\alpha\)</span>，有对偶问题 <span class="math display">\[
\begin{aligned}
\max\,\,&amp; f(\boldsymbol \alpha)=\sum _{i=1}^{n}\alpha_{i}-{\frac
{1}{2}}\sum _{i=1}^{n}\sum _{j=1}^{n}y_{i}\alpha_{i}(\mathbf {x}
_{i}^{T}\mathbf {x} _{j})y_{j}\alpha_{j}
\\
\text{s.t.}\,\,&amp; \alpha_i\ge 0\text{  and  }
\sum_{i=1}^ny_i\alpha_i=0
\end{aligned}
\]</span> 是二次规划，可得 <span class="math inline">\(\mathbf {w} =\sum
_{i=1}^{n}\alpha_{i}y_{i}\mathbf {x} _{i}\)</span></p>
<p>非线性可分问题，找一个到高维的映射 <span
class="math inline">\(\varphi(x)\)</span>，利用核函数 <span
class="math inline">\(k(x_i,x_j)=\varphi(x_i)\cdot\varphi(x_j)\)</span>
算高维内积</p>
<p>Mercer 条件：<span class="math inline">\(k(x,y)\)</span>
描述高维内积的充要条件是对任意 <span class="math inline">\(g(x)\)</span>
满足 <span class="math inline">\(\displaystyle \int g^2(x)\ \mathrm
dx\)</span> 存在，有 <span class="math inline">\(\displaystyle \iint
k(x,y)g(x)g(y)\ \mathrm dx\mathrm dy\ge0\)</span></p>
<p>多项式核函数（二次）：<span class="math inline">\(\varphi(\boldsymbol
x) =
\left&lt;x_n^2,\cdots,x_1^2,\sqrt2x_nx_{x-1},\cdots,\sqrt2x_2x_1,\sqrt{2c}x_n,\cdots,\sqrt{2c}x_1,c\right&gt;\)</span>，<span
class="math inline">\(k(\boldsymbol x,\boldsymbol y)=(\boldsymbol
x^T\boldsymbol y+c)^2\)</span></p>
<p>多项式核函数 <span class="math inline">\(k(\boldsymbol x,\boldsymbol
y)=(\boldsymbol x^T\boldsymbol y+c)^d\)</span></p>
<p>径向基核函数（RBF）<span class="math inline">\(k(\boldsymbol
x,\boldsymbol y)=\exp(-\|\boldsymbol x-\boldsymbol
y\|^2/\sigma^2)\)</span></p>
<p>Sigmoid 核函数 <span class="math inline">\(k(\boldsymbol
x,\boldsymbol y)=\tanh(-\gamma\boldsymbol x^T\boldsymbol
y+c)\)</span></p>
<h3 id="logistic-回归">Logistic 回归</h3>
<p>线性回归：<span class="math inline">\(f(\boldsymbol x)=\boldsymbol
w^T\boldsymbol x\)</span>；Logistic 回归：<span
class="math inline">\(f(x)=\sigma(\boldsymbol w^T\boldsymbol
x)\)</span>，<span
class="math inline">\(\sigma(x)=1/(1+e^{-x})\)</span></p>
<p>梯度下降求解，<span class="math inline">\(\dfrac{\partial f}{\partial
w_i}=(f(x_i)-y_i)x_i\)</span></p>
<p>防止过拟合：损失加正则化项 <span
class="math inline">\(\lambda\|\boldsymbol
w\|\)</span>，那么每次迭代会减小参数</p>
<h2 id="聚类">聚类</h2>
<p>硬聚类：任意两类没有共享数据点；软聚类：有</p>
<p>使类内相似度大，类间相似度小</p>
<h3 id="层次聚类">层次聚类</h3>
<p>自顶向下构造（分裂聚类），自底向上构造（凝聚聚类）</p>
<ul>
<li>Linkage（仅凸且可度量）：每次合并最相似的簇；单链（SLink）：两个最近点；全链：两个最远点；均链：平均距离</li>
<li>CURE（任意形状可度量）：使用簇代表点中的最短距离，代表点是互相距离远的
<span class="math inline">\(c\)</span> 个点，向簇中心收缩 <span
class="math inline">\(a\)</span>
倍；先采样，采样点均匀分布在分区，分区分别聚类，再一起聚类，再把剩下点分给簇</li>
</ul>
<p>CHAMELEON（任意形状）：构造 <span
class="math inline">\(k\)</span>-近邻子图，划分成大量子图，然后层次聚类子图，设
<span class="math inline">\(EC(C_i,C_j)\)</span> 为连接类 <span
class="math inline">\(C_i\)</span>，<span
class="math inline">\(C_j\)</span> 所有边的权重，<span
class="math inline">\(EC(C_i)\)</span> 为将 <span
class="math inline">\(C_i\)</span>
划分为两个相等子类的最小割集，相对互联性函数 <span
class="math display">\[
RI(C_i,C_j)=\frac{2\sum EC(C_i,C_j)}{\sum EC(C_i)+\sum EC(C_j)}
\]</span> 相对近似性函数 <span class="math display">\[
RC(C_i,C_j)=\frac{\overline{EC(C_i,C_j)}}{\dfrac{|C_i|}{|C_i|+|C_j|}\overline{EC(C_i)}+\dfrac{|C_j|}{|C_i|+|C_j|}\overline{EC(C_j)}}
\]</span> 聚类使用的相似性度量：<span
class="math inline">\(RI(C_i,C_j)\times RC^\alpha(C_i,C_j)\)</span></p>
<h3 id="划分聚类">划分聚类</h3>
<ul>
<li><span class="math inline">\(k\)</span>-means：取中心</li>
<li><span
class="math inline">\(k\)</span>-medoids：靠近中心的代表点</li>
</ul>
<p>随机取 <span class="math inline">\(k\)</span>
个代表点，然后分配并重新计算代表点直到收敛，评估是各点到各自中心点距离平方和（SSE）</p>
<h3 id="密度聚类">密度聚类</h3>
<ul>
<li>DBSCAN：Eps 邻域内大于 MinPts
的点是核心点，否则若在核心点邻域点则是边界点；到另一个核心点距离小于 Eps
则密度可达；互相可达的核心点和其边界点是一簇</li>
<li>OPTICS：可以分辨密度不同簇，扫的时候维护第 MinPts
远的点距离，拿优先队列加进已扫点集；Reachablility 排序反应簇结构</li>
<li>DENCLUE：推导密度函数，拿局部极值点，各点往梯度方向合并</li>
</ul>
<h3 id="子空间聚类">子空间聚类</h3>
<p>自底向上
CLIQUE（维增长子空间聚类方法）：维数从低到高处理，对每个属性等分，则成超立方网格，网格内大于某个阈值的单元称为稠密单元，由
<span class="math inline">\(k-1\)</span> 维稠密单元产生 <span
class="math inline">\(k\)</span> 维候选稠密单元，最后通过单元发现簇</p>
<p>自顶向下
PROCLUS（维规约子空间聚类方法）：初始化，采样出一个潜在中心点集合；迭代，用新点替代，距离是各子空间的平均；改进，对各中心确定特征子集</p>
<h3 id="ann-聚类">ANN 聚类</h3>
<p>SOM 网络（Self Organizing
Map）：输入层，竞争层。输入层与竞争层全连接，竞争层内部连接，对临近节点激活，远离节点抑制。每次寻找一个获胜节点激活。会把输入映射到一个空间（二维）空间上不同的区域表示不同类别。</p>
<h2 id="神经网络">神经网络</h2>
<p>感知机 <span class="math inline">\(y=f(\boldsymbol w^T\boldsymbol
x-\theta)\)</span>，<span class="math inline">\(f\)</span>
可以是阶跃函数也可以是 <span class="math inline">\(\mathrm
{sgn}\)</span>，单隐层感知机能表示凸区域，双隐层能表示任意形状</p>
<p>分类使用 softmax 将输出映射到概率 <span
class="math inline">\(\text{softmax}(x_i)=\exp(x_i)/\sum_i\exp(x_i)\)</span></p>
<h3 id="常用激活函数">常用激活函数</h3>
<p><span
class="math inline">\(\tanh(x)=\dfrac{\exp(x)-\exp(-x)}{\exp(x)+\exp(-x)}\)</span></p>
<p><span
class="math inline">\(\text{sigmoid}(x)=\dfrac{1}{1+\exp(-x)}\)</span></p>
<p><span class="math inline">\(\text{ReLU}(x)=\max(0,x)\)</span></p>
<h3 id="backpropagation">Backpropagation</h3>
<p>假设总层数 <span class="math inline">\(L\)</span>，代价 <span
class="math inline">\(C\)</span>，第 <span
class="math inline">\(l\)</span> 层输入 <span
class="math inline">\(x^l\)</span>，对应 <span
class="math inline">\(\delta^l=\dfrac{\partial C}{\partial
x^l}\)</span>，算子输出 <span
class="math inline">\(z^l\)</span>，激活输出 <span
class="math inline">\(x^{l+1}=\sigma(z^l)\)</span></p>
<p>最后一层 <span class="math inline">\(\delta^L=\Delta C\cdot
\sigma&#39;(z^L)\)</span></p>
<p>线性层 <span class="math inline">\(z^l=wx^l+b^l\)</span> <span
class="math display">\[
\begin{cases}
\delta^l=(w^{l})^T\delta^{l+1}\cdot\sigma&#39;(z^l)
\\
\dfrac{\partial C}{\partial b^l}=\delta^{l+1}
\\
\dfrac{\partial C}{\partial w^l}=x^l\delta^{l+1}
\end{cases}
\]</span> 卷积层 <span class="math inline">\(z^l=x^l\otimes h^l\)</span>
<span class="math display">\[
\begin{cases}
\delta^l=\delta^{l+1}\otimes \text{ROT}_{180}(h^l)\cdot\sigma&#39;(z^l)
\\
\dfrac{\partial C}{\partial h^l}=\delta^{l+1}\otimes x^l
\end{cases}
\]</span></p>
<h3 id="cnn">CNN</h3>
<p>LeNet and AlexNet：</p>
<p><img src="Comparison_image_neural_networks.svg" alt="Comparison_image_neural_networks" style="zoom: 25%;" /></p>
<p>AlexNet 可多 GPU，不增 Channels 的卷积可以并行</p>
<h4 id="inception">Inception</h4>
<p>来自 GoogleLeNet，拿不同的层卷，然后叠起来</p>
<figure>
<img src="Inception.png" alt="Inception" />
<figcaption aria-hidden="true">Inception</figcaption>
</figure>
<h4 id="residule">Residule</h4>
<p>残差网络</p>
<p>BasicBlock 两个 <span class="math inline">\(3\times3\)</span>
卷积</p>
<p>Bottoleneck <span
class="math inline">\(1\times1\times2^n;3\times3\times2^n;1\times1\times2^{n+1}\)</span></p>
<p>两种单元都计算残差</p>
<h3 id="rnn">RNN</h3>
<p>每层输入 <span class="math inline">\(x^L_t\)</span>，输出 <span
class="math inline">\(x^{L+1}_t=\sigma(z^L_t)\)</span>，权重 <span
class="math inline">\(w^L\)</span>，循环权重 <span
class="math inline">\(u^L\)</span> <span class="math display">\[
z^L_t=w^Lx^L_t+u^L\sigma(z^L_{t-1})
\]</span> BP Through Time：反向传播，沿着时间倒序给自己传播</p>
<p>BiRNN：双向 RNN，实际上是两个反向 RNN 拼起来</p>
<h4 id="lstm">LSTM</h4>
<p><img src="LSTM_Cell.svg.png" alt="LSTM_Cell.svg" style="zoom: 25%;" /></p>
<p>输入门 <span class="math display">\[
\begin{cases}
i_t=\sigma(W_i[h_{t-1},x_t]+b_i)\\
c_t=f_{t}c_{t-1}+i_t\tanh(W_C[h_{t-1},x_t]+b_C)
\end{cases}
\]</span> 输出门 <span class="math display">\[
\begin{cases}
o_t=\sigma(W_o[h_{t-1},x_t]+b_o)\\
h_t=o_t\tanh(c_t)
\end{cases}
\]</span> 遗忘门 <span class="math display">\[
f_t=\sigma(W_f[h_{t-1},x_t]+b_f)
\]</span></p>
<h4 id="nlp">NLP</h4>
<p>词向量表示</p>
<ul>
<li>One-Hot：词典中的位置</li>
<li>共现矩阵：把相邻的词所在词典中的位置也加一</li>
<li>SVD：对共现矩阵奇异值分解</li>
<li>分布式表示：将词映射到低维空间，此时距离产生意义</li>
<li>NNLM：权重矩阵将 One-Hot 映射到低维向量后拼接 <span
class="math inline">\(n\)</span> 个</li>
<li>Word2Vec，上下文 <span class="math inline">\(2m\)</span> 窗口：
<ul>
<li>CBOW，上下文预测当前值，输入词向量序列由一个周围词矩阵乘再平均，softmax
输出每个词的概率</li>
<li>Skip-gram，当前值预测上下文</li>
</ul></li>
<li>Attention：计算 query 和 key 的相似性，归一化后对 values
加权求和</li>
</ul>
<h2 id="智能优化方法">智能优化方法</h2>
<p>遗传算法（GA）：选择，交叉，变异</p>
<p>蚁群算法，<span class="math inline">\(p\)</span> 蚂蚁 <span
class="math inline">\(k\)</span> 在 <span
class="math inline">\(t\)</span> 时刻从位置 <span
class="math inline">\(i\)</span> 移动到位置 <span
class="math inline">\(j\)</span> 的概率，<span
class="math inline">\(\tau\)</span> 是信息素， <span
class="math inline">\(\eta\)</span> 是启发式（能见度），各自有权重 <span
class="math display">\[
p_{ij}^k(t)=\frac{\tau_{ij}^\alpha(t)+\eta_{ij}^\beta(t)}{\sum_{s\in
Reachable(j)}\tau_{is}^\alpha(t)+\eta_{is}^\beta(t)}
\]</span> 信息素更新 <span class="math display">\[
\tau_{ij}(t+1)=\rho\tau_{ij}(t)+\sum_k \frac{Q}{\eta_k(t)}
\]</span>
粒子群算法（PSO）：每步更新速度和位移，速度向自己曾经到过的最优位置和整个群体到过的最优位置迭代；惯性可以逐步减少避免震荡</p>
<p>自适应协方差矩阵进化（CMAES）：进化的目标是找到一个分布 <span
class="math inline">\(P_\theta(X)\)</span>，<span
class="math inline">\(\theta\)</span> 是参数，使 <span
class="math inline">\(f(x)\)</span> 较优。将 <span
class="math inline">\(P_\theta\)</span>
建模为多维高斯。每步调整均值（最优子群加权平均）、协方差矩阵、全局步长</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统考试复习</title>
    <url>/2022/06/14/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>这个课老师纯念 PPT，要命的是 PPT 做得很烂，懂得都懂</p>
<p>这次我做的笔记仅供回忆知识点用，先学会比较好</p>
<p>建议看一遍 Database System Concepts 来真正学习数据库原理</p>
<h2 id="考试回忆">考试回忆</h2>
<p>考试回忆里可能着重列一些我场上觉得不是很确定的题，难度参考下就得了</p>
<ol type="1">
<li>填空（15）：十五个空，考了如何由前趋图判断无法冲突串行等价（有环）</li>
<li>选择（15）：十五题，有锁相容矩阵、事务 UNDO REDO</li>
<li>简答（9）：三个题，非常坑，得理解一下再知道要列什么，老师说只需要列出概念不用详细解释；考了六级模型五级映像、查询优化分类、约束实现（CHECK
字句，断言，存储过程，触发器）</li>
<li>大题：计算关系代数、关系演算转换关系代数、查询优化</li>
<li>大题：SQL 查询</li>
<li>大题：判断范式，最小表示、求候选键、3NF 分解</li>
<li>大题（15）：画 ER 图</li>
</ol>
<h2 id="纯背诵合集">纯背诵合集</h2>
<h3 id="定义">定义</h3>
<p>数据库（DB）：是长期储存在计算机内、有组织的、可共享的大量数据的集合</p>
<p>数据库管理系统（DBMS）：为建立、使用和维护数据库而配置的通用软件系统，是整个数据库系统的核心</p>
<p>数据库系统（DBS）：实现有组织、动态地存储大量相关的结构化数据、方便各类用户访问的计算机软/硬件资源的集合；由数据库和数据库管理系统构成</p>
<p>数据库系统的软件成分：DBMS、高级语言和编译系统、应用开发工具、应用程序（DBAP）</p>
<p>数据库系统的用户：数据库管理员（DBA）、应用程序员、终端用户（End
User）</p>
<p>数据：数据是信息的符号表示或称为载体，信息则是数据的内涵，是对数据语义的解释；数据有语法（Syntax，指格式规定）、语义（Semantic，指含义）两个方面</p>
<p>数据库语言：数据定义语言（DDL）、数据操纵语言（DML）、数据控制语言（DCL）、数据查询语言（QL）；嵌入型，自含型，双重型</p>
<p>数据库例程，多线程
DBMS：编译器、查询优化和实现、存储与索引、通信控制、事务处理、控制程序（安全性控制、完整性控制）、装载、重组、故障恢复、字典管理、性能分析</p>
<h3 id="数据管理的发展">数据管理的发展</h3>
<p>其中独立性指应用程序和数据之间的独立性</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 21%" />
<col style="width: 26%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>性质</th>
<th>人工管理阶段</th>
<th>文件系统阶段</th>
<th>数据库系统阶段</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>背景</td>
<td>Fortran+Batch</td>
<td>OS+Realtime</td>
<td>DBMS+Distributed</td>
</tr>
<tr class="even">
<td>数据量</td>
<td>小</td>
<td>大</td>
<td>很大</td>
</tr>
<tr class="odd">
<td>持久性</td>
<td>无法保存</td>
<td>可持久</td>
<td>可持久</td>
</tr>
<tr class="even">
<td>管理者</td>
<td>应用程序</td>
<td>文件系统</td>
<td>DBMS</td>
</tr>
<tr class="odd">
<td>共享度</td>
<td>无</td>
<td>差</td>
<td>好</td>
</tr>
<tr class="even">
<td>独立性</td>
<td>无</td>
<td>差</td>
<td>好</td>
</tr>
<tr class="odd">
<td>结构化</td>
<td>无</td>
<td>记录内有整体无</td>
<td>有</td>
</tr>
<tr class="even">
<td>数据控制</td>
<td>应用程序</td>
<td>大部分由应用程序</td>
<td>DBMS控制安全完整并发恢复</td>
</tr>
<tr class="odd">
<td>用户接口</td>
<td>无</td>
<td>物理存取</td>
<td>抽象接口</td>
</tr>
</tbody>
</table>
<h3 id="数据模型与模式">数据模型与模式</h3>
<p>数据模型是规定现实世界数据特征的抽象，是用来描述数据的语法、语义和操作的一组概念的集合。描述内容包括数据库的静态特征、动态特征和完整性约束条件。由以下三部分组成</p>
<ol type="1">
<li>数据结构：指对象的类型集合</li>
<li>数据操作：对各种对象的实例允许执行的操作集合</li>
<li>完整性约束：一组完整性规则的集合（静态列级/元组/关系约束、动态列级/元组/关系约束，静态关系约束包含实体/参照/函数依赖/统计约束）</li>
</ol>
<p>三级模型</p>
<ol type="1">
<li>概念数据模型：面向用户和现实世界的数据模型，如 ER 图</li>
<li>逻辑数据模型：数据库角度看到的数据模型，分为层次（只有 <span
class="math inline">\(1:N\)</span>）、网状（需导航式操作）、关系型、面向对象模型</li>
<li>物理数据模型：反映物理存储结构的模型，利用块、索引、聚簇等术语描述</li>
</ol>
<p>数据模式（Schema）是数据库中全体数据的结构和特征的描述，它仅仅涉及类型的描述，不涉及具体的值</p>
<p>三级模式两级映像，两级映像分别保证逻辑独立性和物理独立性</p>
<ol type="1">
<li>外模式：用逻辑数据模型对用户局部数据的描述</li>
<li>模式：用逻辑数据模型对一数据库全体数据的描述</li>
<li>内模式：用物理数据模型对数据的描述</li>
</ol>
<h3 id="数据库设计">数据库设计</h3>
<p>数据库生命周期：系统规划、数据库设计、系统实现、运行和维护</p>
<p>设计方法：面向数据的设计方法、面向过程的设计方法</p>
<p>扩充的 ER
模型：弱实体、普遍化/特殊化（子类、超类；disjoint/overlap）、范畴（合并；U）、聚集（is
part of）</p>
<p>联系集：多于一个实体的数学关系（<span
class="math inline">\(M:N:P\)</span> 联系）</p>
<p>数据库设计六阶段：</p>
<ul>
<li>需求分析：信息要求、处理要求、安全与完整性要求；系统范围图、业务流程图、数据流图、数据字典</li>
<li>概念结构设计（ER）：自顶向下、自底向上、由内而外（是自底向上）、混合策略；
<ul>
<li>集中式设计：所有一起设计</li>
<li>视图集成（合并 ER 图）（二元梯形即成、n
元集成、二元平衡集成）：解决冲突（命名冲突、属性冲突、类型冲突、约束冲突），消除冗余，</li>
</ul></li>
<li>逻辑结构设计（IDEF1x）：转换数据库模式、优化与调整、用户子模式设计
<ul>
<li>联系基数（<span
class="math inline">\(1:N\)</span>）多端用圆点表示</li>
<li>子实体上的外键标“（FK）”</li>
<li>确定性关系实线，FK 是主键</li>
<li>非确定性关系虚线，FK
不是主键：强制性关系（子实体存在依赖父实体）、非强制性关系（父实体菱形）</li>
<li>参照完整性（删父实体怎么办）：限制、级连、设空、无规则</li>
</ul></li>
<li>物理结构设计：确定存储结构、存放位置、存放方法、系统配置、评价物理结构</li>
<li>数据库实施：用 DDL
定义数据库结构、组织数据入库、编制与调试应用程序、数据库试运行</li>
<li>数据库运行与维护：数据库转储与恢复、数据库性能监督分析改进、数据库重组、数据库重构</li>
</ul>
<h3 id="事务管理">事务管理</h3>
<p>事务（Transaction）是数据库环境下由一组数据库操作序列组成的逻辑工作单元</p>
<p>完成后 Commit 或 Rollback</p>
<p>事务特性
ACID：原子性、一致性（前后的数据库均是一致的）、隔离性、持续性（Durability
提交完了就持续了）</p>
<p>事务状态自动机：活动状态、局部提交状态、失败状态、终止状态、提交状态</p>
<p>故障分类：事务故障（逻辑错误和系统错误）、系统故障、介质故障</p>
<p>故障恢复（冗余）：</p>
<ul>
<li>数据备份（转储）：静态（脱机）备份和动态（实时）备份；全备份，部分备份和增量备份</li>
<li>日志文件，先写日志后写数据库；建立检查点时刻正在执行的事物清单</li>
</ul>
<p>并发的问题：丢失修改、读（已被 REDO
的）脏数据、不可重读（被写了）</p>
<p>并发正确性原则：调度为一个次序的安排；两个调度目标等价就是最后结果一定一样；冲突（读写冲突、写写冲突）；两个调度冲突等价即交换不冲突的顺序能使其相等；并发正确即和串行目标等价</p>
<p>前趋图：有冲突操作的事务，先向后建边</p>
<p>锁：排他锁 X（写锁）、共享锁 S（读锁）、更新锁
U（写入前可被别的事物读）</p>
<ol type="1">
<li>一级加锁协议（防丢失修改）：事务 T 在修改数据 T 之前必须先对其加 X
锁，直到事务结束才释放</li>
<li>二级加锁协议（+防脏数据）：+事务 T 在读取数据 A 之前必须先对其加 S
锁，读完后即可释放 S 锁</li>
<li>三级加锁协议（+防不可重复读）：+事务 T 在读取数据 A 之前必须先对其加
S 锁，直到事务结束才释放</li>
</ol>
<p>SQL 中的一致性级别：Serializable, Repeatable Read, Read Committed,
Read Uncommited</p>
<p>两段锁（保证可串行化，不一定保证无死锁）：第一阶段只能加锁，第二阶段只能放锁</p>
<p>防死锁：一次封锁；顺序封锁；事务重执：</p>
<ul>
<li>wait-die：若后要锁的是老事务则老事务等待，否则先要锁的老事务回滚再执行</li>
<li>wound-wait：若后要锁的是新事务则新事务等待，否则先要锁的年轻事物回滚再执行</li>
</ul>
<p>死锁检测：超时、等待图</p>
<p>活锁：可以随着一个事务的锁关掉自行解开；先来先服务避免活锁</p>
<p>多粒度锁：按资源的层次锁；意向锁（IS 要读所有元组, IX 要写元组, SIX
先读再写）：加锁时必须向高层次加的锁</p>
<p>多粒度锁强度偏序 <span class="math inline">\(-\prec IS \prec (S,
IX)\prec SIX \prec X\)</span></p>
<p>多粒度锁相容矩阵</p>
<table>
<thead>
<tr class="header">
<th>T1</th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr class="even">
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr class="odd">
<td>IS</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="even">
<td>IX</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr class="odd">
<td>SIX</td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr class="even">
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>幻影现象：只对元组加锁的话，插入删除就会导致非串行化；可对数据字典加锁/对索引加锁</p>
<h3 id="分布式与并行数据库">分布式与并行数据库</h3>
<p>数据复制、数据分片</p>
<p>六级模式五级映像：</p>
<ol type="1">
<li>全局外模式</li>
<li>全局概念模式（逻辑数据独立性）</li>
<li>分片模式（分片透明性）</li>
<li>分配模式（位置透明性）</li>
<li>局部概念模式（局部数据模型透明性）</li>
<li>局部内模式（物理数据独立性）</li>
</ol>
<p>DDBMS
的部分：全局数据库管理系统（GDBMS），全局数据字典（GDD），局部数据库管理系统（LDBM），通信管理（CM）</p>
<p>两种分类：物理分布逻辑集中/物理分布逻辑分布（联邦分布式数据库）</p>
<p>联邦分布式数据库：数据库转换、模式转换；多数据库系统 MDBS</p>
<p>分布式查询处理：</p>
<ol type="1">
<li>查询分解（和 DBMS 一样）</li>
<li>数据本地化：使用查询树，上推并，下推选择投影</li>
<li>全局优化</li>
<li>局部优化</li>
</ol>
<p>分布式事务管理：全局事务、局部事务</p>
<ul>
<li>两阶段提交协议：投票阶段，决定阶段</li>
<li>三阶段提交协议</li>
</ul>
<p>分布式并发控制：单一锁管理器、多协调器、多数协议、有偏协议、主副本</p>
<p>死锁处理：局部等待图、全局等待图</p>
<p>并行数据库系统：事务间并行、查询间并行、操作间并行、操作内并行；水平并行、垂直并行（流水）</p>
<h2 id="关系模型">关系模型</h2>
<h3 id="定义-1">定义</h3>
<p>域（domain）是相同类型值组成的集合；</p>
<p>定义在 <span class="math inline">\(D_1,D_2,\cdots,D_n\)</span>
上的关系是 <span class="math inline">\(D_1\times D_2\times\cdots \times
D_n\)</span> 的任意子集；</p>
<p>关系的属性 <span class="math inline">\(A,B,C,\cdots\)</span>
是为每个列起的名称；</p>
<p>关系上的超键（SK）是能唯一确定元组的属性集；</p>
<p>关系上的候选键（CK）是能唯一确定元组的极小属性集；</p>
<p>主键（PK）一般从候选键中选择一个；</p>
<p>一个关系上的外键（FK）是另一个关系的候选键；</p>
<p>主属性是在任意候选键中出现过的属性。</p>
<p>关系模式 <span class="math inline">\(R(U,D,DOM,I,F)\)</span>
是对关系的型的描述，其中</p>
<ul>
<li><span class="math inline">\(U=\{A_1,A_2,\cdots,A_n\}\)</span>
是属性的有序集合</li>
<li><span class="math inline">\(D=\{D_1,D_2,\cdots,D_n\}\)</span>
域集合</li>
<li><span class="math inline">\(DOM=\{A_1\to D_1,A_2\to
D_2,\cdots,A_n\to D_n\}\)</span> 是属性到值域的映射的集合</li>
<li><span class="math inline">\(I\)</span>
是完整性约束规则集，约束分为域完整性约束、实体完整性约束（键不重复）、参照完整性约束（外键约束）、用户自定义完整性约束</li>
<li><span class="math inline">\(F\)</span> 是函数依赖集合</li>
</ul>
<p>关系模式的简记：仅列出 <span class="math inline">\(U\)</span>，写作
<span class="math inline">\(R(A_1,A_2,\cdots,A_n)\)</span></p>
<h3 id="关系代数">关系代数</h3>
<p>并 <span class="math inline">\(R\cup S\)</span>、差 <span
class="math inline">\(R-S\)</span>、交 <span class="math inline">\(R\cap
S\)</span>、笛卡尔积 <span class="math inline">\(R\times S\)</span></p>
<p>选择 <span class="math inline">\(\sigma_F(R)\)</span>、投影 <span
class="math inline">\(\Pi_x(R)\)</span>、<span
class="math inline">\(\theta\)</span> 连接 <span
class="math inline">\(R\Join_{A\theta B}S\)</span>、自然连接 <span
class="math inline">\(R\Join S\)</span></p>
<p>外连接 <span class="math inline">\(R*\Join *S\)</span>、左外连接
<span class="math inline">\(R*\Join S\)</span>、右外连接 <span
class="math inline">\(R\Join *S\)</span></p>
<p>半连接 <span class="math inline">\(R\ltimes S=\Pi_R(R\Join
S)\)</span></p>
<p>设 <span class="math inline">\(R(X,Y)\)</span>，<span
class="math inline">\(S(Y)\)</span> 除 <span class="math inline">\(R\div
S=\Pi_X(R)-\Pi_X((\Pi_X(R)\times S)-R)\)</span>，表示 <span
class="math inline">\(R\)</span> 中“包含” <span
class="math inline">\(S\)</span> 中“所有”元组的元组</p>
<p>最小完备集</p>
<ul>
<li><span class="math inline">\(\{\cup, -, \times, \sigma,
\Pi\}\)</span></li>
<li><span class="math inline">\(\{\cup, -, \Join, \sigma,
\Pi\}\)</span></li>
</ul>
<p>等价变换规则</p>
<ul>
<li>选择串接律：<span
class="math inline">\(\sigma_{C_1}(\sigma_{C_2}(R))=\sigma_{C_1\wedge
C_2}(R)\)</span></li>
<li>选择交换律：<span
class="math inline">\(\sigma_{C_1}(\sigma_{C_2}(R))=\sigma_{C_2}(\sigma_{C_1}(R))\)</span></li>
<li>投影串接律（<span class="math inline">\(L_n\subseteq L_2\subseteq
\cdots\subseteq L_1\)</span>）：<span
class="math inline">\(\Pi_{L_1}(\Pi_{L_2}(\cdots(\Pi_{L_n}(R))))=\Pi_{L_1}(R)\)</span></li>
<li>选择投影交换律：<span
class="math inline">\(\Pi_{L}(\sigma_C(R))=\sigma_{C}(\Pi_L(R))\)</span></li>
<li>连接和笛卡尔积的交换律（仅优化时使用，数学上不甚正确）</li>
<li>选择对连接/笛卡尔积的分配律（<span class="math inline">\(U_{C_1}\cap
U_{S}=U_{C_2}\cap U_{R}=\emptyset\)</span>）：<span
class="math inline">\(\sigma_{C_1\wedge C_2}(R\Join
S)=\sigma_{C_1}(R)\Join\sigma_{C_2}(S)\)</span></li>
<li>投影对连接/笛卡尔积的分配律（和上条相似）</li>
<li>选择对交并差的分配律：<span class="math inline">\(\sigma_{C}(R\cap
S)=\sigma_C{R}\cap \sigma_C(S)\)</span></li>
<li>投影对并的分配律：<span class="math inline">\(\Pi_{L}(R\cup
S)=\Pi_L{R}\cup \Pi_L(S)\)</span></li>
<li>连接、笛卡尔积、交、并各自的结合律</li>
</ul>
<h3 id="关系演算">关系演算</h3>
<h4 id="元组关系演算">元组关系演算</h4>
<p><span class="math inline">\(\{t\,|\,P(t)\}\)</span></p>
<p><span class="math inline">\(P\)</span> 为元组关系演算表达式，简化的
BNF 如下 <span class="math display">\[
\begin{aligned}
P(s,t,u,\cdots)
    &amp; \to &amp; P \vee P \\
  &amp; |   &amp; P \wedge P \\
  &amp; |   &amp; \neg P \\
  &amp; |   &amp; \exists s(P) &amp; &amp; \text{There exists a tuple
}s\text{ that satisfies }P\\
  &amp; |   &amp; \forall s(P) &amp; &amp; \text{All tuples of }s\text{
satisfy }P\\
  &amp; |   &amp; (P) \\
  &amp; |   &amp; R(t) &amp; &amp; t\text{ is a tuple of relation} R\\
  &amp; |   &amp; s[i]\, \theta\, t[i] &amp; &amp; \text{The }i\text{ th
attribute of }s\text{ has a }\theta\text{ relationship with the other}\\
  &amp; |   &amp; c\, \theta\, t[i] \\
  &amp; |   &amp; t[i]\, \theta\, c \\
\end{aligned}
\]</span> 蕴含运算 <span class="math inline">\(p\to q\)</span>
可以表示为 <span class="math inline">\(\neg p\vee q\)</span></p>
<p>关系演算的安全表达式是不产生无穷验证和无限关系的表达式，其满足</p>
<ol type="1">
<li>若 <span class="math inline">\(P(t)\)</span> 为真，<span
class="math inline">\(t\)</span> 的每个分量在 <span
class="math inline">\(Dom(P)\)</span> 中</li>
<li><span class="math inline">\(P\)</span> 中对每个存在表达式 <span
class="math inline">\(\exists u(Q)\)</span>，若 <span
class="math inline">\(u\)</span> 使 <span
class="math inline">\(Q\)</span> 为真，<span
class="math inline">\(u\)</span> 的每个分量在 <span
class="math inline">\(Dom(P)\)</span>​ 中</li>
<li><span class="math inline">\(P\)</span> 中对每个全称表达式 <span
class="math inline">\(\forall u(Q)\)</span>，若 <span
class="math inline">\(u\)</span> 使 <span
class="math inline">\(Q\)</span> 为假，<span
class="math inline">\(u\)</span> 的每个分量在 <span
class="math inline">\(Dom(P)\)</span> 中</li>
</ol>
<p>其中 <span class="math inline">\(Dom(P)\)</span> 是 <span
class="math inline">\(P\)</span>
中出现的所有常量和所有关系中的属性值集合</p>
<h3 id="域关系演算">域关系演算</h3>
<p><span
class="math inline">\(\{xyz\cdots\,|\,P(x,y,z,\cdots)\}\)</span></p>
<p>即把元组写开，剩余略</p>
<h3 id="函数依赖">函数依赖</h3>
<p>设 <span class="math inline">\(R\)</span> 为关系模式，<span
class="math inline">\(r\)</span> 是 <span
class="math inline">\(R\)</span> 上的任意一个关系实例，<span
class="math inline">\(X, Y\subseteq U\)</span> 是两个属性子集，若 <span
class="math inline">\(\forall t_1,t_2\in r \wedge t_1[X]=t_2[X]\)</span>
有 <span class="math inline">\(t_1[Y]=t_2[Y]\)</span>，则称 <span
class="math inline">\(Y\)</span> 函数依赖于 <span
class="math inline">\(X\)</span>，记为 <span class="math inline">\(X\to
Y\)</span>；若 <span class="math inline">\(Y\nsubseteq X\)</span>
则称为非平凡函数依赖；一一对应 <span
class="math inline">\(X\leftrightarrow Y\)</span></p>
<p>设 <span class="math inline">\(X\to Y\)</span>，且不存在 <span
class="math inline">\(X&#39;\subset Y\)</span> 使 <span
class="math inline">\(X&#39;\to Y\)</span>，则有完全函数依赖 <span
class="math inline">\(X\stackrel{f}{\to} Y\)</span>；否则有部分函数依赖
<span class="math inline">\(X\stackrel{P}{\to} Y\)</span></p>
<p>若 <span class="math inline">\(X\to Y\)</span>，<span
class="math inline">\(Y\to Z\)</span> 且 <span
class="math inline">\(X\not\to Z\)</span>，则 <span
class="math inline">\(Z\)</span> 传递函数依赖于 <span
class="math inline">\(X\)</span></p>
<p>Armstrong 公理</p>
<ul>
<li>自反：若 <span class="math inline">\(Y\subseteq X\subseteq
U\)</span> 则 <span class="math inline">\(X\to Y\)</span></li>
<li>增广：若 <span class="math inline">\(X\to Y\)</span> 成立，且 <span
class="math inline">\(Z\subseteq U\)</span> 则 <span
class="math inline">\(XZ\to YZ\)</span> 成立</li>
<li>传递：若 <span class="math inline">\(X\to Y\)</span>，<span
class="math inline">\(Y\to Z\)</span> 成立，则 <span
class="math inline">\(X\to Z\)</span> 成立</li>
</ul>
<p>推论</p>
<ul>
<li>合并规则：<span class="math inline">\(X\to Y\)</span> 且 <span
class="math inline">\(X\to Z\)</span>，则 <span
class="math inline">\(X\to YZ\)</span></li>
<li>伪传递规则：<span class="math inline">\(X\to Y\)</span> 且 <span
class="math inline">\(WY\to Z\)</span>，则 <span
class="math inline">\(WX\to Z\)</span></li>
<li>分解规则：<span class="math inline">\(X\to Y\)</span> 且 <span
class="math inline">\(Z\subseteq Y\)</span> 则 <span
class="math inline">\(X\to Z\)</span></li>
</ul>
<p>设 <span class="math inline">\(F\)</span> 是函数依赖集合，若 <span
class="math inline">\(F\)</span> 成立时有 <span
class="math inline">\(X\to Y\)</span> 成立，则称 <span
class="math inline">\(F\)</span> 逻辑蕴含 <span
class="math inline">\(X\to Y\)</span>，记为 <span
class="math inline">\(F\models X\to Y\)</span></p>
<p>闭包 <span class="math inline">\(F^+=\{X\to Y\,|\, F\models X\to
Y\}\)</span></p>
<p>若 F 满足如下三条属性，则称为最小函数依赖集</p>
<ol type="1">
<li><span class="math inline">\(F\)</span> 右部均为单属性</li>
<li><span class="math inline">\(F\)</span> 中不存在 <span
class="math inline">\(X\to A\)</span> 及 <span
class="math inline">\(Z\subset X\)</span> 使得 <span
class="math inline">\(F^+=((F-\{X\to A\})\cup\{Z\to
A\})^+\)</span>，（就是去掉部分依赖）</li>
<li><span class="math inline">\(F\)</span> 中不存在 <span
class="math inline">\(X\to A\)</span> 使得 <span
class="math inline">\(F^+=(F-\{X\to A\})^+\)</span></li>
</ol>
<p>属性集 <span class="math inline">\(X\)</span> 关于 <span
class="math inline">\(R(U,F)\)</span> 上的函数依赖 <span
class="math inline">\(F\)</span> 的闭包 <span
class="math inline">\(X_F^+=\{A\,|\, A\in U \wedge X\to A \in
F^+\}\)</span>；计算该闭包仅需重复应用函数依赖直至不变</p>
<p>三步构造最小函数依赖集：展开为单属性；缩小部分依赖；检查右部是否存在于剩余依赖的闭包，是则去除</p>
<p>由 <span class="math inline">\(R(U,F)\)</span> 求全部的候选键（<span
class="math inline">\(F\)</span> 必须是最小覆盖）：</p>
<ol type="1">
<li>分四类：<span class="math inline">\(C_1\)</span>
不在任何依赖中出现的属性；<span class="math inline">\(C_2\)</span>
仅在左侧出现；<span class="math inline">\(C_3\)</span>
仅在右侧出现；<span class="math inline">\(C_4\)</span> 左右均出现。</li>
<li>若 <span class="math inline">\((C_1\cup C_2)^+=U\)</span> 或 <span
class="math inline">\(C_4=\emptyset\)</span>，则 <span
class="math inline">\(C_1\cup C_2\)</span> 为唯一候选键；否则逐一将
<span class="math inline">\(C_4\)</span> 的属性 <span
class="math inline">\(A_i\)</span> 加入计算闭包，若是 全集，则 <span
class="math inline">\(C_1\cup C_2\cup \{A_i\}\)</span> 是候选键</li>
</ol>
<h3 id="多值依赖">多值依赖</h3>
<p>设关系 <span class="math inline">\(R(U)\)</span>，<span
class="math inline">\(X,Y,Z\subset U\)</span>，<span
class="math inline">\(Z=U-X-Y\)</span>，若对 <span
class="math inline">\(R\)</span> 的任意实例 <span
class="math inline">\(r\)</span> 有：若 <span
class="math inline">\(r\)</span> 中存在两个元组 <span
class="math inline">\(s\)</span>，<span class="math inline">\(t\)</span>
使得 <span class="math inline">\(s[X]=t[X]\)</span>，则 <span
class="math inline">\(r\)</span> 中必然存在两个元组 <span
class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span>
使得，交换 <span class="math inline">\(s\)</span>，<span
class="math inline">\(t\)</span> 在 <span
class="math inline">\(Y\)</span> 属性上的新元组仍在 <span
class="math inline">\(r\)</span> 中出现，则 <span
class="math inline">\(Y\)</span> 多值依赖于 <span
class="math inline">\(X\)</span>，记为 <span
class="math inline">\(X\to\to Y\)</span></p>
<p>多值依赖的 Armstrong 公理</p>
<ul>
<li>互补：若 <span class="math inline">\(X\to\to Y\)</span> 则 <span
class="math inline">\(X\to\to(U-X-Y)\)</span></li>
<li>多值增广：若 <span class="math inline">\(X\to\to Y\)</span> 且 <span
class="math inline">\(V\subseteq W\)</span>，则 <span
class="math inline">\(WX\to\to VY\)</span></li>
<li>多值传递：若 <span class="math inline">\(X\to\to Y\)</span> 且 <span
class="math inline">\(Y\to\to Z\)</span>，则 <span
class="math inline">\(X\to\to(Z-Y)\)</span></li>
<li>若 <span class="math inline">\(X\to Y\)</span> 则 <span
class="math inline">\(X\to\to Y\)</span></li>
<li>若 <span class="math inline">\(X\to\to Y\)</span>，<span
class="math inline">\(Z\subseteq Y\)</span>，且对某一 <span
class="math inline">\(W\)</span>，当 <span class="math inline">\(Y\cap
W=\emptyset\)</span> 时如有 <span class="math inline">\(W\to
Z\)</span>，则 <span class="math inline">\(X\to Z\)</span></li>
</ul>
<h3 id="分解">分解</h3>
<p><span class="math inline">\(R(U,F)\)</span>
的分解是一个关系模式的集合 <span
class="math inline">\(\rho=\{R_1(U_1,F_1),R_2(U_2,F_2),\cdots,R_k(U_k,F_k)\}\)</span>，其中属性集合的并为全集，各函数依赖为在对应属性集上的投影</p>
<p>关系集的投影连接算子</p>
<h4 id="无损连接分解">无损连接分解</h4>
<p>假设 <span class="math inline">\(\rho=\{R_1,R_2,\cdots,R_k\}\)</span>
是 <span class="math inline">\(R\)</span> 的一个分解，<span
class="math inline">\(r\)</span> 是 <span
class="math inline">\(R\)</span> 的一个关系，设投影连接算子 <span
class="math inline">\(m_\rho(r)=r_1\Join r_2\Join\cdots\Join
r_k\)</span>，有</p>
<ul>
<li>属性数量单调，<span class="math inline">\(r\subseteq
m_\rho(r)\)</span></li>
<li>可逆，设 <span class="math inline">\(s=m_\rho(r)\)</span>，有 <span
class="math inline">\(\Pi_{U_i}(s)=r_i\)</span></li>
<li>幂等，<span
class="math inline">\(m_\rho(m_\rho(r))=m_\rho(r)\)</span></li>
</ul>
<p>无损连接分解指 <span class="math inline">\(r=m_\rho(r)\)</span></p>
<p>无损连接分解判定</p>
<ol type="1">
<li>构造一个 <span class="math inline">\(m\times n\)</span>
的符号表，每行对应一个子关系模式，每列对应一个属性，<span
class="math inline">\(A_j\in R_i\)</span> 时， <span
class="math inline">\(T[i,j]=a_j\)</span>，否则 <span
class="math inline">\(T[i,j]=b_{ij}\)</span></li>
<li>根据函数依赖进行变换，如果存在不满足依赖的行，则修改属性值为相同的
<span class="math inline">\(a\)</span>，没 <span
class="math inline">\(a\)</span> 则改为 <span
class="math inline">\(i,j\)</span> 最小的 <span
class="math inline">\(b_{ij}\)</span></li>
<li>若进行了变换回到 2</li>
<li>若存在全 <span class="math inline">\(a\)</span>
行则是无损连接，否则不是</li>
</ol>
<p>两个子模式 <span class="math inline">\(\rho=\{R_1,R_2\}\)</span>
分解的快速判断：<span class="math inline">\((U_1\cap U_2)\to(U_1-U_2)\in
F^+\)</span> 或 <span class="math inline">\((U_1\cap U_2)\to(U_2-U_1)\in
F^+\)</span></p>
<h4 id="保持函数依赖分解">保持函数依赖分解</h4>
<p>若 <span class="math inline">\(F^+=\left(\cup_{i=1}^k
F_i\right)^+\)</span> 则保持函数依赖</p>
<h3 id="范式和规范分解">范式和规范分解</h3>
<p>范式：</p>
<ul>
<li>若 <span class="math inline">\(R\)</span>
每个属性是原子属性，且元组在属性的取值也是不可再分的，则满足 1NF</li>
<li>若 <span class="math inline">\(R\in \text{1NF}\)</span>
且所有非主属性都完全函数依赖于 CK 的所有属性，则满足 2NF</li>
<li>若 <span class="math inline">\(R\in \text{2NF}\)</span>
且所有非主属性不传递函数依赖于 CK 的任何属性，则满足 3NF</li>
<li>若 <span class="math inline">\(R\in \text{3NF}\)</span>
上的任何非平凡函数依赖都有决定子包含某个候选键，则满足 BCNF</li>
<li>若 <span class="math inline">\(R\in\text{BCNF}\)</span>
且其所有非平凡多值依赖都有决定子包含某个候选键，则满足 4NF</li>
</ul>
<p>无损连接且保持函数依赖的 3NF 分解：</p>
<ol type="1">
<li>将 <span class="math inline">\(F\)</span> 转换为最小覆盖</li>
<li>不在 <span class="math inline">\(F\)</span> 中的属性构成 <span
class="math inline">\(R_0(U_0)\)</span>，剩余属性记为 <span
class="math inline">\(U\)</span></li>
<li><span class="math inline">\(F\)</span>
按照决定子相同原则分组，每组的所有属性构成一个关系 <span
class="math inline">\(R_i(U_i)\)</span></li>
<li>加入由候选键构成的关系模式 <span
class="math inline">\(R_{CK}\)</span></li>
</ol>
<p>保证无损连接的 BCNF 分解</p>
<ol type="1">
<li>令 <span class="math inline">\(\rho=\{R(U,F)\}\)</span></li>
<li>若每个子关系是 BCNF，则终止，否则存在函数依赖 <span
class="math inline">\((X\to A)\in F_i^+\)</span> 不包含候选键，则分为
<span class="math inline">\(R_{i1}(XA,F_{i1})\)</span>，<span
class="math inline">\(R_{i2}(U_i-A,F_{i2})\)</span></li>
</ol>
<h2 id="sql">SQL</h2>
<p>请前往 W3C School 等地学习</p>
<h2 id="数据库物理存储">数据库物理存储</h2>
<h3 id="文件">文件</h3>
<p>文件结构：</p>
<ul>
<li>定长记录文件：所有记录一样长，可以使用顺序移动法、末尾移动法、空闲列表法维护</li>
<li>变长记录文件：字节流表示法、保留空间法、锚块/溢出块表示法（做链表）</li>
</ul>
<p>文件组织<del>指的是数据组织成记录、块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录和块之间相互联系的方法</del>（应该是记录组织为逻辑结构的方式）；存取方法指的是对文件所采取的存取操作方法</p>
<p>文件组织：</p>
<ul>
<li>无序文件：插入尾，删除直接删/标志，定期整理；查需扫描</li>
<li>顺序文件：维护有序；插入可使用溢出块形成链表，定期整理</li>
<li>索引文件：使用索引维护文件</li>
<li>散列文件：维护键到桶所在磁盘块地址的映射，可以用溢出桶；非相等比较的查找必须扫；动态散列即拿哈希值的高
<span class="math inline">\(k\)</span> 位先分桶，不够了加大 <span
class="math inline">\(k\)</span> 值，用 Trie 树维护</li>
</ul>
<h3 id="索引">索引</h3>
<p>稠密索引：每个值都有索引；稀疏索引：部分值有索引</p>
<p>主索引：主键是排序域，是每个块的第一个主键值到这个块的映射</p>
<p>聚簇索引：用一个顺序文件中不是键的排序域建的索引，指向这个值第一次出现的块；这个索引文件是一个排序文件；原文件一个块可能被引用多次；只能有一个聚簇索引因为和物理相关</p>
<p>辅助索引：非排序域上的索引；索引指向存储一系列记录指针的磁盘块（类似二级索引）</p>
<p>B 树索引：秩为 <span class="math inline">\(n\)</span>，每个结点至少
<span class="math inline">\(\lceil n/2 \rceil\)</span> 个树指针，至多
<span class="math inline">\(n\)</span> 个，内节点存储键和数据指针，有
<span class="math inline">\(q\)</span> 个树指针的节点有 <span
class="math inline">\(q-1\)</span> 个键</p>
<p>B+
树索引：数据指针仅存在最后一层叶节点并且是同一层，叶节点维护下一个叶节点的指针；一般除非只有一个叶，根可以拥有少于
<span class="math inline">\(\lceil n/2\rceil\)</span>
个树指针，来形成至少两层；下溢时先看兄弟能否补足不然合并</p>
<h2 id="查询处理和优化">查询处理和优化</h2>
<p>过程：（查询）词法分析语法分析（语法树）优化（查询计划）系统执行（结果）</p>
<p>预编译：可执行访问模块（AM）</p>
<p>类型：</p>
<ul>
<li>规则优化</li>
<li>代数优化：把选择展开，选择投影下推叶节点，合并选择投影和一个连接/笛卡尔积组成操作；找公共表达式，投影可与下方二元一起，适当预处理</li>
<li>物理优化（依赖于存取路径的优化），估计选中占比（较大不用无序索引）</li>
<li>代价估算优化：多做几个选最优</li>
<li>语义优化</li>
</ul>
<p>代价估算的单位 <span
class="math inline">\(C_{I/O}=D_0+xD_1\)</span></p>
<p>代价估计模型：</p>
<ul>
<li>连接 <span class="math inline">\(R\Join S\)</span> 中 <span
class="math inline">\(js=|R\Join_C S|/|R\times S|\)</span>，<span
class="math inline">\(0\le js\le1\)</span>，估算 <span
class="math inline">\(js\sim 1/M\)</span>；其中 <span
class="math inline">\(n_R\)</span>，<span
class="math inline">\(n_S\)</span> 为元组数，块因子 <span
class="math inline">\(p_R\)</span>，<span
class="math inline">\(p_S\)</span> 为一块的元组数，块数 <span
class="math inline">\(b_R=\lceil n_R/p_R\rceil\)</span>，假设外循环为
<span class="math inline">\(R\)</span>，内存块数 <span
class="math inline">\(n\ll b_r\sim b_s\)</span></li>
<li>选择 <span class="math inline">\(\sigma_{P(A)}(R)\)</span> 中 <span
class="math inline">\(N_A\)</span> 属性 <span
class="math inline">\(A\)</span> 在关系中不同值数，<span
class="math inline">\(M_A\)</span> 属性的值域大小，<span
class="math inline">\(L_i\)</span> 索引 <span
class="math inline">\(i\)</span> 的级数，<span
class="math inline">\(s\sim N_a/M_A\)</span> 为满足条件的元组数量</li>
</ul>
<p>连接操作的代价：</p>
<ul>
<li>嵌套循环，则 <span class="math inline">\(R\)</span>
的块放进去剩一块给 <span class="math inline">\(S\)</span>，访问块数
<span class="math inline">\(b_R+\lceil b_R/(n-1)\rceil\times
b_S\)</span>，代价 <span class="math inline">\(C_{NLJ} = b_R+\lceil
b_R/(n-1)\rceil\cdot b_S+(js\cdot n_R\cdot r_S)/p_{RS}\)</span></li>
<li>索引嵌套循环，访问块数 <span class="math inline">\(b_R+n_R\cdot
c\)</span>，其中 <span class="math inline">\(c\)</span> 是索引代价
<ul>
<li>无序索引 <span class="math inline">\(C_{NSJ}=b_R+n_R\cdot
(L_B+n_S/N_B)\)</span></li>
<li>聚簇索引 <span class="math inline">\(C_{SJ}=b_R+n_R\cdot
(L_B+n_S/N_B/p_S)\)</span></li>
<li>散列索引 <span class="math inline">\(C_{SHJ}=b_R+n_R\cdot
h\)</span>，其中 <span class="math inline">\(h\sim 1\)</span>
为散列一次访问的块数</li>
</ul></li>
<li>排序归并连接算法，访问块数 <span
class="math inline">\(b_R+b_S\)</span></li>
<li>散列连接算法，各自哈希进同一组桶，各桶里连接，访问块数 <span
class="math inline">\(b_R+b_S\)</span>，代价 <span
class="math inline">\(C_{HJ} = b_R+b_S+js\cdot(n_R\cdot N_B+n_S\cdot
N_A)\)</span></li>
</ul>
<p>选择操作的代价：</p>
<ul>
<li>顺序扫描：<span class="math inline">\(C_{sa}=b_r\)</span> 或 <span
class="math inline">\(C_{sa}=1/2b_R\)</span></li>
<li>利用索引 <span class="math inline">\(C_{lk}=L+1\)</span>，散列索引
<span class="math inline">\(C_{hk}=1\)</span></li>
<li>利用无序索引 <span class="math inline">\(C_{INK}=L+s\)</span></li>
<li>聚簇索引等值 <span class="math inline">\(C_{CI}=L+\lceil
s/p\rceil\)</span>，范围 <span class="math inline">\(C_{CIR}=L+\lceil
b/2\rceil\)</span></li>
</ul>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学提纲</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<h2 id="第一章">第一章</h2>
<h3 id="排列">排列</h3>
<p><span class="math display">\[
P(n,r)=P_{n}^{r}=\frac{n!}{(n-r)!}
\]</span></p>
<h3 id="组合">组合</h3>
<p><span class="math display">\[
\binom{n}{r} =C_n^r=C(n,r)=\frac{n!}{r!(n-r)!}
\]</span></p>
<h3 id="可重排列">可重排列</h3>
<p><span class="math inline">\(n\)</span> 种不同元素取 <span
class="math inline">\(r\)</span> 个可重元素排列</p>
<p><span class="math display">\[
\overline{P}(n,r) = n^r
\]</span></p>
<h3 id="多重排列">多重排列</h3>
<p>每种元素 <span class="math inline">\(x_i\)</span> 选择 <span
class="math inline">\(r_i\)</span> 个按次序排列，<span
class="math inline">\(n=\sum_i r_i\)</span> <span
class="math display">\[
P(n;r_1,\cdots,r_k)=\binom{n}{r_1,r_2,\cdots,r_k}=\frac{n!}{r_1!r_2!\cdots
r_k!}
\]</span></p>
<h3 id="多项式幂次展开系数">多项式幂次展开系数</h3>
<p>有多项式 <span class="math display">\[
(x_1+x_2+x_3+\cdots+x_m)^n
\]</span> 其项 <span
class="math inline">\(x_1^{n_1}x_2^{n_2}x_3^{n_3}\cdots
x_m^{n_m}\)</span> 的系数为</p>
<p><span class="math display">\[
\binom{n}{n_1,n_2,\cdots,n_m}=\frac{n!}{n_1!n_2!\cdots n_m!}
\]</span> 项数 <span class="math inline">\(C(n+m-1,n)\)</span>，系数和
<span class="math inline">\(m^n\)</span></p>
<h3 id="圆周排列">圆周排列</h3>
<p>经旋转重复认为是相同的排列 <span class="math display">\[
Q(n,r)=P(n,r)/r
\]</span> 项链排列：经旋转对称重复认为是相同的排列，排列数 <span
class="math inline">\(Q(n,r)/2\)</span></p>
<h3 id="可重组合">可重组合</h3>
<p><span class="math inline">\(n\)</span> 种不同元素取 <span
class="math inline">\(r\)</span> 个可重元素组合</p>
<p><span class="math display">\[
\overline{C}(n,r)=C(n+r-1,r)
\]</span></p>
<p>线性方程 <span class="math inline">\(x_1+x_2+\cdots+x_n=b\)</span>
的自然数解个数 <span class="math inline">\(C(n+b-1,b)\)</span></p>
<h3 id="不相邻组合">不相邻组合</h3>
<p><span class="math inline">\(n\)</span> 个不同元素 <span
class="math inline">\(x_1,x_2,\cdots,x_n\)</span> 取 <span
class="math inline">\(r\)</span> 个不相邻元素组合（即不存在 <span
class="math inline">\(x_j,x_{j+1}\)</span> 同时选取） <span
class="math display">\[
C(n-r+1,r)
\]</span></p>
<h3 id="格路定理">格路定理</h3>
<p>设 <span class="math inline">\(c&gt;a\)</span>，<span
class="math inline">\(d&gt;b\)</span>，则由 <span
class="math inline">\((a,b)\)</span> 到 <span
class="math inline">\((c,d)\)</span> 的简单格路数 <span
class="math display">\[
|(a,b)-(c,d)|=\binom{(c-a)+(d-b)}{c-a}
\]</span> 从 <span class="math inline">\((0,1)\)</span> 至 <span
class="math inline">\((m,n)\)</span> 不接触对角线 <span
class="math inline">\(y=x\)</span> 格路：采用一一对应原理</p>
<p><span class="math display">\[
\binom{m+n-1}{m}-\binom{m+n-1}{m-1}
=
\left(1-\frac{m}{n}\right)\binom{m+n-1}{m}
\]</span></p>
<h3 id="无根标号树与序列一一对应">无根标号树与序列一一对应</h3>
<p>树到序列：逐个摘去编号最小的叶子，该叶子相邻节点形成的序列（长度
<span class="math inline">\(n-2\)</span>）</p>
<p>序列到树：序列一 <span
class="math inline">\(b_1,b_2,\cdots,b_{n-2}\)</span>，对应序列二 <span
class="math inline">\(1,2,\cdots,n\)</span>，从序列二中找到第一个不出现在序列一中的数
<span class="math inline">\(a_1\)</span>，生成边 <span
class="math inline">\((a_1,b_1)\)</span>。分别从序列一和序列二中去掉
<span class="math inline">\(a_1\)</span> 和 <span
class="math inline">\(b_1\)</span>；在余下的序列中重复上述操作，直到序列一为空，序列
2 余下两点建边</p>
<p>凯利定理：<span class="math inline">\(n\)</span>
个有标号的顶点的树的数目是 <span
class="math inline">\(n^{n-2}\)</span></p>
<h3 id="排列的生成算法">排列的生成算法</h3>
<h4 id="序数法">序数法</h4>
<p>排列的序数 <span
class="math inline">\(m\)</span>：排列在枚举过程的出现排名 <span
class="math display">\[
m=a_n(n-1)!+a_{n-1}(n-2)!+\cdots+a_3\cdot 2!+a_2\cdot 1!
\]</span> 序列 <span class="math inline">\((a_na_{n-1}\cdots
a_2)\uparrow\)</span> 为序数 <span class="math inline">\(m\)</span>
对应的（递增进制）中介数，注意没有第一位</p>
<p>序数求中介数：使用短除法</p>
<p><strong>递增进位制法</strong></p>
<p>递增进位数：<span class="math inline">\(0\le a_k &lt;
k\)</span>，表示第 <span class="math inline">\(k\)</span> 位为 <span
class="math inline">\(k\)</span> 进制</p>
<p>全排列的中介数：<span class="math inline">\(a_k\)</span> 表示数字
<span class="math inline">\(k\)</span> 的右边比 <span
class="math inline">\(k\)</span> 小的数字个数</p>
<p>中介数的全排列：填空法；由大到小从中介数意义确定右侧空格个数</p>
<p>由排列求下一个排列：检查 <span class="math inline">\(k\)</span> 从
<span class="math inline">\(1\sim n\)</span>
使其最大，若排列中存在子序列 <span
class="math inline">\(k,k-1,k-2,\cdots,2,1\)</span>，则将 <span
class="math inline">\(k+1\)</span> 置于 <span
class="math inline">\(k\)</span> 位置，并在剩下的 <span
class="math inline">\(k\)</span> 个空中，依次从左至右填入 <span
class="math inline">\(1,2,\cdots,k\)</span>。若 <span
class="math inline">\(k=n\)</span>，无下一个排列</p>
<p><strong>递减进位制法</strong></p>
<p>中介数各位是递增进位制轴对称 <span
class="math inline">\((a_2a_3\cdots a_n)\downarrow \iff
(a_na_{n-1}\cdots a_2)\uparrow\)</span>，意义由下标决定，权 <span
class="math inline">\(m=\sum\limits_{k=2}^na_k\dfrac{n!}{k!}\)</span></p>
<p>递减进位数：<span class="math inline">\(0\le a_k &lt; k\)</span></p>
<p>全排列的中介数：<span class="math inline">\(a_k\)</span> 表示数字
<span class="math inline">\(k\)</span> 的右边比 <span
class="math inline">\(k\)</span> 小的数字个数</p>
<p>中介数的全排列：由大到小从中介数意义确定右侧空格个数</p>
<p>由排列求下一个排列：若 <span class="math inline">\(n\)</span>
不在最左侧则显然，否则将最长的下降序列 <span
class="math inline">\(n,n-1,n-2,\cdots,i\)</span>
删去，并将它们由小到大排在右端，将 <span
class="math inline">\(i-1\)</span> 与 <span
class="math inline">\(i-2\)</span> 对换，此时的排列就是下一个排列。若
<span class="math inline">\(i&lt;3\)</span> 则无下一个序列</p>
<h4 id="字典序法">字典序法</h4>
<p>下一个排列：</p>
<ol type="1">
<li>串 <span class="math inline">\(P\)</span>
从右到左找出比右边数字小的第一个数 <span
class="math inline">\(P_t\)</span>（最后一个上升位），以及该位以后的后缀
<span class="math inline">\(s_{t+1}\)</span></li>
<li><span class="math inline">\(s_{t+1}\)</span> 中找出比 <span
class="math inline">\(P_t\)</span> 大的最后的数 <span
class="math inline">\(P_p\)</span></li>
<li>将 <span class="math inline">\(P_t\)</span>，<span
class="math inline">\(P_p\)</span> 对换后反转后缀</li>
</ol>
<p>中介数：<span class="math inline">\((k_1k_2\cdots
k_{n-1})\)</span>，<span class="math inline">\(k_i\)</span> 表示数字
<span class="math inline">\(P_i\)</span> 的右边比 <span
class="math inline">\(P_i\)</span> 小的数字个数</p>
<p>序数：<span class="math inline">\(m=k_1\cdot (n-1)!+k_2\cdot
(n-2)!+\cdots+k_{n-1}\cdot1!\)</span></p>
<h4 id="换位法">换位法</h4>
<p>排列 <span class="math inline">\(P=P_1P_2\cdots P_n\)</span> 中数
<span class="math inline">\(k\)</span> 上的箭头方向（移动方向），由排列
<span class="math inline">\(P\)</span> 中 <span
class="math inline">\(1\sim k-1\)</span>
所构成的子序列的奇偶性决定，当为偶时，箭头向左；当为奇时，箭头向右。数
<span class="math inline">\(1,2\)</span>上的箭头规定向左。如 <span
class="math inline">\(\overset\leftarrow8\vec3\vec9\vec6\vec4\vec7\vec5\overset\leftarrow2\overset\leftarrow1\)</span></p>
<p>加点法判断箭头方向：是否加点取决于该数右侧比它小的数数量是否为奇数，子序列
<span class="math inline">\(1\sim k-1\)</span>
点数为偶时箭头向左，否则向右</p>
<p>中介数：<span class="math inline">\((b_2b_3\cdots
b_n)\downarrow\)</span>，<span class="math inline">\(b_i\)</span> 表示
<span class="math inline">\(i\)</span> 箭尾方向上比 <span
class="math inline">\(i\)</span> 小的数的个数</p>
<p>中介数到序数：<span
class="math inline">\(m=\sum\limits_{k=2}^na_k\dfrac{n!}{k!}\)</span></p>
<p>中介数到排列：仅需要确定 <span class="math inline">\(P_k\)</span>
箭头方向，设排列 <span class="math inline">\(P\)</span> 中 <span
class="math inline">\(1\sim k-1\)</span> 所构成的子排列序数为 <span
class="math inline">\(a_{k-1}(P)\)</span>（与逆序数同奇偶性），短除时判断即可</p>
<p>下一个排列：设 <span class="math inline">\(P_j=n\)</span>，当 <span
class="math inline">\(P_j\)</span> 不在顶时 <span
class="math inline">\(P_j\)</span> 与箭头方向元素交换，否则对长度 <span
class="math inline">\(n-1\)</span>
的子排列使用上述做法，下一个排列中所有比 <span
class="math inline">\(P_j\)</span> 大的数改变箭头方向</p>
<h3 id="组合的生成算法">组合的生成算法</h3>
<p>给组合元素排序并以字典序生成</p>
<p>序号：按字典序思想</p>
<h2 id="第二章">第二章</h2>
<h3 id="maclaurin-公式">Maclaurin 公式</h3>
<p><span class="math display">\[
\frac{1}{1-x}=1+x+x^2+x^3+\cdots+x^n+\cdots
\]</span></p>
<p><span class="math display">\[
\mathrm
e^{x}=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots+\frac{x^n}{n!}+\cdots
\]</span></p>
<p><span class="math display">\[
\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdots
\]</span></p>
<p><span class="math display">\[
\cos x=x-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots
\]</span></p>
<p><span class="math display">\[
\ln (1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+\cdots
\]</span></p>
<h3 id="行列式按行展开">行列式按行展开</h3>
<p><span class="math display">\[
D=\sum a_{ij}(-1)^{i+j}M_{ij}
\]</span></p>
<h3 id="线性常系数齐次递推关系">线性常系数齐次递推关系</h3>
<p><span class="math inline">\(k\)</span> 阶线性常系数齐次递推关系 <span
class="math display">\[
a_n+C_1a_{n-1}+C_2a_{n-2}+\cdots+C_ka_{n-k}=0
\]</span> 特征多项式 <span class="math display">\[
C(x)=x^k+C_1x^{k-1}+\cdots+C_{k-1}x+C_k
\]</span> 有 <span class="math display">\[
\begin{align}
x^kC\left(\frac{1}{x}\right)G(x)=P(x)=\sum_{j=0}^{k-1}C_jx^j\sum_{i=0}^{k-1-j}a_ix^i
\nonumber\\
\Rightarrow
G(x)=\frac{P(x)}{1+C_1x+\cdots+C_{k-1}x^{k-1}+C_kx^k}\nonumber
\end{align}
\]</span> 由于 <span class="math inline">\(P(x)\)</span> 次数低于 <span
class="math inline">\(k\)</span>，则 <span
class="math inline">\(G(x)\)</span>
有分子为常数、分母为特征根表达式的分项表示</p>
<p>设特征多项式有 <span class="math inline">\(k\)</span> 个根 <span
class="math inline">\(q_1,q_2,\cdots,q_k\)</span>，则通解中有 <span
class="math inline">\(k\)</span> 个分项（<span
class="math inline">\(A_i\)</span> 为待定系数）：</p>
<ul>
<li>若 <span class="math inline">\(q_i\)</span> 为单根，则项 <span
class="math inline">\(A_iq_i^n\)</span> 在通解中</li>
<li>若 <span class="math inline">\(q_i\)</span> 为 <span
class="math inline">\(m\)</span> 重根，则项 <span
class="math inline">\(\left(A_{i0}+A_{i1}n+A_{i2}n^2+\cdots+A_{i(m-1)}n^m\right)q^n\)</span>
在通解中</li>
<li>若 <span class="math inline">\(q_{i1},q_{i2}\)</span> 是一对共轭复根
<span class="math inline">\(\rho \mathrm e^{\pm \theta\mathrm
i}\)</span>，则项 <span
class="math inline">\(A_{i1}\rho^n\cos(n\theta)+A_{i2}\rho^n\sin(n\theta)\)</span>
在通解中</li>
</ul>
<h3 id="线性常系数非齐次递推关系">线性常系数非齐次递推关系</h3>
<p><span class="math inline">\(k\)</span> 阶线性常系数非齐次递推关系
<span class="math display">\[
a_n+C_1a_{n-1}+C_2a_{n-2}+\cdots+C_ka_{n-k}=f(n)
\]</span> 先求齐次通解，非齐次特解求解如下：</p>
<p>当 <span class="math inline">\(f(n)=r^ng(n)\)</span>，其中 <span
class="math inline">\(g(n)\)</span> 是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(p\)</span> 次多项式，<span
class="math inline">\(r\)</span> 是 <span
class="math inline">\(C(x)=0\)</span> 的 <span
class="math inline">\(m\ge 0\)</span> 重根，特解形式 <span
class="math inline">\(r^n\left(k_0n^m+k_1n^{m+1}+\cdots+k_pn^{m+p}\right)\)</span></p>
<h3 id="ferrers-图像">Ferrers 图像</h3>
<p>自上而下的 <span class="math inline">\(n\)</span> 层格子，第 <span
class="math inline">\(i\)</span> 层格子数为 <span
class="math inline">\(m_i\)</span>，则 <span
class="math inline">\(m_i\ge m_{i+1}\)</span> 的图像称为 Ferrers
图像</p>
<p>等价于一个拆分成 <span class="math inline">\(n\)</span>
个整数的整数拆分</p>
<p>结论：</p>
<ul>
<li>整数 <span class="math inline">\(n\)</span> 拆分成 <span
class="math inline">\(k\)</span> 个数的和的拆分数，和数 <span
class="math inline">\(n\)</span> 拆分成最大数为 <span
class="math inline">\(k\)</span> 的数的和的拆分数相等</li>
<li>整数 <span class="math inline">\(n\)</span> 拆分成最多不超过 <span
class="math inline">\(m\)</span> 个数的和的拆分数，和 <span
class="math inline">\(n\)</span> 拆分成最大不超过 <span
class="math inline">\(m\)</span> 的拆分数相等</li>
<li>整数 <span class="math inline">\(n\)</span>
拆分成互不相同的若干奇数的和的的拆分数，和 <span
class="math inline">\(n\)</span> 拆分成自共轭的 Ferrers
图像的拆分数相等</li>
</ul>
<h3 id="指数型母函数">指数型母函数</h3>
<p><span class="math display">\[
G_e(x)=a_0+\frac{a_1}{1!}x+\frac{a_2}{2!}x^2+\frac{a_3}{3!}x^3+\cdots+\frac{a_n}{n!}x^n+\cdots
\]</span></p>
<p>若元素 <span class="math inline">\(x_1\)</span>有 <span
class="math inline">\(n_1\)</span> 个，元素 <span
class="math inline">\(x_2\)</span> 有 <span
class="math inline">\(n_2\)</span> 个，元素 <span
class="math inline">\(x_k\)</span> 有 <span
class="math inline">\(n_k\)</span> 个；组成的 <span
class="math inline">\(n=\sum n_k\)</span> 个元素中取 <span
class="math inline">\(r\)</span> 个排列，设其不同的排列数为 <span
class="math inline">\(p_r\)</span>。则序列 <span
class="math inline">\(p_0,p_1,p_2,\cdots,p_n\)</span> 的指数型母函数为
<span class="math display">\[
G_e(x)=
(1+\frac{x}{1!}+\frac{x^2}{2!}+\cdots+\frac{x^n_1}{n_1!})
(1+\frac{x}{1!}+\frac{x^2}{2!}+\cdots+\frac{x^n_2}{n_2!})
\cdots
(1+\frac{x}{1!}+\frac{x^2}{2!}+\cdots+\frac{x^n_k}{n_k!})
\]</span></p>
<h3 id="错排">错排</h3>
<p>递推关系 <span
class="math inline">\(D_n=(n-1)(D_{n-1}+D_{n-2})\)</span>，<span
class="math inline">\(D_1=0\)</span>，<span
class="math inline">\(D_2=1\)</span></p>
<p>通项 <span
class="math inline">\(D_n=\left[1-1+\frac{1}{2!}-\frac{1}{3!}+\cdots+(-1)^n\frac{1}{n!}\right]n!\)</span></p>
<h3 id="stirling-数">Stirling 数</h3>
<p>第一类 <span class="math display">\[
x(x-1)(x-2)\cdots(x-n+1)=s(n,0)+s(n,1)x+s(n,2)x^2+\cdots+s(n,n)x^n
\]</span> 递推 <span
class="math inline">\(s(n+1,k)=s(n,k-1)-ns(n,k)\)</span></p>
<p>第二类 <span class="math display">\[
S(n,m)=mS(n-1,m)+S(n-1,m-1)
\]</span></p>
<h3 id="球与盒子">球与盒子</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 39%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>球有无区别</th>
<th>盒有无区别</th>
<th>允许空盒</th>
<th>不允许空盒</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>有</td>
<td>有</td>
<td><span class="math inline">\(m^n\)</span></td>
<td><span class="math inline">\(m!S(n,m)\)</span></td>
</tr>
<tr class="even">
<td>有</td>
<td>无</td>
<td><span class="math inline">\(\sum_{i=1}^{\min(n,m)}
S(n,i)\)</span></td>
<td><span class="math inline">\(S(n,m)\)</span></td>
</tr>
<tr class="odd">
<td>无</td>
<td>有</td>
<td><span class="math inline">\(C(n+m-1,n)\)</span></td>
<td><span class="math inline">\(C(n-1,m-1)\)</span></td>
</tr>
<tr class="even">
<td>无</td>
<td>无</td>
<td><span
class="math inline">\(G(x)=\frac{1}{(1-x)(1-x^2)\cdots(1-x^m)}\)</span></td>
<td><span
class="math inline">\(G(x)=\frac{x^m}{(1-x)(1-x^2)\cdots(1-x^m)}\)</span></td>
</tr>
</tbody>
</table>
<h3 id="catalan-数">Catalan 数</h3>
<p>凸 <span class="math inline">\(n\)</span>
边形由不相交对角线拆分三角形的方案数</p>
<p><span class="math inline">\(n\)</span>
个元素确定进栈序列的出栈序列方案数</p>
<p><span class="math inline">\(n\)</span> 个矩阵连乘的结合方案数 <span
class="math display">\[
h_{n+1}=h_2h_n+h_3h_{n-1}+\cdots+h_nh_2 = \frac{1}{n}\binom{2n-2}{n-1}
\]</span></p>
<h2 id="第三章">第三章</h2>
<h3 id="容斥原理">容斥原理</h3>
<p><span class="math display">\[
\left|\bigcup_{A\in C}A\right|
=\sum_{s=1}^n (-1)^{s-1}\sum_{|S|=s\wedge S\subset C}\left|\bigcap_{A\in
S} A\right|
\]</span></p>
<h3 id="棋盘多项式">棋盘多项式</h3>
<p><span class="math inline">\(r_k(C)\)</span> 表示 <span
class="math inline">\(k\)</span> 个棋子布置到棋盘 <span
class="math inline">\(C\)</span> 上的方案数，棋盘 <span
class="math inline">\(C\)</span> 由形状表示，<span
class="math inline">\(r_0(C)=1\)</span>，<span
class="math inline">\(r_0(\emptyset)=1\)</span>；讨论一个格子有无放子，则
<span class="math inline">\(r_k(C)=r_{k-1}(C_i)+r_k(C_e)\)</span>，其中
<span class="math inline">\(C_i\)</span> 表示去掉该行该列，<span
class="math inline">\(C_e\)</span>
表示去掉该格；不冲突的部分乘法原则</p>
<p>棋盘多项式 <span class="math display">\[
R(C)=\sum_k r_k(C)x^k
\]</span> 有禁区的排列数 <span class="math display">\[
r_0n!-r_1(n-1)!+r_2(n-2)!-\cdots+(-1)^nr_n
\]</span> 其中 <span class="math inline">\(r_k\)</span> 表示 <span
class="math inline">\(k\)</span> 个棋子布置在禁区的方案数</p>
<h3 id="广义容斥原理">广义容斥原理</h3>
<p><span class="math display">\[
\beta(m)=\sum_{k=m}^n(-1)^{k-m}\binom{k}{m}\alpha(k)
\]</span></p>
<p><span class="math inline">\(A_i\)</span> 为有第 <span
class="math inline">\(i\)</span> 种性质的元素集合；<span
class="math inline">\(\alpha(m)=\sum_{|S|=m}\left|\bigcap_{A\in S}
A\right|\)</span> 为至少有 <span class="math inline">\(m\)</span>
种性质的元素集合；<span class="math inline">\(\beta(m)\)</span> 为恰有
<span class="math inline">\(m\)</span> 种性质的元素的集合</p>
<h3 id="欧拉函数">欧拉函数</h3>
<p><span class="math inline">\(\varphi(n)\)</span> 小于 <span
class="math inline">\(n\)</span> 且与 <span
class="math inline">\(n\)</span> 互素的数的个数，设 <span
class="math inline">\(n=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}\)</span></p>
<p><span class="math display">\[
\varphi(n)=n\left(1-\frac{1}{p_1}\right)\left(1-\frac{1}{p_2}\right)\cdots\left(1-\frac{1}{p_k}\right)
\]</span></p>
<h3 id="莫比乌斯反演">莫比乌斯反演</h3>
<p>莫比乌斯函数</p>
<p><span class="math display">\[
\mu(d)=\begin{cases}
1 &amp;,\ d=1;\\
(-1)^k &amp;,\ d=\prod_{i=1}^k p_i\\
0 &amp;,\ \exists p^2 | d
\end{cases}
\]</span> 莫比乌斯反演定理：<span class="math inline">\(F(n)\)</span> 和
<span class="math inline">\(f(n)\)</span>
是定义在非负整数集合上的两个函数，并且满足 <span class="math display">\[
F(n)=\sum_{d|n}f(d)
\]</span> 那么存在一个结论 <span class="math display">\[
f(n)=\sum_{d|n}\mu(d)F\left(\frac{n}{d}\right)
\]</span> 性质</p>
<p><span class="math display">\[
\varphi(n)=\sum_{d|n}\mu(d)\frac{n}{d}
\]</span> 应用于圆排列问题，设集合 <span
class="math inline">\(|A|=m\)</span> 中取 <span
class="math inline">\(d\)</span> 个元素，作周期是 <span
class="math inline">\(d\)</span> 的圆排列个数为 <span
class="math inline">\(M(d)\)</span>，则为线排列计数</p>
<p><span class="math display">\[
\sum_{d|n}dM(d)=m^n
\]</span> 得 <span class="math display">\[
nM(n)=\sum_{d|n}\mu(d)m^{\frac{n}{d}}
\]</span> 则长度为 <span class="math inline">\(n\)</span> 的圆排列个数
<span class="math display">\[
T(n)=\sum_{d|n}M(d)=\sum_{d|n}\frac{1}{d}\sum_{d_1|d}\mu(d)m^\frac{d}{d_1}
\]</span></p>
<h3 id="鸽巢原理">鸽巢原理</h3>
<p>应用：<span class="math inline">\(m,n\)</span> 是正整数，则长度为
<span class="math inline">\(mn+1\)</span> 的无重序列 <span
class="math inline">\(S\)</span> 有一长度为 <span
class="math inline">\(m+1\)</span> 的严格增子序列或长度为 <span
class="math inline">\(n+1\)</span> 的严格减子序列</p>
<p>推广鸽巢原理</p>
<p><span class="math inline">\(m_1,m_2,\cdots,m_n\)</span>
都是正整数，并有 <span class="math inline">\(m_1 + m_2 +\cdots +m_n-n +
1\)</span> 个鸽子住进 <span class="math inline">\(n\)</span>
个鸽巢，则至少对某个 <span class="math inline">\(i\)</span> 有第 <span
class="math inline">\(i\)</span> 个巢中至少有 <span
class="math inline">\(m_i\)</span> 个鸽子，<span class="math inline">\(i
= 1 , 2 ,\cdots, n\)</span></p>
<p>推论：若 <span class="math inline">\(\overline m\ge
r\)</span>，则至少一个 <span class="math inline">\(\ge r\)</span></p>
<h3 id="ramsey-问题">Ramsey 问题</h3>
<p>给定一对正整数 <span
class="math inline">\(a,b\)</span>，存在一个最小的正整数 <span
class="math inline">\(r\)</span>，对 <span
class="math inline">\(r\)</span>
个顶点的完全图的边任意红、蓝２着色，存在 <span
class="math inline">\(a\)</span> 个顶点的红边完全图或 <span
class="math inline">\(b\)</span> 个顶点的蓝边完全图，记为 r ( a , b
)</p>
<p>判定树</p>
<h2 id="第四章">第四章</h2>
<h3 id="群">群</h3>
<p>定义：满足封闭性、结合律、有幺元、有逆元</p>
<p>性质：设 <span class="math inline">\(a\in G\)</span>，则存在最小乘数
<span class="math inline">\(r(a)\)</span>，使 <span
class="math inline">\(a^{r(a)}=e\)</span>，且 <span
class="math inline">\(a^{-1}=a^{r(a)-1}\)</span>（可得费马小定理），<span
class="math inline">\(r(a)\)</span> 称为元素 <span
class="math inline">\(a\)</span> 的阶</p>
<h3 id="置换">置换</h3>
<p><span class="math display">\[
P=\begin{pmatrix}
1 &amp; 2 &amp; \cdots &amp; n\\
a_1 &amp; a_2 &amp;\cdots &amp; a_n
\end{pmatrix}
\]</span></p>
<p>任何一个 <span class="math inline">\(n\)</span> 阶有限群都同构一个
<span class="math inline">\(n\)</span> 个文字的置换群 <span
class="math inline">\(S_n\)</span></p>
<p>循环表示</p>
<p><span class="math display">\[
\begin{pmatrix}
a_1 &amp; a_2 &amp;\cdots &amp; a_n
\end{pmatrix}
=
\begin{pmatrix}
a_1 &amp; a_2 &amp;\cdots &amp; a_n\\
a_2 &amp; a_3 &amp;\cdots &amp; a_1
\end{pmatrix}
\]</span> 对换：二阶循环</p>
<p>奇置换，偶置换：逆序数、对换个数</p>
<p>偶置换构成 <span class="math inline">\(\frac{n!}{2}\)</span>
的子群（交代群）</p>
<p>共轭类：循环分解中同阶循环的数量一致的置换</p>
<p>共轭类 <span
class="math inline">\((1)^{n_1}(2)^{n_2}\cdots(m)^{n_m}\)</span>
的元的个数</p>
<p><span class="math display">\[
\frac{n!}{\left(\prod n_i!\right)\left(\prod i^{n_i}\right)}
\]</span> <span class="math inline">\(k\)</span> 不动置换类 <span
class="math inline">\(Z_k\)</span>，其为一个子群</p>
<p>等价类：元素的等价关系指 <span class="math inline">\(G\)</span>
中存在置换能使两元素互换；含 <span class="math inline">\(k\)</span>
的等价类称为 含 <span class="math inline">\(k\)</span> 的轨道 <span
class="math inline">\(E_k\)</span></p>
<p>Lagrange 定理：<span class="math inline">\(|E_k||Z_k|=G\)</span></p>
<h3 id="burnside-引理">Burnside 引理</h3>
<p>置换群 <span class="math inline">\(G\)</span> 将 <span
class="math inline">\([1,n]\)</span> 划分为不同等价类的个数为</p>
<p><span class="math display">\[
\frac{1}{|G|}[c_1(P_1)+c_2(P_2)+\cdots+c_1(P_g)]
\]</span> 其中 <span class="math inline">\(c_1(P_i)\)</span> 为 <span
class="math inline">\(P_i\)</span> 作用下，不动点（长度为 1
的循环）的个数</p>
<h3 id="polya-定理">Polya 定理</h3>
<p>将置换群 <span class="math inline">\(\overline G\)</span> 下的 <span
class="math inline">\([1,n]\)</span> 用 <span
class="math inline">\(m\)</span> 种颜色涂色，方案数为</p>
<p><span class="math display">\[
\frac{1}{\left|\overline G\right|}\left[m^{c(\overline
P_1)}+m^{c(\overline P_2)}+\cdots+m^{c(\overline P_\overline g)}\right]
\]</span> 其中 <span class="math inline">\(c\left(\overline
P_i\right)\)</span> 是置换的循环节数</p>
<h3 id="母函数形式的-polya-定理">母函数形式的 Polya 定理</h3>
<p>设同一种颜色使用 <span class="math inline">\(k\)</span> 次，有 <span
class="math display">\[
P(G)=\frac{1}{|G|}\sum_{i=1}^g\prod_{k=1}^n\left(
x_1^k+x_2^k+\cdots+x_m^k
\right)^{c_k(\overline P_i)}
\]</span></p>
<h2 id="第五章">第五章</h2>
<h3 id="拉丁方">拉丁方</h3>
<p><span class="math inline">\(1\sim n\)</span> 构成的 <span
class="math inline">\(n\)</span> 阶方阵中，每行（每列）中 <span
class="math inline">\(n\)</span> 个元素都只能出现一次</p>
<p>正交拉丁方：设 <span class="math inline">\(A_{n\times
n}\)</span>，<span class="math inline">\(B_{n\times n}\)</span>，是两个
<span class="math inline">\(n\)</span> 阶拉丁方，<span
class="math inline">\(C_{ij}=(A_{ij}, B_{ij})\)</span> 若 <span
class="math inline">\(C\)</span> 中的所有数偶互不相同，则 <span
class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span> 正交</p>
<p>若存在 <span class="math inline">\(r\)</span> 个 <span
class="math inline">\(n\)</span> 阶正交拉丁方，则 <span
class="math inline">\(r&lt; n\)</span></p>
<h3 id="galois-域">Galois 域</h3>
<p>域：加法交换群，除去加法幺元成乘法交换群，有分配律</p>
<p>若 <span class="math inline">\(p\)</span> 是素数，<span
class="math inline">\(\{0,1,2,\cdots,p-1\}\)</span> 在 <span
class="math inline">\(\mod p\)</span> 意义下 <span
class="math inline">\(+\)</span>，<span
class="math inline">\(\times\)</span> 成伽罗瓦域 <span
class="math inline">\(GF(p)\)</span></p>
<p><span class="math inline">\(GF(p)\)</span> 上的多项式 <span
class="math inline">\(GF[p,x]\)</span></p>
<p>若 <span class="math inline">\(p(x)\in GF[p,x]\)</span>
不可表示为两个多项式的积，则称其不可化约</p>
<p>设 <span class="math inline">\(m(x)\)</span> 是 <span
class="math inline">\(GF[p,x]\)</span> 上不可约 <span
class="math inline">\(n\)</span> 次多项式，则可将 <span
class="math inline">\(GF[p,x]\)</span> 划分为模 <span
class="math inline">\(m(x)\)</span> 同余类 <span
class="math inline">\(GF[p,m(x)]\)</span>，其元素构成域 <span
class="math inline">\(GF(p^n)\)</span></p>
<h3 id="正交拉丁方构造">正交拉丁方构造</h3>
<p>若 <span class="math inline">\(n=p^m\)</span>，则存在 <span
class="math inline">\(n-1\)</span> 个正交拉丁方：</p>
<blockquote>
<p>设 <span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span> 是
<span class="math inline">\(GF(p^m)\)</span> 的 <span
class="math inline">\(n\)</span> 个不同元素，其中 <span
class="math inline">\(\alpha_n=0\)</span></p>
<p>构造方阵序列 <span class="math inline">\(A_{n\times
n}^{(k)}\)</span>，其中 <span
class="math inline">\(a_{ij}^{(k)}=\alpha_k\cdot
\alpha_i+\alpha_j\)</span></p>
</blockquote>
<p>若 <span class="math inline">\(n=p_1^{m_1}p_2^{m_2}\cdots
p_k^{m_k}\)</span>，则存在 <span
class="math inline">\(\min\{p_1^{m_1},p_2^{m_2},\cdots
,p_k^{m_k}\}-1\)</span> 个正交拉丁方</p>
<h3 id="均衡不完全区组设计">均衡不完全区组设计</h3>
<p><span class="math inline">\(BIBD(b,v,r,k,\lambda)\)</span></p>
<p><span class="math inline">\(X=\{x_1,x_2,\cdots,x_v\}\)</span>，<span
class="math inline">\(B=\{B_1,B_2,\cdots,B_b\}\)</span>，<span
class="math inline">\(B_i\subset X\)</span>，<span
class="math inline">\(|B_i|=k\)</span></p>
<p><span class="math inline">\(X\)</span> 的任一元素正好在 <span
class="math inline">\(r\)</span> 个子集中出现</p>
<p><span class="math inline">\(X\)</span> 的任意一对元素正好在 <span
class="math inline">\(\lambda\)</span> 个子集出现</p>
<p>与某元同组的总元次 <span
class="math inline">\(r(k-1)=\lambda(v-1)\)</span></p>
<p>所有元素总元次 <span class="math inline">\(vr=bk\)</span></p>
<p>有 <span class="math inline">\(b\ge v\)</span></p>
<p>区组矩阵： <span class="math display">\[
a_{ij}=\begin{cases}
1 &amp;,\ x_i\in B_j\\
0 &amp;,\ x_i \notin B_j
\end{cases}
\]</span> 对于 BIBD 设计，<span class="math inline">\(AA^{\mathrm
T}=(r-\lambda)I+\lambda J\)</span>，其中 <span
class="math inline">\(J\)</span> 是全 1 矩阵</p>
<h3 id="对称均衡不完全区组设计">对称均衡不完全区组设计</h3>
<p><span class="math inline">\(b=v\)</span></p>
<p><span class="math inline">\(k=r\)</span></p>
<p>任意两组均有 <span class="math inline">\(\lambda\)</span>
个共同元素</p>
<h3 id="三连系">三连系</h3>
<p><span class="math inline">\(k=3\)</span> 的 BIBD 称为三连系</p>
<p><span class="math inline">\(\lambda = 1\)</span> 的三连系称为 Steiner
三连系，存在的充要条件 <span class="math inline">\(v\equiv 1\mod 6 \vee
v\equiv 3\mod 6\)</span></p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理背诵笔记</title>
    <url>/2022/02/27/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%83%8C%E8%AF%B5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文是西交折磨水课计组的复习背诵笔记，用的是王换招老师的课本。</p>
<h2 id="考试回忆">考试回忆</h2>
<p>都是 PPT 题型</p>
<ul>
<li>（10）填空：五空，八股；</li>
<li>（15）简答：三题，八股，考了总线控制啥的；</li>
<li>（15）指令系统设计：写出格式、算各寻址方式的范围；</li>
<li>（15）磁盘：大小、传输率计算等；</li>
<li>（15）存储器设计：字位扩展、画连接图；</li>
<li>（15）浮点运算：十分简单的加减；</li>
<li>（15）双总线 CPU：判断未标明模块是什么（是 <code>SigExt</code>），写
ADD 指令周期。</li>
</ul>
<h2 id="misc">Misc</h2>
<p>常用进制/幂次对照</p>
<p><span class="math inline">\(2^6=64=40H\)</span></p>
<p><span class="math inline">\(2^{8}=256=100H\)</span></p>
<p><span class="math inline">\(2^{10}=1024=400H\)</span></p>
<p><span class="math inline">\(2^{13}=8192=2000H\)</span></p>
<p>Mega <span class="math inline">\(10^6\sim2^{20}\)</span></p>
<p>数电</p>
<p>74LS138（3-8 译码器）：<span class="math inline">\(S_0\)</span>
为真，<span class="math inline">\(S_1\)</span> 与 <span
class="math inline">\(S_2\)</span> 为假时工作（可能有低输出）</p>
<p><img
src="/images/ComputerOrgCourse/2022-02-18-16-49-14-image.png" /></p>
<h2 id="反向开悟">反向开悟</h2>
<p>硬件：组成计算机的各种实际装置；软件：各类特殊功能的程序和相关数据（相互依存，逻辑上等价、协同发展）</p>
<p>层次结构：每层的结构：广义语言、解释器、作用对象</p>
<p>子学科</p>
<ul>
<li>系统结构：主要研究计算机系统中软件和硬件的功能分配，以及确定软件和硬件的界面（现代计算机的发展主要是体系结构的变革）</li>
<li>组成：指计算机内部的逻辑组成和逻辑实现，各部件间的连接、通信、控制方式，以及信息的流动方式</li>
<li>实现：是对计算机组成的物理实现。研究各部件的物理结构、机器制造技术和工艺等</li>
</ul>
<p>计算机分类：（信息表现形式和处理方式）数/模/混；（用途）专用/通用；（配置）巨/大中/小/微/工作站/服务器</p>
<p>冯诺伊曼存储程序计算机：运算器、控制器、存储器、输入设备和输出设备</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220225170126397.png"
alt="image-20220225170126397" />
<figcaption aria-hidden="true">image-20220225170126397</figcaption>
</figure>
<p>总线结构：片内总线、系统总线等</p>
<p>存储器：主存储器是计算机的主要工作存储器，存放正在运行的程序和数据；主存包括存储体、各种逻辑部件及控制电路等；存储单元（具有特定存储地址的存储单位）；存储元</p>
<p>字长：CPU 能同时处理的最大数据位数（数据通路宽度，寄存器位数）</p>
<h2 id="isa">ISA</h2>
<p>指令系统是指一台计算机所具有的全部机器指令的集合，它反映了该机所拥有的基本功能；机器语言；软硬件界面；指令系统的逻辑实现</p>
<p>RISC 特点：长度固定、LW SW 访存、GPR 多、流水线、硬布线控制</p>
<p>设计原则：完备性、规整性、高效性、兼容性</p>
<p>数据类型（应用或软件处理的数据结构）；数据表示（硬件能够直接识别，指令能直接操作的数据类型）；操作数（指令中的数据：地址、数字、字符、逻辑数）</p>
<p>地址空间（统一编址/单独编址）（按字编址/按字节编址）</p>
<p>大端（高字节低地址）（符号位永远最低）</p>
<p>小端（低字节低地址）（强转不换位）</p>
<p>指令类型：数据传送指令；数据运算指令；程序控制指令；输入输出指令；其他指令</p>
<p>CPU 结构：堆栈结构；累加器结构；通用寄存器 RS 型；通用寄存器 RR
型</p>
<p>地址码个数：（三二一零）地址指令</p>
<p>操作码扩展技术：当采用等长指令字格式，且多种地址码结构混合使用时，可利用地址码个数较少的指令空出的地址码字段，来增加操作码的位数</p>
<p>寻址方式（实际地址 <code>EA</code>）</p>
<ul>
<li><p>指令寻址方式</p>
<ul>
<li><p>顺序指令寻址（<code>PC=(PC)+1</code>）</p></li>
<li><p>跳跃指令寻址（存储器寻址）</p></li>
</ul></li>
<li><p>数据寻址方式</p>
<ul>
<li><p>基本寻址方式（立即寻址、寄存器寻址、存储器寻址、堆栈寻址）</p>
<ul>
<li>存储器寻址：直接 <code>A</code>、间接 <code>(A)</code>、寄存器间接
<code>(R)</code>、偏移（相对 <code>(PC)+A</code>/基址
<code>(Rb)+A</code>/变址 <code>A+(Rx)</code>）、段
<code>(DS)&lt;&lt;4+(Rx)+A</code></li>
</ul></li>
<li><p>复合寻址方式（变址间接、间接变址等）</p></li>
</ul></li>
</ul>
<p>程序定位方式：直接定位方式、静态定位方式、动态定位方式</p>
<hr />
<h2 id="存储器">存储器</h2>
<p>按作用分类：内部存储器、外部存储器、控制存储器</p>
<p>按存储介质分类：半导体、磁表面、光盘</p>
<p>按存取方式分类：随机存取、只读、顺序存取（磁带）、直接存取（磁盘）、相联</p>
<p>按工艺分类：双极型、MOS 型</p>
<p>按可保存性分类：电易失型、非电易失型</p>
<p>RAM 的分类：SRAM; DRAM; NVRAM (SRAM+EEPROM)</p>
<p>层次原则：包含性、一致性</p>
<h3 id="ramrom">RAM/ROM</h3>
<p>地址译码：</p>
<ul>
<li><p>线选法 <span class="math inline">\(n\)</span>
位地址译码线与驱动数 <span class="math inline">\(2^n\)</span></p></li>
<li><p>重合法（双译码）<span class="math inline">\(n\)</span>
位地址译码线与驱动数 <span
class="math inline">\(2^{n/2+1}\)</span></p></li>
</ul>
<p>存取时间：一次存储器操作到完成的时间</p>
<p>存取周期：连续两次独立操作的最小间隔</p>
<p>存储器带宽：存取周期的倒数</p>
<p>引端名：电气引脚、逻辑引脚（数据线 <span
class="math inline">\(D_i\)</span>、地址线 <span
class="math inline">\(A_i\)</span>、控制线(读/写控制 <span
class="math inline">\(\overline{WE}\)</span>、片选控制 <span
class="math inline">\(\overline{CS}\)</span>)）</p>
<p>SRAM 8 管（4 Latch；4 I/O 两高两低）</p>
<p>DRAM 3/1 管（<span class="math inline">\(C_g\)</span>
电容状态），测位线电流，再生放大器；行列地址分时输入（<span
class="math inline">\(\overline{RAS}\)</span>（兼任片选）、<span
class="math inline">\(\overline{CAS}\)</span>）</p>
<p>DRAM 刷新</p>
<ul>
<li><p>集中式刷新：每个最大刷新间隔停下来逐行干一次</p></li>
<li><p>分散式刷新：每个读写周期刷一行</p></li>
<li><p>异步式刷新：分散每行的刷新</p></li>
</ul>
<p>DRAM 类型</p>
<ul>
<li><p>FPM DRAM（Fast Page Mode）快速页面模式：后续行地址省略</p></li>
<li><p>EDO DRAM（Extended Data
Out）扩展数据输出：地址数据部分并行</p></li>
<li><p>SDRAM（Synchronous）：与时钟同步</p></li>
<li><p>DDR SDRAM：上下沿都搞</p></li>
</ul>
<p>DRAM 控制器（DRAMC）</p>
<ul>
<li><p>刷新地址计数器</p></li>
<li><p>地址多路选择器：选通行、列、刷新地址</p></li>
<li><p>刷新定时器</p></li>
<li><p>仲裁电路（仲裁访存、刷新）</p></li>
<li><p>定时发生器（<span
class="math inline">\(\overline{RAS}\)</span>，<span
class="math inline">\(\overline{CAS}\)</span>，<span
class="math inline">\(\overline{WE}\)</span>）</p></li>
</ul>
<p>ROM</p>
<ul>
<li><p>MROM（Mask ROM）：造的时候就写好了</p></li>
<li><p>PROM（Programmable）：溶丝式/反向二极管式</p></li>
<li><p>EPROM（Erasable）：浮动栅极雪崩注入式
MOS（FAMOS），擦除需要特殊手段（紫外）</p></li>
<li><p>EEPROM（Electrically Erasable）：浮动栅极上有控制栅</p></li>
<li><p>Flash：和 EEPROM
类似，但浮栅的绝缘层更薄，快，耐损耗性差</p></li>
</ul>
<p>容量扩展技术</p>
<ul>
<li><p>位扩展：总片数=字长/片字长；横向排列</p></li>
<li><p>字扩展：总片数=字数/片字数（加片选译码器）；垂直排列</p></li>
</ul>
<p>8086 内存接口：地址总线 20 位，数据总线 16 位，<span
class="math inline">\(\overline{BHE}\)</span> 信号和 <span
class="math inline">\(A_0\)</span> 决定高低字节；<span
class="math inline">\(\overline{MREQ}\)</span>（Memory request）</p>
<h3 id="cache">Cache</h3>
<p>相连存储器</p>
<ul>
<li>存储元是一个 D 触发器；未被 M 屏蔽时存储位与检索位 D
同或（屏蔽高阻）得匹配标志 P；字选线 S 控制数据位 Q 和写</li>
<li>按内容查找：检索/屏蔽寄存器-存储体-匹配寄存器-优先排队电路-存储体-数据输出</li>
<li>按地址查找：屏蔽码全零，输出 AE 低电平</li>
</ul>
<p>Cache</p>
<ul>
<li><p>命中率 <span
class="math inline">\(H=N_1/(N_1+N_2)\)</span></p></li>
<li><p>失效率 <span class="math inline">\(F=1-H\)</span></p></li>
<li><p>平均访存时间 <span
class="math inline">\(T_a=HT_c+(1-H)T_m\)</span></p></li>
<li><p>加速比 <span class="math inline">\(S_p=T_m/T_a\)</span></p></li>
<li><p>访问效率 <span class="math inline">\(e=T_c/T_a\)</span></p></li>
</ul>
<p>区号 E；组号 G；组内块号 B；（块内地址 W）</p>
<p>全相连：全映射；直接相联：单射；组相连：块分组组内全相联</p>
<p>替换算法：RAND，FIFO，LRU，LFU（最不经常使用）</p>
<p>命中写回一致性：写直达法，写回法（替换时写，简单写回/标志位写回）</p>
<p>不命中写回一致性：不按写分配（写时不取），按写分配（写时取）</p>
<h3 id="辅助存储器">辅助存储器</h3>
<p>软磁磁头、硬磁介质</p>
<p>编码方法</p>
<ul>
<li><p>归零（RZ）：正负0</p></li>
<li><p>不归零（NRZ）：正负，变化时反向</p></li>
<li><p>不归零 1（NRZ1）：翻转沿为 1</p></li>
<li><p>调相（PM）：周期中心点上跳为一，下跳为零，连续则在周期交界翻转</p></li>
<li><p>调频（FM）：交界处翻转，写一中心点翻</p></li>
<li><p>改进调频（MFM）：写一中心点翻，写零交界处翻</p></li>
</ul>
<p><img
src="/images/ComputerOrgCourse/2022-02-18-20-37-29-image.png" /></p>
<p>编码效率（密度与翻转次数之比）：FM/PM 0.5，其他 1</p>
<p>自同步：RZ/PM/FM/NFM</p>
<p>每张盘片上下两面，一般最上最下不用；</p>
<p>磁道（磁头径向运动维+盘片维）；地址：柱面、盘面、扇区</p>
<p>硬分区/软分区（0索引）</p>
<p>不定长记录格式：数据块大小可变</p>
<p>格式化磁盘容量 = 硬盘个数x磁盘记录面数x磁道数x每道扇区数x扇区容量</p>
<p>平均寻址时间 = 平均寻道时间+平均等待时间</p>
<p>内部数据传输率 = 磁道容量x转速；外部数据传输率：总线和缓冲区速率</p>
<hr />
<h2 id="总线和-io">总线和 IO</h2>
<h3 id="总线">总线</h3>
<p>系统总线：计算机单机系统内部各大部件间信息传输的公共通路</p>
<p>通信总线：计算机系统间或计算机与其他系统间的信息通路</p>
<p>按物理位置分：板级总线、板间总线</p>
<p>按信息分：数据总线、地址总线、控制总线</p>
<p>按传输方式分：串、并</p>
<p>总线控制：集中式、分布式</p>
<p>总线主模块、从模块</p>
<p>仲裁：链式查询、计数器定时查询、独立请求</p>
<p>链式查询：固定优先级优先链；三根信号线 BusRequest BusGrant
BusBusy；BG 上游可掐断</p>
<p>计数器定时查询：地址计数，发出去地址匹配的模块可发</p>
<p>独立请求：每个模块独立 BR BG，控制器内部排队</p>
<p>一次总线操作：申请分配；寻址；传送；结束</p>
<p>总线周期：一次总线传送的时间（地址+数据）；BURST（一次地址多次数据）</p>
<p>总线通信方式：</p>
<ul>
<li><p>同步：公共时钟信号一致</p></li>
<li><p>异步：应答建立连接，周期可变</p>
<ul>
<li><p>不互锁：发一段时间关，不管收</p></li>
<li><p>半互锁：主模块需 ACK，从不需</p></li>
<li><p>全互锁：均需 ACK</p></li>
</ul></li>
<li><p>半同步：周期以快速为基础，对慢速部件加等待线</p></li>
<li><p>分离：Datagram，发的时候要发自己地址，准备好了再回</p></li>
</ul>
<p>双总线结构：以 CPU 为中心（IO+存储）/以存储器为中心（系统+存储）</p>
<p>三总线结构：CPU 中心加 DMA 总线</p>
<p>总线特性：机械特性、电气特性、功能特性、时序特性</p>
<p>总线性能指标：宽度、频率、带宽、控制方式、通信方式、信号线数、负载能力、扩展能力</p>
<h3 id="io">IO</h3>
<p>编址：统一编址（访存即可）；独立编址（IO 指令）</p>
<p>设备分类：人机交互设备、信息驻留设备、机机通信设备</p>
<h4 id="键盘">键盘</h4>
<p>无编码键盘：扫描检查有无按键，程序查表编码</p>
<p>编码键盘：扫描检查有无按键，按键自动编码</p>
<p><img
src="/images/ComputerOrgCourse/2022-02-18-21-36-20-image.png" /></p>
<h4 id="显示器">显示器</h4>
<p>字符、图形、图像显示器</p>
<p>CRT：光栅扫描、随机扫描（彩色 CRT 有三个阴极管）</p>
<p>刷新存储器 VRAM</p>
<p>字符显示器</p>
<ul>
<li><p>VRAM 地址 = 字符所在行号x一行字符数+列号</p></li>
<li><p>字符发生器 ROM</p></li>
<li><p>点振荡器（点时钟），点计数器（字符时钟），字计数器（行时钟），行计数器（排时钟），排计数器</p></li>
</ul>
<p><img
src="/images/ComputerOrgCourse/2022-02-18-21-50-43-image.png" /></p>
<h4 id="打印机">打印机</h4>
<p>和图形显示器一样</p>
<h3 id="io-接口">IO 接口</h3>
<p>数据缓冲、串并转化、电气转换、控制、查询、寻址</p>
<p>组成：数据缓冲寄存器
DBR、设备选择电路、控制逻辑电路、设备状态标记、命令寄存器和命令译码器</p>
<p>同步异步；穿行并行</p>
<p>控制方式</p>
<ul>
<li><p>程序查询（轮询）</p></li>
<li><p>中断：中断请求触发器 INTR，中断屏蔽触发器 MASK；中断允许触发器
INTA</p>
<ul>
<li><p>中断判优：串行排队、并行排队</p></li>
<li><p>中断响应：关中断、保护断点、获得入口（软件查询、硬件向量）</p></li>
<li><p>中断服务：保护现场、中断处理、恢复现场</p></li>
<li><p>中断返回</p>
<p>中断嵌套：服务时开中断，优先级/屏蔽字（某中断可以屏蔽其他哪些）</p></li>
</ul></li>
<li><p>DMA：预处理、传送、后处理</p>
<ul>
<li><p>停止 CPU 访存；周期窃取；交替访存</p></li>
<li><p>选择型（并总线）、多路型（串优先）</p></li>
</ul></li>
<li><p>I/O 通道</p></li>
<li><p>I/O 处理机</p></li>
</ul>
<hr />
<h2 id="数据表示与数据运算">数据表示与数据运算</h2>
<p>字符 ASCII，低 7 位，最高位恒为零/校验/扩展</p>
<p>汉字国标码/区位码</p>
<p>十进制 BCD：有权 8421；无权 余 3；自补 2421；循环 格雷码</p>
<p>定点小数（符号位后小数点）</p>
<h3 id="数值数据表示">数值数据表示</h3>
<p><span class="math inline">\(X\)</span> 为真值；<span
class="math inline">\(M\)</span> 为最大值，定点整数为 <span
class="math inline">\(2^n\)</span>，定点小数为 <span
class="math inline">\(1\)</span></p>
<p>原码（仅设符号位）</p>
<p><span class="math display">\[
[X]_{原}=\begin{cases}
X &amp; 0 \le X &lt; M \\
M-X &amp; -M &lt; X \le 0
\end{cases}
\]</span></p>
<p>补码（负则反码加一）</p>
<p><span class="math display">\[
[X]_{补}=\begin{cases}
X &amp; 0 \le X &lt; M \\
2M+X \mod 2M &amp; -M \le X &lt; 0
\end{cases}
\]</span></p>
<p>变形补码（两位符号位，特性与补码一致，可判溢出）</p>
<p>反码（全反，最高符号位，模是全一），符号位参与运算</p>
<p>移码（符号位相反的补码，便于比较，用于浮点指数）</p>
<p><span class="math display">\[
\begin{aligned}
    [X]_{移}=2^n+X &amp; &amp; -2^k\le X&lt;2^k
\end{aligned}
\]</span></p>
<h3 id="定点运算">定点运算</h3>
<p>全加器 <span class="math inline">\(X_i\)</span>, <span
class="math inline">\(Y_i\)</span>，Carry <span
class="math inline">\(C_i, C_{i+i}\)</span>，结果 <span
class="math inline">\(F_i = X_i \oplus Y_i \oplus C_i\)</span>，<span
class="math inline">\(C_{i+1}=X_iY_i+(X_i\oplus Y_i)C_i\)</span></p>
<p>加法溢出：同号相加变号；最高数值位和符号位进位不同；变形补码符号位不同</p>
<p>逻辑移位：补零；循环移位：补丢失数；算术移位：符号位不变，反码补
1</p>
<p>舍入：截尾；末尾置 1（或移出有一则置）；0 舍 1 入</p>
<p>桶形移位器：32 选一</p>
<h4 id="加法器">加法器</h4>
<p>行波进位加法器：全加器串接</p>
<p>进位生成函数 <span class="math inline">\(g_i=X_iY_i\)</span></p>
<p>进位传递函数 <span class="math inline">\(p_i=X_i\oplus
Y_i\)</span></p>
<p>进位 <span class="math inline">\(C_{i+1}=g_i+p_iC_i\)</span></p>
<p>先行进位表达式</p>
<p><span class="math display">\[
\begin{cases}
C_1=g_0+p_0C_0 \\
C_2=g_1+p_1g_0+p_1p_0C_0 \\
C_3=g_2+p_2g_1+p_2p_1g_0+p_2p_1p_0C_0 \\
C_4=g_3+p_3g_2+p_2g_1+p_3p_2p_1g_0+p_3p_2p_1p_0C_0
\end{cases}
\]</span></p>
<p>先行进位（CLA, Carry Look Ahead）</p>
<p>四位先行加法器：进位生成传递部件、CLA 部件、四位求和部件</p>
<p>成组先行——级连部件：组间串行进位</p>
<p>多级先行进位：<span class="math inline">\(C_{n+4}\)</span>
由组间产生</p>
<p>小组进位生成函数 <span
class="math inline">\(G_i=g_{n+3}+p_{n+3}g_{n+2}+p_{n+3}p_{n+2}g_{n+1}+p_{n+3}p_{n+2}p_{n+1}g_n\)</span></p>
<p>小组进位传递函数 <span
class="math inline">\(P_i=p_{n+3}p_{n+2}p_{n+1}p_n\)</span></p>
<p>成组先行进位部件（BCLA, Block Carry Look Ahead）</p>
<p><span class="math display">\[
\begin{cases}
C_{n+1}=g_n+p_nC_n \\
C_{n+2}=g_{n+1}+p_{n+1}g_n+p_{n+1}p_nC_n \\
C_{n+3}=g_{n+2}+p_{n+2}g_{n+1}+p_{n+2}p_{n+1}g_n+p_{n+2}p_{n+1}p_nC_n \\
G_{n}=g_{n+3}+p_{n+3}g_{n+2}+p_{n+2}g_{n+1}+p_{n+3}p_{n+2}p_{n+1}g_n+p_{n+3}p_{n+2}p_{n+1}p_ng_n
\\
P_n=p_{n+3}p_{n+2}p_{n+1}p_n
\end{cases}
\]</span></p>
<p>4 位 BCLA 的 <span class="math inline">\(G_n\)</span>，<span
class="math inline">\(P_n\)</span> 输出给 4 位 CLA 输出进位 <span
class="math inline">\(C_{4n}\)</span></p>
<p>二级先行——级连进位逻辑：大组串行进位</p>
<p>三级先行进位 <span class="math inline">\(G_n^*\)</span>，<span
class="math inline">\(P_n^*\)</span></p>
<p>74181：4 位算术逻辑单元，有 CLA，BCLA 功能，可输出小组进位函数 <span
class="math inline">\(P\)</span>，<span
class="math inline">\(G\)</span>，组内进位不输出，输出求和信号</p>
<p>74182：4 位成组先行进位部件</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221111744348.png"
alt="image-20220221111744348" />
<figcaption aria-hidden="true">image-20220221111744348</figcaption>
</figure>
<p>进位延迟时间：设与非门延迟 <span
class="math inline">\(t_y\)</span>，行波加法器 <span
class="math inline">\(2nt_y\)</span>；假设与或非门延迟 <span
class="math inline">\(1.5t_y\)</span>，先行进位 <span
class="math inline">\(2.5t_y\)</span>，二级先行级连 <span
class="math inline">\(10t_y\)</span></p>
<h4 id="原码一位乘">原码一位乘</h4>
<p>设 <span class="math inline">\(X_s\)</span>，<span
class="math inline">\(Y_s\)</span> 为符号位，<span
class="math inline">\(X^*\)</span>，<span
class="math inline">\(Y^*\)</span> 为绝对值，<span
class="math inline">\(n\)</span> 为非符号位位数</p>
<p><span class="math display">\[
P^*=\frac{1}{2}\left(
    X^*Y_1+\frac{1}{2}\left(X^*Y_2+\frac{1}{2}(\cdots)\right)
\right)
\]</span></p>
<p>结果是 <span class="math inline">\(2n\)</span>
位，乘数右移时左侧容纳部分积，部分积带符号位防溢出</p>
<p>例：<span class="math inline">\(n=4\)</span>；<span
class="math inline">\(X=0.1101\)</span>，<span
class="math inline">\(Y=-0.1011\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Multiplicand</span><br><span class="line">    0.1 1 0 1</span><br><span class="line">    Partial Product    Multiplicant</span><br><span class="line">    0.0 0 0 0          0.1 0 1 1</span><br><span class="line">+   0.1 1 0 1</span><br><span class="line">----------------------------------</span><br><span class="line">    0.1 1 0 1</span><br><span class="line">&gt;   0.0 1 1 0          1 0.1 0 1</span><br><span class="line">+   0.1 1 0 1</span><br><span class="line">----------------------------------</span><br><span class="line">    1.0 0 1 1</span><br><span class="line">&gt;   0.1 0 0 1          1 1 0.1 0</span><br><span class="line">&gt;   0.0 1 0 0          1 1 1 0.1</span><br><span class="line">+   0.1 1 0 1</span><br><span class="line">----------------------------------</span><br><span class="line">    1.0 0 0 1</span><br><span class="line">&gt;   0.1 0 0 0          1 1 1 1 0</span><br><span class="line">    Result</span><br><span class="line">    0.10001111</span><br></pre></td></tr></table></figure>
<h4 id="补码一位乘法比较法">补码一位乘法（比较法）</h4>
<p>设 <span class="math inline">\([Y]_{补}=Y_0.Y_1Y_2\cdots
Y_n\)</span></p>
<p><span class="math display">\[
Y=-Y_0+\sum_{i=1}^{n}2^{-i}Y_i=\sum_{i=0}^n2^{-i}(Y_{i+1}-Y_i)
\]</span></p>
<p><span class="math inline">\([XY]_{补}=[X]_{补}Y\)</span></p>
<p>部分积双符号位参加运算，乘数添一位零，最低两位判断位，加法系数 <span
class="math inline">\(Y_{n+1}-Y_n\)</span></p>
<p>最后一次不移位，最低两位舍去，总移位次数为 <span
class="math inline">\(n+1\)</span>，加法次数 <span
class="math inline">\(n\)</span></p>
<p>例：<span class="math inline">\(X=0.1101\)</span>，<span
class="math inline">\(Y=-0.1011\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Multiplicand</span><br><span class="line">      0.1 1 0 1</span><br><span class="line">    Negative</span><br><span class="line">      1.0 0 1 1</span><br><span class="line">    Partial Product    Multiplicand Appendix</span><br><span class="line">    0 0.0 0 0 0        1.0 1 0 1    0</span><br><span class="line">-X  1 1.0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1.0 0 1 1</span><br><span class="line">&gt;   1 1.1 0 0 1        1 1.0 1 0    1</span><br><span class="line">+X  0 0.1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0.0 1 1 0</span><br><span class="line">&gt;   0 0.0 0 1 1        0 1 1.0 1    0</span><br><span class="line">-X  1 1.0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1.0 1 1 0</span><br><span class="line">&gt;   1 1.1 0 1 1        0 0 1 1.0    1</span><br><span class="line">+X  0 0.1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0.1 0 0 0</span><br><span class="line">&gt;   0 0.0 1 0 0        0 0 0 1 1.   0</span><br><span class="line">-X  1 1.0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1.0 1 1 1        0 0 0 1 0.   0</span><br><span class="line">    Result</span><br><span class="line">    1.01110001</span><br></pre></td></tr></table></figure>
<p>对于整数，附加位后为小数点，最后一步运算右移两位，左去除多余符号位</p>
<p>例：<span class="math inline">\(X=1101\)</span>，<span
class="math inline">\(Y=-1011\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Multiplicand</span><br><span class="line">      0 1 1 0 1</span><br><span class="line">    Negative</span><br><span class="line">      1 0 0 1 1</span><br><span class="line">    Partial Product    Multiplicand Appendix</span><br><span class="line">    0 0,0 0 0 0        1,0 1 0 1    0.</span><br><span class="line">-X  1 1,0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1,0 0 1 1</span><br><span class="line">&gt;   1 1,1 0 0 1        1 1,0 1 0    1.</span><br><span class="line">+X  0 0,1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0,0 1 1 0</span><br><span class="line">&gt;   0 0,0 0 1 1        0 1 1,0 1    0.</span><br><span class="line">-X  1 1,0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1,0 1 1 0</span><br><span class="line">&gt;   1 1,1 0 1 1        0 0 1 1,0    1.</span><br><span class="line">+X  0 0 1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0,1 0 0 0</span><br><span class="line">&gt;   0 0,0 1 0 0        0 0 0 1 1,   0.</span><br><span class="line">-X  1 1,0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1,0 1 1 1</span><br><span class="line">&gt;   1 1,1 0 1 1        1 0 0 0 1,   1.</span><br><span class="line">    Result</span><br><span class="line">    1,01110001</span><br></pre></td></tr></table></figure>
<h4 id="补码二位乘法比较法">补码二位乘法（比较法）</h4>
<p>由一位乘法可得部分积</p>
<p><span class="math display">\[
[Z_{i+2}]_{补}=2^{-2}([Z_i]_{补}+(Y_{n-i+1}+Y_{n-i}-2Y_{n-i-1})[X]_{补})
\]</span></p>
<p>部分积三位符号位，乘数增加一位附加位，乘数增加符号位至偶数位，低三位清零</p>
<p><span class="math inline">\(n\)</span> 为奇数时，乘数设一位符号位，做
<span class="math inline">\((n+1)/2\)</span>
次运算和移位，最后一次移一位</p>
<p><span class="math inline">\(n\)</span> 为偶数时，乘数设两位符号位，做
<span class="math inline">\(n/2 + 1\)</span> 次运算，<span
class="math inline">\(n/2\)</span> 次移位</p>
<p>例：<span class="math inline">\(X=0.1101\)</span>，<span
class="math inline">\(Y=-0.1011\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Multiplicand</span><br><span class="line">    0 0 0.1 1 0 1</span><br><span class="line">    2X</span><br><span class="line">    0 0 1.1 0 1 0</span><br><span class="line">    -X</span><br><span class="line">    1 1 1.0 0 1 1</span><br><span class="line">    -2X</span><br><span class="line">    1 1 0.0 1 1 0</span><br><span class="line">    Partial Product    Multiplicand Appendix</span><br><span class="line">    0 0 0.0 0 0 0      1 1.0 1 0 1  0</span><br><span class="line">+X  0 0 0.1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0 0.1 1 0 1</span><br><span class="line">&gt;2  0 0 0.0 0 1 1      0 1 1 1.0 1  0</span><br><span class="line">+X  0 0 0.1 1 0 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    0 0 1.0 0 0 0</span><br><span class="line">&gt;2  0 0 0.0 1 0 0      0 0 0 1 1 1. 0</span><br><span class="line">-X  1 1 1.0 0 1 1</span><br><span class="line">--------------------------------------------</span><br><span class="line">    1 1 1.0 1 1 1      0 0 0 1 0 0  0</span><br><span class="line">    Result</span><br><span class="line">    1.01110001</span><br></pre></td></tr></table></figure>
<h4
id="原码加减交替除法不恢复余数法">原码加减交替除法（不恢复余数法）</h4>
<p>恢复余数法：每步试减，若余数小于零则加除数恢复余数再继续</p>
<p>对于恢复余数，可以直接下一步加，即 <span
class="math inline">\(R_{i+1}=2(R_i-Y^*)+Y^*\)</span>；最后一步需要恢复余数，且余数不移位（共移位
<span class="math inline">\(n\)</span> 次）</p>
<p>例：<span class="math inline">\(X=-0.1011\)</span>，<span
class="math inline">\(Y=-0.1101\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Divisor</span><br><span class="line">    0.1 1 0 1</span><br><span class="line">    -Y</span><br><span class="line">    1.0 0 1 1</span><br><span class="line">    Remainder    Quotient</span><br><span class="line">    0.1 0 1 1    0.0 0 0 0</span><br><span class="line">-Y  1.0 0 1 1</span><br><span class="line">--------------------------</span><br><span class="line">    1.1 1 1 0</span><br><span class="line">&lt;   1.1 1 0 0    0.0 0 0 0</span><br><span class="line">+Y  0.1 1 0 1</span><br><span class="line">--------------------------</span><br><span class="line">    0.1 0 0 1</span><br><span class="line">&lt;   1.0 0 1 0    0.0 0 0 1</span><br><span class="line">-Y  1.0 0 1 1</span><br><span class="line">--------------------------</span><br><span class="line">    0.0 1 0 1</span><br><span class="line">&lt;   0.1 0 1 0    0.0 0 1 1</span><br><span class="line">-Y  1.0 0 1 1</span><br><span class="line">--------------------------</span><br><span class="line">    1.1 1 0 1</span><br><span class="line">&lt;   1.1 0 1 0    0.0 1 1 0</span><br><span class="line">+Y  0.1 1 0 1</span><br><span class="line">--------------------------</span><br><span class="line">    0.0 1 1 1</span><br><span class="line">    Result</span><br><span class="line">    0.1101 ... 0.0111e-4</span><br></pre></td></tr></table></figure>
<h3 id="浮点">浮点</h3>
<p><span class="math inline">\(N=MR^E\)</span>，<span
class="math inline">\(M\)</span> 为尾数，<span
class="math inline">\(E\)</span> 为阶码，<span
class="math inline">\(R\)</span> 为基底</p>
<p>阶码用移码表示</p>
<p>规格化：<span
class="math inline">\(1/2&lt;|M|&lt;1\)</span>，即尾数最高位是有效值</p>
<p>机器零：尾数为零，阶码为最负（移码零）</p>
<p>IEEE754：隐藏位是一，移码偏移常数是 <span
class="math inline">\(2^k-1\)</span>，符号位、阶码、尾数；单精度阶码 8
位，双精度 11 位</p>
<h4 id="加法">加法</h4>
<ol type="1">
<li>检测零</li>
<li>对阶：求阶差，小阶尾数右移对齐</li>
<li>尾数运算：两位符号位判溢出</li>
<li>规格化：溢出右规，非规格化左归</li>
<li>舍入：零舍一入</li>
<li>溢出判断：上溢出错，下溢表零</li>
</ol>
<h4 id="乘除">乘除</h4>
<ol type="1">
<li>检测零</li>
<li>阶码加减：移码需要修正偏置</li>
<li>尾数乘除</li>
<li>规格化</li>
<li>舍入</li>
<li>判溢出</li>
</ol>
<hr />
<h2 id="cpu">CPU</h2>
<p>五大功能：顺序控制、操作控制、时间控制、数据加工、中断控制</p>
<p>五个基本功能组件：算术逻辑单元、寄存器组、内部总线、中断系统、控制单元</p>
<p>数据通路：全部执行部件的集合</p>
<p>微操作：不可再分解的操作；微命令：执行微操作所需要的控制信号</p>
<p>中断系统</p>
<ul>
<li>允许中断 <code>EINT</code>，中断请求 <code>INTR_i</code></li>
<li>指令周期结束后响应中断</li>
<li>外部中断源：中断控制器；内部中断源</li>
<li>中断判优：软、硬件</li>
<li>中断响应</li>
<li>MIPS：出错地址 <code>EPC</code>，原因
<code>Cause</code>，中断服务由操作系统提供</li>
</ul>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221173310913.png"
alt="image-20220221173310913" />
<figcaption aria-hidden="true">image-20220221173310913</figcaption>
</figure>
<h3 id="单周期数据通路">单周期数据通路</h3>
<p>组成</p>
<ul>
<li>指令存储器 <code>IM</code></li>
<li>数据存储器 <code>DM</code></li>
<li>程序存储器 <code>PC</code></li>
<li>寄存器组 <code>RF</code></li>
<li>算术逻辑单元 <code>ALU</code></li>
<li>加法器（PC+4）</li>
</ul>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221170314064.png"
alt="image-20220221170314064" />
<figcaption aria-hidden="true">image-20220221170314064</figcaption>
</figure>
<h3 id="多周期数据通路">多周期数据通路</h3>
<p>分散互联：合并冗余单元（指令数据存储器，加法器和 ALU）；增加
<code>IR</code>，<code>MDR</code>，<code>A</code>，<code>B</code>，<code>ALUOut</code>
寄存器</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221171213386.png"
alt="image-20220221171213386" />
<figcaption aria-hidden="true">image-20220221171213386</figcaption>
</figure>
<p>单总线：增强符号扩展器的功能（<code>SigExt(IR[15-0])</code>、<code>SigExt(IR[15-0])&lt;&lt;2</code>、<code>4</code>、<code>IR[25-0]&lt;&lt;2</code>）</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221172036032.png"
alt="image-20220221172036032" />
<figcaption aria-hidden="true">image-20220221172036032</figcaption>
</figure>
<p>转移指令将 26 位地址左移两位与 <code>PC</code> 高四位拼接</p>
<p>取指令阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RTL                           Ctrl</span><br><span class="line"># Send addr</span><br><span class="line">MAR &lt;- (PC)                   PCOeH, PCOeL, MARWr</span><br><span class="line">A &lt;- (PC)                     Awr</span><br><span class="line"># Fetch inst</span><br><span class="line">IR &lt;- M[MAR]                  MemRd, MemOe, IRWr</span><br><span class="line"># Send PC offset</span><br><span class="line">B &lt;- 4                        ExtSel=10, ImmOeH, ImmOeL, BWr</span><br><span class="line"># Calc PC</span><br><span class="line">PC &lt;- PC + 4                  ALUOp=00, RegOe, PCWr</span><br><span class="line"># Decode</span><br><span class="line">A &lt;- (RF[IR[25-21]])          RegSel=00, RegOe, AWr</span><br></pre></td></tr></table></figure>
<p>ADD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RTL                           Ctrl</span><br><span class="line"># Rt read</span><br><span class="line">B &lt;- (RF[IR[20-16]])          RegSel=01, RegOe, BWr</span><br><span class="line"># Calc</span><br><span class="line">RF[IR[15-11]] &lt;- (A) + (B)    ALUOp=00, ALUOe, RegSel=02, RegWr</span><br></pre></td></tr></table></figure>
<p>LW</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RTL                           Ctrl</span><br><span class="line"># Imm Ext</span><br><span class="line">B &lt;- SigExt(IR[15-0])         ExtSel=00, ImmOeH, ImmOeL, BWr</span><br><span class="line"># Addr calc</span><br><span class="line">MAR &lt;- (A) + (B)              ALUOp=00, ALUOe, MARWr</span><br><span class="line"># Memory access</span><br><span class="line">MDR &lt;- M[MAR]                 MemRd, MemOe, MDRWr, MDRSrc=1</span><br><span class="line"># Regfile write</span><br><span class="line">RF[IR[20-16]] &lt;- (MDR)        MDROe, RegSel=01, RegWr</span><br></pre></td></tr></table></figure>
<p>双总线</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221195550882.png"
alt="image-20220221195550882" />
<figcaption aria-hidden="true">image-20220221195550882</figcaption>
</figure>
<p>三总线</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221200034443.png"
alt="image-20220221200034443" />
<figcaption aria-hidden="true">image-20220221200034443</figcaption>
</figure>
<h3 id="性能">性能</h3>
<p>指令的 CPI 按频度加权平均</p>
<h3 id="流水">流水</h3>
<p>部件冗余、数据冒险、控制冒险、吞吐率、加速比、效率</p>
<p>五级：FI、ID、EX、MA、WB</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221204113476.png"
alt="image-20220221204113476" />
<figcaption aria-hidden="true">image-20220221204113476</figcaption>
</figure>
<hr />
<h2 id="控制器">控制器</h2>
<p>作用：提供定时信号、提供控制信号、响应中断请求</p>
<p>组成：控制寄存器、译码器、时序信号产生器、CU</p>
<p>组合逻辑控制器，微程序控制器，混合设计</p>
<p>三级时序体制：主状态周期；节拍电位（多个传送操作）；节拍脉冲（同步控制信号）</p>
<p>控制方式：同步（时序信号触发状态转移）；异步（握手机制触发转移）</p>
<ul>
<li>同步控制方式：统一、不定长、中央局部</li>
<li>异步：二级时序（节拍、脉冲）</li>
<li>联合</li>
</ul>
<p>硬布线控制器 <span class="math inline">\(C_i=f(I_m, B_j, M_l, T_k,
P_n)\)</span>，是译码信号、机器状态、机器周期、节拍和脉冲的函数</p>
<p>门阵列控制器：用门阵列芯片实现</p>
<p>多周期同步控制单元：组合逻辑和状态寄存器
<code>SR</code>；异步：加一个 <code>Ready</code> 信号</p>
<h3 id="微程序">微程序</h3>
<p>微指令格式：微操作控制字段
<code>uOP</code>（能产生微命令）；顺序控制字段
<code>uAddr</code>（下一条控存地址）</p>
<figure>
<img src="/images/ComputerOrgCourse/image-20220221211255253.png"
alt="image-20220221211255253" />
<figcaption aria-hidden="true">image-20220221211255253</figcaption>
</figure>
<p>水平型微指令：一条微指令多个微命令；垂直型微指令：不多个微指令</p>
<p>编码方法</p>
<ul>
<li>直接编码（不译）</li>
<li>字段直接编码：互斥命令组织编码</li>
<li>字段间接编码：某些微命令要由其他字段解释</li>
<li>混合编码：直接编码和字段直接编码混合</li>
</ul>
<p>微地址形成方法</p>
<ul>
<li>直接表示：下一条</li>
<li>增量方式：CMAR
增加计数功能；分顺序微指令和转移型微指令（条件（转或顺序）、转移地址）</li>
<li>增量与下址字段相结合方式：对比增量方式没有顺序微指令</li>
<li>断定方式：非测试地址字段，测试条件字段（可以多路转移）</li>
</ul>
<p>微入口技术：解决如何进入相应微程序，“功能转移”，查表法、转移地址产生逻辑</p>
<p>微指令周期（微周期）：取，执行；串行：先取再执行；重叠：执行和取并行</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络背诵笔记</title>
    <url>/2022/02/27/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%83%8C%E8%AF%B5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本提纲是计算机网络课程的复习背诵，根据西交的考点截取了内容。这个课程使用
Tanenbaum, Andrew S. 的著名课本。</p>
<p>这次考的不难，居然没有 TCP 拥塞控制。</p>
<h2 id="开悟">开悟</h2>
<p>计算机网络是一组通过<strong>单一技术</strong>相互连接的<strong>自主计算机</strong>集合</p>
<p>分布式系统强调整体性</p>
<h3 id="分类">分类</h3>
<p><code>[Personal | Local | Metropolitan | Wide] Area Networks</code>、internetworks</p>
<p>按其他标准</p>
<p>子网：一组路由器和通信线路的集合，主要负责将数据包从源主机移动到目的主机</p>
<h3 id="分层模型">分层模型</h3>
<p>优点：各层独立，灵活性好，结构分离，易于实现维护，促进标准化</p>
<p>原则：根据功能需要，功能明确，利于标准，信息量少，层数合适</p>
<p>OSI 七层模型（主要概念：服务、接口、时序）</p>
<p>协议三要素：语法、语义、时序</p>
<table>
<thead>
<tr class="header">
<th>Unit exchanged</th>
<th>层</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>APDU</td>
<td>应用</td>
<td>HTTP, SMTP, RTP, DNS, TELNET, FTP, DNS</td>
</tr>
<tr class="even">
<td>PPDU</td>
<td>表示</td>
<td></td>
</tr>
<tr class="odd">
<td>SPDU</td>
<td>会话</td>
<td></td>
</tr>
<tr class="even">
<td>TPDU (Segment)</td>
<td>传输</td>
<td>TCP, UDP</td>
</tr>
<tr class="odd">
<td>Packet</td>
<td>网络</td>
<td>IP, ICMP, RIP, OSPF, BGP</td>
</tr>
<tr class="even">
<td>Frame</td>
<td>数据链路</td>
<td>PPP</td>
</tr>
<tr class="odd">
<td>Bit</td>
<td>物理</td>
<td></td>
</tr>
</tbody>
</table>
<p>TCP/IP 模型：应用层，传输层，互联网层（Host to network）（Link
layer）</p>
<p>会话层：管理应用程序间的会话；表示层：处理语法语义</p>
<h3 id="服务">服务</h3>
<p>有无连接，有无确认</p>
<table>
<thead>
<tr class="header">
<th>服务</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>可靠消息流</td>
<td>帧序列</td>
</tr>
<tr class="even">
<td>可靠字节流</td>
<td>远程登录</td>
</tr>
<tr class="odd">
<td>不可靠连接</td>
<td>数字语音</td>
</tr>
<tr class="even">
<td>不可靠数据报</td>
<td>垃圾邮件</td>
</tr>
<tr class="odd">
<td>确认数据报</td>
<td>挂号信</td>
</tr>
<tr class="even">
<td>请求-回复</td>
<td>数据库查询</td>
</tr>
</tbody>
</table>
<h3 id="standardization">Standardization</h3>
<table>
<thead>
<tr class="header">
<th>Body</th>
<th>Area</th>
<th>E.g.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ITU</td>
<td>Telecommunication</td>
<td>G.992 (ASDL), H.264</td>
</tr>
<tr class="even">
<td>IEEE</td>
<td>Communications</td>
<td>802.3, 802.11, 802.15 (PAN)</td>
</tr>
<tr class="odd">
<td>IETF</td>
<td>Internet</td>
<td>RFC 2616, RFC 1034/1035</td>
</tr>
<tr class="even">
<td>W3C</td>
<td>Web</td>
<td>HTML5</td>
</tr>
</tbody>
</table>
<h3 id="internet-architecture">Internet Architecture</h3>
<ul>
<li>POP: Point Of Presence；ISP 存点</li>
<li>IXP: internet exchange point；Internet 交换点</li>
<li>CMTS: cable modem termination system</li>
<li>DSLAM: access multiplexer</li>
</ul>
<figure>
<img src="/images/ComputerNetworkCourse/image-20220223102513412.png"
alt="image-20220223102513412" />
<figcaption aria-hidden="true">image-20220223102513412</figcaption>
</figure>
<hr />
<h2 id="物理层">物理层</h2>
<p>机械特性；电气特性；规程特性（同步、信号时序、应答关心、操作过程）；功能特性</p>
<h3 id="傅立叶分析">傅立叶分析</h3>
<p>假设周期是 8 个 Bit，8 次谐波足以复原信号</p>
<p>则 <span class="math inline">\(b\)</span> Bit/s 的第一个谐波频率为
<span class="math inline">\(b/8\)</span>
Hz，可发送的谐波次数是截止频率（电话线 3kHz）除以一次谐波频率</p>
<h3 id="nyquist-采样定理">Nyquist 采样定理</h3>
<p>波特率：符号一秒变换的次数 <span
class="math inline">\(B_r\)</span>；比特率 <span
class="math inline">\(s\)</span>（bps）；离散等级 <span
class="math inline">\(V\)</span> <span class="math display">\[
s=B_r\log_2 V
\]</span> 采样定理 <span class="math display">\[
\max{s} = 2B\log_2V
\]</span></p>
<p>其中 <span class="math inline">\(B\)</span> 为带宽</p>
<p>也就是说，带宽 <span class="math inline">\(B\)</span>
的信道最多做两倍频率采样来到达 <span class="math inline">\(2B\)</span>
的波特率</p>
<h3 id="shanon-定理">Shanon 定理</h3>
<p><span class="math display">\[
\text{Maximum Bit Rate} = B\log_2(1+S/N)
\]</span></p>
<p>其中 <span class="math inline">\(S/N\)</span> 是信噪比</p>
<p>dB: <span class="math inline">\(10\log_{10}(S/N)\)</span></p>
<h3 id="介质">介质</h3>
<p>引导型介质：磁，双绞线（S/U TP），同轴线，电力线，光纤（0.85um,
1.30um, 1.55um）</p>
<p>非引导型介质：电磁波，微波，红外，可见光</p>
<p>VLF，LF，MF 地面传播（AM）</p>
<p>HF、VHF、UHF 电离层反射（FM/TV）</p>
<p>卫星：LEO，MEO（GPS），GEO（L, S, C, Ku, Ka）（SHF、EHF）</p>
<p>小口径终端可使用地面 Hub 放大</p>
<h3 id="数字调制">数字调制</h3>
<p>比特（数据）与代表他们的信号之间的转换过程称为数字调制</p>
<p>Baseband、Passband</p>
<figure>
<img src="/images/ComputerNetworkCourse/2-20.png" alt="2-20" />
<figcaption aria-hidden="true">2-20</figcaption>
</figure>
<ul>
<li>T1/USB：NRZI</li>
<li>Ethernet：Manchester</li>
</ul>
<p>解决 NRZI 长串 0：4B/5B 码，扰频</p>
<p>解决直流分量：双极编码（1/-1 均为 1，用于平衡直流分量），8B/10B码</p>
<h3 id="通带传输">通带传输</h3>
<p>ASK 幅移键控</p>
<p>FSK 频移键控</p>
<p>PSK 相移键控：二进制相移键控 BPSK，正交相移键控 QPSK</p>
<p>QAM 正交调幅</p>
<figure>
<img src="/images/ComputerNetworkCourse/2-22.png" alt="2-22" />
<figcaption aria-hidden="true">2-22</figcaption>
</figure>
<h3 id="信道复用">信道复用</h3>
<p><strong>频分复用</strong> FDM</p>
<p>利用通带传输使多个用户共享信道</p>
<p>OFDM 正交频分复用：取消保护带，在所有子载波上调制</p>
<p><strong>波分复用</strong> WDM</p>
<p>（SONET）波长，光纤上极高频率的频分多路复用</p>
<p><strong>时分复用</strong> TDM</p>
<p>时间槽，保护时间</p>
<p>统计时分复用</p>
<p><strong>码分复用</strong> CDMA</p>
<p>Code Division Multiple Access，由 Walsh
码产生正交码片序列，每个比特分为 <span class="math inline">\(m\)</span>
个码片，每个站发送被分配的码片序列或其反码</p>
<p>所有站的码片序列两两正交，<span class="math inline">\(S\cdot
T=\dfrac{1}{m}\sum_{i=1}^mS_iT_i=0\)</span></p>
<figure>
<img src="/images/ComputerNetworkCourse/2-28.png" alt="2-28" />
<figcaption aria-hidden="true">2-28</figcaption>
</figure>
<h3 id="电话交换网">电话交换网</h3>
<p>Local loop; Trunks; Switching offices</p>
<p>LATA (Local Access and Transport Access), LEC, IXC</p>
<p>DSL: Cat3 UTP</p>
<p>ASDL (Asymmetric Digital Subscriber Lines) 256x4kHz Channels; 0-25
Voice</p>
<p>数字电话中使用脉冲编码调制 PCM，Pulse Code Modulation，每秒采集 8000
个样值，T1 载波每帧（125 <span
class="math inline">\(\mu\text{s}\)</span>）24 个信道（TDM），每信道 8
bit，一个帧标记位，共 193 bit，<span class="math inline">\((8\times 24 +
1)\times 8000 = 1.544\)</span> Mbps，信令控制 8 kbps</p>
<p>T2 = 4 T1，T3 = 7 T2，T4 = 6 T3</p>
<p>SONET（Synchronous Optical Network），每帧 <span
class="math inline">\(87+3\)</span> 列，<span
class="math inline">\(9\)</span> 行， <span
class="math inline">\(8\times810\times((87+3)\times 9)\times 8000 =
51.84\)</span> Mbps</p>
<p>有线电视网同轴搭接，同轴接到光纤节点；固话每家回环到 End Office</p>
<h3 id="交换">交换</h3>
<p>电路交换（Strowger 装置）：建立电路，传输数据，拆除电路</p>
<p>包交换（存储-转发）：报文交换（逻辑上完整），分组交换（数据报、虚电路），信元交换（固定长度的信息段）</p>
<figure>
<img src="/images/ComputerNetworkCourse/2-43.png" alt="2-43" />
<figcaption aria-hidden="true">2-43</figcaption>
</figure>
<p>发送时延、传播时延、转发时延</p>
<h3 id="蜂窝网络">蜂窝网络</h3>
<p>频率可跨蜂窝复用，并随着用户的移动而切换蜂窝</p>
<p>模拟语音 1G（AMPS），临近蜂窝不复用，832
个信道（Control/Paging/Access/Data），FDM，频分双工（FDD）</p>
<p>数字语音 2G（GSM），124 FDM，8 TDM，148 bit 数据帧</p>
<p>移动交换中心 MSC，归属位置寄存器 HLR，拜访位置寄存器 VLR，鉴权中心
HLR</p>
<p>数字语音数据 3G，CDMA（长伪随机序列），功率控制</p>
<p>4G，TD-LTE（TDD 时分双工）</p>
<p>5G，融合怪</p>
<hr />
<h2 id="数据链路层">数据链路层</h2>
<p>主要功能：物理地址；成帧（定界与同步）；差错控制；流量控制；信道访问控制</p>
<p>PPP：成帧，链路控制（启动、测试线路、协商参数）、协商网络层选项（没有差错流量控制）</p>
<p>上层服务：不可靠（无 ACK）无连接，可靠无连接，可靠连接</p>
<p>应答：最常采用正向（负向，双向）</p>
<h3 id="成帧">成帧</h3>
<p>原则：易区分，带宽小</p>
<ul>
<li>字节计数法</li>
<li>字节填充的标志字节法 FLAG，ESC</li>
<li>含位填充的分界标志法：使用 01111110 定界，连续 1 塞 0</li>
<li>物理层编码违例法：冗余编码使用</li>
</ul>
<h3 id="错误控制">错误控制</h3>
<h4 id="自动纠错">自动纠错</h4>
<ol type="1">
<li><p>Hamming codes</p></li>
<li><p>Binary convolutional codes</p></li>
<li><p>Reed-Solomon codes</p></li>
<li><p>Low-Density Parity Check codes</p></li>
</ol>
<p>汉明距离即异或值的 1 数量</p>
<p>纠错码 <span class="math inline">\(n=m+r\)</span>
位，对于一位错误纠错，<span class="math inline">\(m+r+1\le
2^r\)</span>（对于合法的 <span class="math inline">\(2^m\)</span>
个码字，距离 1 内的 <span class="math inline">\(n+1\)</span>
个码字都纠错至它）</p>
<h5 id="hamming-code">Hamming Code</h5>
<p>汉明码 index <span class="math inline">\([1,n]\)</span>，第 <span
class="math inline">\(2^k, k\ge 0\)</span> 位是二进制 index <span
class="math inline">\(k\)</span> 位为 1 的所有值（包括自己）的偶校验</p>
<p>纠错位置为所有校验结果拼接成的二进制串表示的
index（<code>...P8P4P2P1</code>）</p>
<h4 id="检错反馈重发">检错反馈重发</h4>
<ol type="1">
<li><p>Parity</p></li>
<li><p>Checksums</p></li>
<li><p>Cyclic Redundancy Checks</p></li>
</ol>
<h5 id="crc">CRC</h5>
<p><span class="math inline">\(r\)</span> 阶生成多项式 <span
class="math inline">\(G(x)\)</span>，向帧追加 <span
class="math inline">\(r\)</span> 位使得多项式能被 <span
class="math inline">\(G(x)\)</span> 模二除尽</p>
<h3 id="流量控制">流量控制</h3>
<h4 id="utopian">Utopian</h4>
<p>无错，理想信道，单工</p>
<p>链路层进什么出什么</p>
<h4 id="无错信道下的单工停等协议">无错信道下的单工停等协议</h4>
<p>收方有有限的速度和缓冲区，每收一包发送确认；</p>
<p>发方只有确认后才可发下一包。</p>
<h4 id="有错信道下的单工停等协议">有错信道下的单工停等协议</h4>
<p>采用正向应答、定时重传、循环序列号</p>
<h4 id="有错信道下的双工协议">有错信道下的双工协议</h4>
<p>Piggybacking：ACK 序列号在数据帧中附带</p>
<p>缺点：同时开始传送时，若超时计时器不合理，将会传送三次以上</p>
<p><code>ack_timeout</code> 用于 Piggyback 缺少反向流量的情况</p>
<h5 id="滑动窗口协议">滑动窗口协议</h5>
<p>发送端维护允许连续发送未应答帧的序号，当收到 ACK
后该序号移除并后移窗口</p>
<p>接收端维护允许连续接收未处理帧的序号，当收到后将该序号移除并后移窗口</p>
<p>延迟-带宽乘积 <span
class="math inline">\(BD\)</span>，窗口大小（发送容许未 ACK 的帧数量）为
<span class="math inline">\(w\)</span>，链路利用率小于 <span
class="math inline">\(\dfrac{w}{1+2BD}\)</span></p>
<h5 id="损坏帧处理">损坏帧处理</h5>
<p>根据接收缓冲区和带宽的 Trade-off，有两种方案</p>
<p><strong>Go Back N</strong></p>
<p>在该帧之后的所有帧都会被忽略，接收窗口大小为 1</p>
<p>使用累计确认（accumulative
acknowledgement），确认某帧会确认之前帧</p>
<p>每一帧都要给一个计数器</p>
<p><strong>Selective Repeat</strong></p>
<p>仅重传该帧，需要 NAK</p>
<p>为了防止发送接收窗口重叠，序列号空间至少为窗口大小的两倍</p>
<h3 id="数据链路层协议例子">数据链路层协议例子</h3>
<h4 id="sonet">SONET</h4>
<p>IP 包；PPP 帧；SONET 载荷</p>
<p>PPP
负责成帧，链路控制（LCP），协商网络层选项（NCP），错误检测；不需要错误纠正，流量控制，有序性，多点链路</p>
<p>PPP 帧结构：Flag 转义
<code>0x7D 0x5E</code>；控制域在不可靠线路上可以使用有序号的传输</p>
<figure>
<img src="/images/ComputerNetworkCourse/image-20220223141513564.png"
alt="image-20220223141513564" />
<figcaption aria-hidden="true">image-20220223141513564</figcaption>
</figure>
<figure>
<img src="/images/ComputerNetworkCourse/image-20220223142343462.png"
alt="image-20220223142343462" />
<figcaption aria-hidden="true">image-20220223142343462</figcaption>
</figure>
<h4 id="asdl">ASDL</h4>
<p>PPP；AAL5；ATM；ASDL 载荷</p>
<figure>
<img src="/images/ComputerNetworkCourse/image-20220223144101981.png"
alt="image-20220223144101981" />
<figcaption aria-hidden="true">image-20220223144101981</figcaption>
</figure>
<hr />
<h2 id="介质访问控制子层">介质访问控制子层</h2>
<p>静态信道分配：FDM，TDM</p>
<p>动态信道分配假设：独立流量、单信道、检测冲突、连续时间或时间槽、载波监听或无载波监听</p>
<p>发送站行为假设：所有帧长相等，泊松分布发送每帧时间发送包均值 <span
class="math inline">\(0&lt;N&lt;1\)</span>，带重传均值 <span
class="math inline">\(G\)</span>，冲突率 <span
class="math inline">\(P_0\)</span>，吞吐率 <span
class="math inline">\(S=GP_0\)</span></p>
<p>给定时间发送 <span class="math inline">\(k\)</span> 帧的概率</p>
<p><span class="math display">\[
\mathrm{Pr}[k]=\frac{G^ke^{-G}}{k!}
\]</span></p>
<h3 id="aloha">ALOHA</h3>
<p><strong>连续时间</strong></p>
<p>无载波监听，若要发送，则直接发送，若冲突，随机重传；<span
class="math inline">\(G=0.5\)</span> 时效率最好 <span
class="math inline">\(18.4\%\)</span></p>
<p><span class="math inline">\(S=Ge^{-2G}\)</span></p>
<p><strong>时间槽</strong></p>
<p>时间槽内才能发送，冲突时间减半，最高效率翻倍 <span
class="math inline">\(G=1\)</span> 时效率最好 <span
class="math inline">\(36.8\%\)</span></p>
<p><span class="math inline">\(S=Ge^{-G}\)</span></p>
<h3 id="csma">CSMA</h3>
<p>Carrier Sence Multiple Access，有载波监听的多站访问</p>
<p><strong>1-persistent</strong></p>
<p>监听，若可发，立即发</p>
<p><strong>Non-persistent</strong></p>
<p>监听，若不可发，随机时间后再次尝试</p>
<p><strong>p-persistent</strong></p>
<p>使用时间槽，若信道可用，以 <span class="math inline">\(p\)</span>
概率发送，<span class="math inline">\(1-p\)</span> 概率下一槽发送</p>
<p><img
src="/images/ComputerNetworkCourse/2022-01-10-15-32-22-image.png" /></p>
<h3 id="csma-cd">CSMA-CD</h3>
<p>CSMA with Collision Detection，带冲突检测</p>
<p>如果冲突发生，立即停止发送，等随机时间</p>
<p><strong>Bit-Map Protocol</strong></p>
<p>N 个冲突槽，在冲突时间发比特以预约，接下来由编号高的站先发</p>
<p><strong>Token Ring</strong></p>
<p>拥有 Token 的站可以发，并把 Token 传递给下一个站</p>
<p><strong>Binary Countdown</strong></p>
<p>在竞争期间从高到低发自己的编号，若看到 1 且自己为 0
则放弃（上述两种每站在竞争期间都需要一位，<span
class="math inline">\(O(N)\)</span>；此方法 <span
class="math inline">\(O(\log N)\)</span>）</p>
<h3 id="limited-contention-protocols">Limited-Contention Protocols</h3>
<p>思路：对 <span class="math inline">\(k\)</span>
个站来说，每个站该槽发的概率若是 <span
class="math inline">\(p\)</span>，成功发的几率是 <span
class="math inline">\(kp(1-p)^{k-1}\)</span>。对 <span
class="math inline">\(p\)</span> 求导可得最优概率 <span
class="math inline">\(((k-1)/k)^{k-1}\)</span>。将多个站分为组，组内竞争，组间无竞争。</p>
<p><strong>The Adaptive Tree Walk Protocol</strong></p>
<p>自适应树遍历协议：叶子是站，节点是组，有冲突则深度优先走直到不冲突</p>
<p>假设 <span class="math inline">\(q\)</span> 个 ready
站均匀分布，<span class="math inline">\(i\)</span> 层某节点的 ready
站期望为 <span class="math inline">\(2^{-i}q\)</span></p>
<h3 id="wireless-lan-protocols">Wireless LAN Protocols</h3>
<p>Hidden terminal problem：A 给 B 发，看不见的 C 也给 B 发</p>
<p>Exposed terminal problem：A 因为 C 不给 B 发，但实际上 C 对 B
没影响</p>
<p>MACA (Multiple Access with Collision Avoidance)：RTS (Request To
Send)，CTS (Clear To Send)；其他收到 CTS 的站不能发，仅收到 RTS
的站可以发</p>
<hr />
<h2 id="ethernet">Ethernet</h2>
<h3 id="classic-ethernet">Classic Ethernet</h3>
<h4 id="physical-layer">Physical Layer</h4>
<p>全部通过 Transceiver 接到同一根同轴线上，同轴线可以 Repeater 串接</p>
<p>发曼彻斯特码</p>
<p>线：<code>xBasey/xBase-T/F</code>，x 表示速率（Mbps），Base
基带传输，y 表示 coax 长度（100m），Twisted pair/Fiber；用四个中继器最长
2500 米</p>
<h4 id="mac-sublayer">MAC Sublayer</h4>
<h5 id="帧格式">帧格式</h5>
<p>前导码每字节 <code>10101010</code>，除了最后一位 Start of
frame；它是曼彻斯特码方波</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-06-18-40-25-image.png" /></p>
<p>MAC 地址第一位 1 是组播地址，全 1 是广播地址</p>
<p>由于 Ethernet 和 IEEE 的兼容问题，0x600 以下为 Length，否则 Type</p>
<p>Data 最长限制最早来自于 Transceiver 的 RAM 容量</p>
<p>传播时延 <span class="math inline">\(\tau\)</span>，最长 <span
class="math inline">\(2\tau\)</span>
时检测到错误，帧长不得小于该时间（2500m，50 <span
class="math inline">\(\mu\)</span>s，10 Mbps，则最小帧长 500
bit）；每一个检测到冲突的站都发 4-6 Byte 的干扰串；最小帧长 64 字节</p>
<p>32 bit CRC Checksum</p>
<h5 id="csma-cd-1">CSMA-CD</h5>
<p>一个时间槽 64 bit</p>
<p>802.3：1-坚持 CSMA-CD</p>
<p>Binary Exponential Backoff: 假设我发的帧已经撞了 <span
class="math inline">\(i\)</span> 次，下次发之前等待
<code>randfrom(0, 2^i)</code> 个时间槽；第 10-15 次冲突等最多 1023
个时间槽，第十六次没成功就开摆</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-06-19-18-35-image.png" /></p>
<h3 id="交换以太网">交换以太网</h3>
<p>全双工则无冲突</p>
<p>混杂模式：所有的帧给所有的电脑，不只给 dst</p>
<h3 id="快速以太网">快速以太网</h3>
<p>802.3u，直接快十倍，再变短（210 m）</p>
<p>100Base-TX 4B-5B 125 MHZ, 100 Mbps (Cat 5 UTP)</p>
<figure>
<img src="/images/ComputerNetworkCourse/image-20220222181549156.png"
alt="image-20220222181549156" />
<figcaption aria-hidden="true">image-20220222181549156</figcaption>
</figure>
<h3 id="千兆以太网">千兆以太网</h3>
<p>支持 200m：</p>
<ul>
<li>载波扩展（加 Padding 到 512 Byte）</li>
<li>帧突发（合并多个帧）</li>
</ul>
<h3 id="万兆">万兆</h3>
<p><code>10GBase-[S|L|E]R/CX4/T</code>，三种光纤/四对同轴/四对双绞线（Cat
6a）</p>
<hr />
<h2 id="无线网络">无线网络</h2>
<h3 id="section">802.11</h3>
<p>数据链路层分为 MAC 子层和 LLC（Logical Link Control）子层</p>
<h4 id="physical-layer-1">Physical Layer</h4>
<p>802.11 Frequency hopping</p>
<p>802.11b Spread spectrum, CDMA 2.4G</p>
<p>802.11a OFDM 5G</p>
<p>802.11g OFDM 2.4G</p>
<p>802.11n MIMO OFDM</p>
<h4 id="mac-sublayer-1">MAC Sublayer</h4>
<p>CSMA-CA</p>
<p>准备发之前先随机后退（Backoff）一段时间，若冲突使用 Binary
Exponential Backoff</p>
<p>使用 ACK 推断冲突</p>
<p>DCF: Distributed Coordination Function 分布式协调功能</p>
<p>Point Coordination Function 用于单 AP 情况，通常无用</p>
<p>Virtual Sensing: Network Allocation Vector 记录别的站要发多久，RTS
CTS 实际上没啥用</p>
<p>DIFS (DCF Interframe Spacing) 每种帧后退不一</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-08-22-02-37-image.png" /></p>
<h4 id="帧格式-1">802.11 帧格式</h4>
<p><img
src="/images/ComputerNetworkCourse/2022-02-09-20-48-58-image.png" /></p>
<p>三个地址：AP, src, dst; rcv, AP, src</p>
<h3 id="broadband-wireless">802.16 Broadband Wireless</h3>
<p>早期试图作为有线本地回环的无线替代的产物，挑战 4G</p>
<p>数据链路层有三个子层：Security Sublayer; MAC common sublayer; Service
specific convergence sublayer.</p>
<h4 id="physical">Physical</h4>
<p>802.16a OFDM, Fixed; 802.16e Scalable OFDMA Mobile</p>
<p>3.5 GHz/2.5 GHz</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-09-21-11-28-image.png" /></p>
<h4 id="mac">MAC</h4>
<p>Classes of service (same as ATM)</p>
<ul>
<li><p>constant bit rate (uncompressed voice)</p></li>
<li><p>real-time variable bit rate (compressed multimedia)</p></li>
<li><p>non-real-time variable bit rate (file transfer)</p></li>
<li><p>best-effort (else)</p></li>
</ul>
<p><img
src="/images/ComputerNetworkCourse/2022-02-09-21-15-19-image.png" /></p>
<h3 id="bluetooth">Bluetooth</h3>
<p>Piconet: Master and slaves</p>
<p>TDM 系统（时分复用）</p>
<p>活跃从节点最大 7 个，最多 255 个驻留节点</p>
<p>Scatternet: overlapping piconets</p>
<p>对于不同的应用预先定义 Profile</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-09-21-43-25-image.png" /></p>
<p>Linkcontrol <span class="math inline">\(\sim\)</span> MAC</p>
<p>L2CAP: Logical Link Control Adaptation Protocol</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-09-21-46-03-image.png" /></p>
<p>Header：F 流量控制 A 确认 S 序号；重复三遍是保证大量冗余</p>
<h3 id="rfid">RFID</h3>
<p>Radio Frequency Identification</p>
<p>EPC (Electronic Product Code) Gen 2 RFID</p>
<h3 id="physical-layer-2">Physical layer</h3>
<p>标签选择不反射或反射读写器的信号（后向散射 Backscatter）</p>
<h3 id="tag-identification-layer">Tag Identification Layer</h3>
<p>Slotted ALOHA</p>
<p>读写器告诉标签的时间槽范围（Query Qrepeat），标签随机选择时间槽应答
RN16，收到读写器ACK后，再发 EPC</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-10-17-26-30-image.png" /></p>
<hr />
<h2 id="二层交换">二层交换</h2>
<h3 id="学习网桥">学习网桥</h3>
<p>网桥工作在混杂模式（dst 不是网桥的包也可以处理）</p>
<p>泛洪：不知道就全发</p>
<p>后向学习：看源端口学</p>
<h3 id="生成树网桥">生成树网桥</h3>
<p>802.1D</p>
<p>选举一个根，然后按到根的距离做生成树</p>
<h3 id="vlan">VLAN</h3>
<p>802.1Q</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-10-19-49-04-image.png" /></p>
<p>最大长度 1522 字节（本来是 1518）</p>
<p>Type 字段魔改一番；CFI: Canonical Format Indicator</p>
<hr />
<h2 id="网络层">网络层</h2>
<p>主要功能：寻址；路由选择；数据分组转发；流量控制；拥塞控制；差错检测恢复；审计</p>
<h3 id="面向连接实现">面向连接实现</h3>
<p>标签交换：路由器可以分配连接标识符</p>
<p>多协议标签交换 MPLS</p>
<h3 id="路由算法">路由算法</h3>
<ul>
<li><p>泛洪算法：设最大跳数，通过维护源路由器的最大序号表判断泛洪过的数据包</p></li>
<li><p>距离矢量路由：表告诉你某目的走哪条路</p>
<ul>
<li>有无穷计数问题</li>
</ul></li>
<li><p>链路状态路由（OSPF/IS-IS）：把完整的链路信息发给别的节点</p>
<ul>
<li><p>广播 LAN（一根
Ethernet）被建模成一个节点，指定一台做路由工作</p></li>
<li><p>发现邻居、度量成本、构造信息包、发给其他路由器、接收信息包、计算最短路</p></li>
<li><p>每一个链路信息数据包都有 Age，每次转发或走过一秒减一</p></li>
<li><p>状态包缓冲区里记录了 Age，Seq，发送标志（要发到哪里），ACK
标志（从哪个端口来）</p></li>
</ul></li>
<li><p>层次路由：分层，最优的层数是 <span class="math inline">\(\ln
N\)</span></p></li>
<li><p>广播路由：逆向路径转发（沿着生成树来的泛洪包可以转，其他的不用）</p></li>
<li><p>组播路由：距离矢量组播路由协议（生成树子树如果没儿子有兴趣就剪掉，但是每个组播源都可能是根）；核心树（发给某个组的树根然后转发，树其实是同一颗）</p></li>
<li><p>任播路由（Anycast，发给最近的组成员）：<del>层次路由即可</del></p></li>
<li><p>移动路由：家乡代理</p></li>
<li><p>Ad Hoc 路由（ADOV）：按需发现（泛洪），路由维护（周期
Hello）</p></li>
</ul>
<h3 id="拥塞控制">拥塞控制</h3>
<ul>
<li><p>网络供给：加钱</p></li>
<li><p>流量感知路由：依照负载调节路由权重</p></li>
<li><p>准入控制：应用于虚电路，控制虚电路建立</p></li>
<li><p>流量调节：向上游发 Choke
包（抑制包）；ECN（应答包上打标记）；逐跳后压（每一跳收到抑制都要减缓）</p></li>
<li><p>负载脱落：Wine；Milk；Priority；RED（Random Early
Detection，平均队列长度超阈值即丢）</p></li>
</ul>
<h3 id="服务质量">服务质量</h3>
<ul>
<li><p>应用需求（带宽；延迟；抖动；丢失）</p></li>
<li><p>流量整形</p>
<ul>
<li><p>漏桶：数据包恒定速率流出</p></li>
<li><p>令牌桶：用令牌发包，令牌恒定速率供给，可以存一些</p></li>
</ul></li>
<li><p>包调度：同一个流的数据包需要统一路由；预约带宽、缓冲和 CPU
时钟</p>
<ul>
<li><p>Round-robon 多个流公平队列</p></li>
<li><p>Weighted Fair Queueing 计算 Finish Time <span
class="math inline">\(F_i=\max(A_i, F_{i-1})+L_i/W\)</span>，按 Finish
Time 排序发送</p></li>
</ul></li>
<li><p>准入控制：建立流时生成流规范（令牌桶容量，令牌桶速率，峰值速率，最小最大包大小），一路上的路由器调整规范并预留资源</p></li>
<li><p>综合服务，资源预留协议：沿着组播生成树往上走做预留</p></li>
<li><p>区分服务：基于类别的服务质量，单跳行为（在服务器的待遇）</p>
<ul>
<li><p>加速转发：开了一个新的快道</p></li>
<li><p>确保转发：先过分类器，再过监管器，生成 12 个 优先级（4 个分类 3
个丢包），进 WFQ</p></li>
</ul></li>
</ul>
<h3 id="互联网络">互联网络</h3>
<p>网络层要隐藏下面不同的链路层技术</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-10-59-12-image.png" /></p>
<p>多协议路由，管道技术：直接把整个带头的包包住（v4 包 v6）</p>
<h4 id="数据包分段">数据包分段</h4>
<p>限制包长的理由</p>
<ul>
<li><p>硬件（如以太网 1500）</p></li>
<li><p>操作系统（如 512 Byte 缓冲区）</p></li>
<li><p>协议（IP 65515 Byte）</p></li>
<li><p>标准</p></li>
<li><p>减少错误带来的重传（802.11 2272 Byte）</p></li>
<li><p>防止占信道</p></li>
</ul>
<p>MTU (Path Maximum Transmission Unit)</p>
<p>Transparent fragmentation:
出网关重组（需要计数，路由器支持，需要缓冲）</p>
<p>Nontransparent fragmentation:
直到目的再重组（分段开销，丢包，主机突发大）</p>
<p>分段相关字段：包编号（分段后一样）；Offset（第一字节的偏移量）；终止位（最后一段）</p>
<p>路径 MTU 发现：如果包太大就传回去告诉源重发个小的</p>
<h3 id="ipv4">IPv4</h3>
<h4 id="ip-头">IP 头</h4>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-14-47-15-image.png" /></p>
<p>(4b) IHL: 头长度，5-15 Words</p>
<p>(1B) Diff.Serv.: 6b 标识确保服务，2b ECN</p>
<p>(2B) L: 65535 Max</p>
<p>(2B) ID: 包序号，同一个包的所有段一样</p>
<p>(1b) Unused</p>
<p>(1b) DF: Don't Fragment，来检测 MTU</p>
<p>(2b) MF: More Fragments: 同包最后一段置 0</p>
<p>(13b) Frag.Offs: 第一字节的位置，段按 8 Byte 对齐，则少三位</p>
<p>(1B) TTL: 最多活 255 跳</p>
<p>(1B) Protocol: 传输层协议</p>
<p>(1B) Checksum: 所有半字的和的补码（加起来是零）</p>
<p>Option 基本不管了</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-15-35-55-image.png" /></p>
<h4 id="ip-地址">IP 地址</h4>
<p>The prefix is network address; the suffix is the host address.</p>
<p>Subnetting: 加长给的 prefix</p>
<p>CIDR-Classless InterDomain Routing 无类域间路由：</p>
<ul>
<li><p>路由聚合，即高层路由器的表项前缀变短</p></li>
<li><p>Longest matching
prefix：聚合完了可以加项，这些前缀长的优先匹配</p></li>
</ul>
<p>Classful addressing</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-16-32-06-image.png" /></p>
<p>Special addresses:</p>
<p><code>127.*.*.*</code> 环回</p>
<p><code>0.0.0.0</code> This host</p>
<p><code>255.255.255.255</code> 广播</p>
<p><code>(Network)11...1</code> 某网络下的所有主机</p>
<p><code>224.0.0.0/24</code> 本地网络组播</p>
<h4 id="nat">NAT</h4>
<p>依赖 TCP/UDP 协议</p>
<p>三种内网 IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.0.0.0    - 10.255.255.255/8</span><br><span class="line">172.16.0.0  - 172.31.255.255/12</span><br><span class="line">192.168.0.0 - 192.168.255.255/16</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Full Cone NAT：第一次使用建立映射 (IP:Port) <span
class="math inline">\(\to\)</span>
(IP:Port)，内发外外发内地址不变</p></li>
<li><p>Restricted Cone NAT：外网主机 S 按映射地址发内网主机 C 时，C
必须向 S 的 IP 发过包</p></li>
<li><p>Port Restricted Cone NAT：外网主机 S 按映射地址发内网主机 C 时，C
必须向 S 的 IP:Port 发过包</p></li>
<li><p>Symmetric NAT：外网主机与内网建立连接，NAT 都会创建新的
IP:Port，其他外网主机无法通过别的连接建立的 IP:Port 访问</p></li>
</ul>
<h3 id="ipv6">IPv6</h3>
<p>目标</p>
<ul>
<li><p>很多</p></li>
<li><p>减小路由表</p></li>
<li><p>简化，更快</p></li>
<li><p>安全</p></li>
<li><p>关注服务类型</p></li>
<li><p>辅助组播</p></li>
<li><p>漫游不换地址</p></li>
<li><p>给发展留空间</p></li>
<li><p>共存</p></li>
</ul>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-21-03-19-image.png" /></p>
<p>流标签为零时不是虚电路，流标签和地址有关</p>
<p>Payload Length 不算 40 个字节的头</p>
<p>Next Header 是可选头的类型，若没有可选头就是下一个协议头</p>
<p>不分段，直接发现 MTU</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-22-35-15-image.png" /></p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-22-43-58-image.png" /></p>
<h3 id="icmp">ICMP</h3>
<p>它是包裹在 IP 里的</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-22-48-14-image.png" /></p>
<h3 id="arp">ARP</h3>
<p>Who has (Some IP)? Tell (Some IP);</p>
<p>(Some IP) is at (Some MAC).</p>
<p>缓存 ARP 表，ARP 表会超时，以允许动态</p>
<p>广播可以把自己的表也给你一份</p>
<p>ARP 别的网会问到网关的 MAC，这样就发给网关了</p>
<h3 id="dhcp">DHCP</h3>
<p>动态主机配置协议 Dynamic Host Configuration Protocol</p>
<p>需要 DHCP 服务器，路由器也支持</p>
<p>DISCOVER;</p>
<p>OFFER.</p>
<h3 id="mpls">MPLS</h3>
<p>多协议标签交换</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-23-21-38-image.png" /></p>
<p>可以多加很多层标签，这样按最外层路由，可以将多条路径合并节省</p>
<p>S 表示后面是不是还有标签</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-23-22-06-image.png" /></p>
<h3 id="ospf">OSPF</h3>
<p>Open Shortest Path First</p>
<p>域内路由算法（内部网关协议）（RIP
也是内部网关协议）：自治系统（AS）里的协议</p>
<p>如果有多条最短路，OSPF 会平均载荷</p>
<p>支持物理距离、延迟等距离尺度</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-23-50-35-image.png" /></p>
<p>一个区域内的最短路计算是一样的</p>
<p>边界路由器可以传递拓扑的摘要，如果边界只有一个路由器（stub
存根），不需要传递路由信息</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-12-23-54-10-image.png" /></p>
<h3 id="bgp">BGP</h3>
<p>Border Gateway Protocol</p>
<p>域间路由算法，解决政治、经济问题</p>
<p>是距离矢量协议</p>
<p>路由器通过 TCP 通信</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-13-00-02-12-image.png" /></p>
<p>所有 AS 从 AS1 买服务，AS2 3 间有对等传输</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-13-00-08-41-image.png" /></p>
<h3 id="igmp">IGMP</h3>
<p>组播</p>
<h3 id="mobile-ip">Mobile IP</h3>
<ul>
<li><p>Use home IP everywhere</p></li>
<li><p>No software changes</p></li>
<li><p>No router/table changes</p></li>
<li><p>Restrict detours</p></li>
<li><p>No overhead at home</p></li>
</ul>
<p>ARP 代理</p>
<p>gratuitous ARP</p>
<hr />
<h2 id="传输层">传输层</h2>
<p>主要工作：屏蔽子网差异；弥补应用层差异；提供进程级通信能力</p>
<p>传输实体：Kernel/so/proc，给应用层提供两种服务</p>
<p>单独的一层：位置不一样，主机，路由器。用户对网络层没有控制权</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-15-21-28-56-image.png" /></p>
<p>Segment: TPDU (Transport Protocol Data Unit)（想想为啥它也要
Seq）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-15-22-24-10-image.png" /></p>
<p>Berkeley Socket 原语</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-11-37-22-image.png" /></p>
<p>NSAP(Network Service Access Point): IP</p>
<p>TSAP(Transport Service Access Point): Port</p>
<p>如何区分并拒绝重复的段：数据包存活上限 <span
class="math inline">\(T\)</span>（120s for Internet），序号在 <span
class="math inline">\(T\)</span>
内不被重用（划禁止区域），初始序号即（不同步的）计数器的低位，序号递增速率不得大于时间进度</p>
<p>三次握手（目的是让服务器区分连接请求是否确是当前的）</p>
<p>段也要时间戳，为了防止 32
位序号绕回（因为现在太快了）（序号需要随机以防被预测）</p>
<p>非对称释放：挂电话；对称释放：我不发了哦</p>
<p>四次挥手，因为要是对方决定好了要放开连接才放开连接，那就放不了了</p>
<p>挥手以及 ACK 超时都会释放连接</p>
<p>多路复用：多个连接过一个地址（路由器）；逆向多路复用：一个连接利用多个网络地址冲</p>
<h3 id="差错控制">差错控制</h3>
<p>链路层的差错控制可以避免整条路径重传</p>
<p>传输层差错控制可以防止路由器出错</p>
<p>BL 积非常大，窗口和缓冲要大，多连接：缓冲池</p>
<p>动态缓冲区分配，发送端告知要多少缓冲，接收端分配并告诉实际缓冲数量（Window
size 字段）</p>
<p>窗口大小跟踪网络承载能力的变化，也可以达到拥塞控制</p>
<p>主机崩溃恢复只能由上层完成（A for ACK；W for write to process；C for
crash）（S0 没有未完成的段但有确认，S1 没有确认）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-16-34-21-image.png" /></p>
<h3 id="流量控制-1">流量控制</h3>
<p>流量分配</p>
<ul>
<li><p>最大最小公平：（所有的流从零开始增长）如果分配给一个流的带宽在不减少分配给另一个流带宽的前提下无法得到进一步增长，那么就不给这个流更多带宽</p></li>
<li><p>事实上模糊地按连接分配流量，所以电驴毒瘤</p></li>
</ul>
<p>XCP(eXplicit Congestion Protocol) 路由器告诉源速率，ECN
路由器告诉源减速，其他是测量并控制</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-20-15-45-image.png" /></p>
<p>关于丢包式检测：无线链路层毫秒级重传，传输层秒级</p>
<p>加法递增乘法递减：</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-17-28-53-image.png" /></p>
<h3 id="udp">UDP</h3>
<p>没有流量控制，差错控制或者重传；有多路复用</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-20-31-28-image.png" /></p>
<p>校验和包括的伪头如下（没有传输，算的时候按下面，实际上破坏分层）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-20-32-21-image.png" /></p>
<p>远程过程调用（Remote Procedure Call）：不需要
Socket，客户端和服务器都有 Stub</p>
<p>实时传输协议 RTP（应用层上实现的传输协议）：UDP 实现（配合 RTCP
控制协议获得更多功能）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-21-01-38-image.png" /></p>
<p>P：四字节对齐；X：扩展头；CC：有多少贡献源；M
应用解释（一般为标记开始）；Payload Type（MP3）；时间戳用于减少抖动</p>
<p>同步源标识符 (Synchronization source identifier)
指明了该数据包属于哪一个流</p>
<h3 id="tcp">TCP</h3>
<h4 id="头">头</h4>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-21-22-36-image.png" /></p>
<p>一个 TCP 段最多 65535-20(IP)-20(TCP) = 65495 数据</p>
<p>TCP 给每个字节编了址，ACK number 是下一个期待的字节（累计确认）</p>
<p>标志位</p>
<ul>
<li><p>有 ECN 时，ECE（ECN-Echo）告诉发送端网络给了 ECN；CWR（Congestion
Window Reduced）表示发送端已放缓</p></li>
<li><p>URG
是否使用紧急指针，紧急指针指向数据里紧急的那个部分（实际上不怎么用）</p></li>
<li><p>PSH 刷缓冲区</p></li>
<li><p>RST 被用于突然重置一个己经变得混乱的连接，或者拒绝连接</p></li>
<li><p>SYN/ACK=1/0 表示连接请求，SYN/ACK=1/1 表示连接接受</p></li>
<li><p>FIN 挥手</p></li>
</ul>
<p>校验和包括头、数据和 TCP 伪头（和 UDP 一样），校验是强制的</p>
<p>选项可以有的字段：</p>
<ul>
<li><p>最大段长 MSS</p></li>
<li><p>窗口尺度（可以将窗口大小左移最多 14 位）</p></li>
<li><p>时间戳（解决序号绕回）</p></li>
<li><p>SACK 已经接收到的段序号范围</p></li>
</ul>
<h4 id="连接">连接</h4>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-21-55-31-image.png" /></p>
<p>右：如果同时发起连接，结果是建立了一个 (x, y) 的连接</p>
<p>SYN 泛洪解决方法：序号加密送出去，握手回来解密拿到序号</p>
<p>四次挥手 SYN 和 ACK 可能在同一个包，就变成了三次</p>
<p>TCP 连接是十一个状态的有限状态机</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-22-03-25-image.png" /></p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-22-10-15-image.png" /></p>
<h4 id="滑动窗口">滑动窗口</h4>
<p><img
src="/images/ComputerNetworkCourse/2022-02-16-22-24-56-image.png" /></p>
<p>窗口探测：强制宣告下一个窗口大小</p>
<p>延迟确认：接收端最晚到缓冲区满才确认（延迟 50 ms 等搭车）</p>
<p>Nagle（避免发的全是小包）：发送端只发送第一次到达的数据，后面的缓冲起来（相当于停等）</p>
<p>Clark（低能窗口综合症，应用一次读一个，窗口就 1）：窗口更新在
空缓存<span class="math inline">\(=\min(\)</span> 一半，最大段长 <span
class="math inline">\()\)</span> 时才发生</p>
<h4 id="计时器管理">计时器管理</h4>
<h5 id="重传计时器">重传计时器</h5>
<p>记录 <span class="math inline">\(SRTT\)</span>
平滑平均往返时间：<span class="math inline">\(SRTT=\alpha
SRTT+(1-\alpha)RTT\)</span>，<span class="math inline">\(\alpha\)</span>
典型值 <span class="math inline">\(7/8\)</span></p>
<p><span class="math inline">\(RTTVAR\)</span> 是上述的均方差：<span
class="math inline">\(RTTVAR=\beta RTTVAR + (1-\beta)|SRTT-RTT|\)</span>
典型值 <span class="math inline">\(3/4\)</span></p>
<p>重传超时 <span class="math inline">\(RTO=SRTT+4RTTVAR\)</span></p>
<p>第一次重传不更新估计值，接下来每一次连续重传超时加倍</p>
<h5 id="持续计时器">持续计时器</h5>
<p>发送端做窗口探测以免窗口更新丢了</p>
<h5 id="保活计时器">保活计时器</h5>
<p>连接没有活动时查看另一端是否存在（争议）</p>
<h5 id="连接终止计时器">连接终止计时器</h5>
<p>等待最大包存活时间的两倍</p>
<h4 id="拥塞控制-1">拥塞控制</h4>
<p>拥塞窗口（cnwd）：任何时候发送端可以向网络发送的字节数</p>
<p>确认时钟：ACK 包的速率代表了这个网络上最慢的链路的速度</p>
<p>慢启动：拥塞窗口初始值 4 个段，每 ACK
一个发出的包增加一个段的字节量（任何时候未确认的数据包的数量就是拥塞窗口的大小）</p>
<p>TCP Tahoe</p>
<ul>
<li><p>慢启动阈值：慢启动的上限，每当检测到丢包，慢启动阈值就设为拥塞窗口的一半，慢启动超过阈值之后就到线性增加（近似每个
RTT 增加一段，针对 cwnd/MSS 中每个可能被确认的包，增加
(MSS*MSS)/cnwd）</p></li>
<li><p>丢包：意味着拥塞窗口满，无法发包，等到重传可发再开始慢启动，阈值为拥塞窗口一半</p></li>
<li><p>重复确认：当丢失数据包的后续数据包到达接收端时，它们触发给发送端返回确认，这些确认段携带着相同的确认号（因为是累积确认）；TCP
假设三个确认意味着丢包了（快速重传）</p></li>
</ul>
<p>快速恢复（维持确认时钟避免重新慢速启动）：对重复确认计数直到网络内的数据包数量下降到新阈值，从此时往后，每接收到一个重复确认就发送一个新的数据包；一个
RTT 后丢的包被确认（就没有重复确认了），重新开始线性增加</p>
<h4 id="性能问题">性能问题</h4>
<ul>
<li><p>Performance problems in computer networks</p></li>
<li><p>Network performance measurement</p>
<ul>
<li>确保样值空间足够大，确保样值具有代表性，缓存可以破坏测量结果，确保测试期间不会发生不可知事情，小心使用粗粒度时钟，小心推断结果</li>
</ul></li>
<li><p>System design for better performance</p>
<ul>
<li>主机速度比网络速度更重要，减少包数量来降低开销，最小化数据复制（一起实现层），带宽能买延时不行，最小化上下文切换，避免拥塞比从中恢复更好，避免超时（重复）</li>
</ul></li>
<li><p>Fast TPDU processing</p>
<ul>
<li>Make common cases fast; TCP/IP
相邻段一般一样（存好）；计时轮（每个槽一个
Tick，指向一个触发的计时器列表）</li>
</ul></li>
<li><p>Protocols for high-speed networks</p>
<ul>
<li>序号回绕；大窗口；重传策略；延时瓶颈；简洁协议少计算</li>
</ul></li>
</ul>
<h4 id="delay-tolerant-networking">Delay Tolerant Networking</h4>
<p>处理间歇性的连接，按消息处理，存储转发</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-15-05-08-image.png" /></p>
<p>Custodian 托管标识符（路上的节点承担照看数据安全的责任）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-15-06-38-image.png" /></p>
<hr />
<h2 id="应用层">应用层</h2>
<h3 id="dns">DNS</h3>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-15-42-15-image.png" /></p>
<p>记录格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Domain name   Time to live    Class     Type     Value</span><br><span class="line">cs.mit.edu    86400           IN        CNAME    csail.mit.edu</span><br><span class="line">; Authoritative data for cs.vu.nl</span><br><span class="line">cs.vu.nl      86400           IN        SOA      star boss (9527,....)</span><br><span class="line">cs.vu.nl      86400           IN        MX       1 zephyr</span><br><span class="line">cs.vu.nl      86400           IN        MX       2 top</span><br><span class="line">cs.vu.nl      86400           IN        NS       star</span><br><span class="line">star          86400           IN        A        130.37.56.205</span><br><span class="line">zephyr        86400           IN        A        130.37.20.10</span><br><span class="line">top           86400           IN        A        130.37.20.11</span><br><span class="line">www           86400           IN        CNAME    star.cs.vu.nl</span><br><span class="line">ftp           86400           IN        CNAME    zephyr.cs.vu.nl</span><br><span class="line">rowboat                       IN        A        130.37.56.201</span><br><span class="line">                              IN        MX       1 rowboat</span><br><span class="line">                              IN        MX       2 zephyr</span><br></pre></td></tr></table></figure>
<p>IN：Internet</p>
<p>PTR 可用于反向查找（IP 查名字）</p>
<h4 id="域名解析">域名解析</h4>
<p>权威记录：管辖的服务器返回的结果（相对于缓存记录）</p>
<p>13 个根服务器 <code>a.root-servers.net</code> 到
<code>m.root-servers.net</code>，选播路由</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-16-11-23-image.png" /></p>
<p>递归查询：服务器全权帮你干完，给你返回最终结果</p>
<p>迭代查询：返回部分方案和下一个操作</p>
<h3 id="email">Email</h3>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-16-26-13-image.png" /></p>
<p>SMTP-&gt;SMTP-&gt;POP3/IMAP</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-16-38-50-image.png" /></p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-16-41-22-image.png" /></p>
<p>MIME：多媒体支持</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-19-23-26-image.png" /></p>
<p>五种传输编码和一个扩充入口：文本、8
位编码、二进制文件、base64、可打印编码</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-19-26-50-image.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From: alice@cs.washington.edu</span><br><span class="line">To: bob@ee.uwa.edu.au</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Message-Id: &lt;0704760941.AA00747@cs.washington.edu&gt;</span><br><span class="line">Content-Type: multipart/alternative; boundary=qwertyuiopasdfghjklzxcvbnm</span><br><span class="line">Subject: Earth orbits sun integral number of times</span><br><span class="line"></span><br><span class="line">This is the preamble. The user agent ignores it. Have a nice day.</span><br><span class="line"></span><br><span class="line">--qwertyuiopasdfghjklzxcvbnm</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Happy birthday to you&lt;br&gt;</span><br><span class="line">Happy birthday to you&lt;br&gt;</span><br><span class="line">Happy birthday dear &lt;b&gt; Bob &lt;/b&gt;&lt;br&gt; Happy birthday to you&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">--qwertyuiopasdfghjklzxcvbnm</span><br><span class="line">Content-Type: message/external-body;</span><br><span class="line">    access-type=&quot;anon-ftp&quot;;</span><br><span class="line">    site=&quot;bicycle.cs.washington.edu&quot;;</span><br><span class="line">    directory=&quot;pub&quot;;</span><br><span class="line">    name=&quot;birthday.snd&quot;</span><br><span class="line"></span><br><span class="line">content-type: audio/basic</span><br><span class="line">content-transfer-encoding: base64</span><br><span class="line">--qwertyuiopasdfghjklzxcvbnm--</span><br></pre></td></tr></table></figure>
<p>SMTP (Simple Mail Transfer Protocol) 端口 25，纯 ASCII
协议，不包括认证，明文传输；4 个单词的命令（<code>HELO</code>,
<code>MAIL FROM</code>, <code>RCPT TO</code>, <code>DATA</code>）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-19-43-29-image.png" /></p>
<p>IMAP (Internet Message Access Protocol) 端口 143</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-19-47-14-image.png" /></p>
<p>POP3 (Post Office Protocol) 端口 110</p>
<h3 id="www">WWW</h3>
<p>URL (Uniform Resourse Locator); URI (Uniform Resourse Identifier)</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-19-51-35-image.png" /></p>
<p>Cookie 最多 4KB</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-20-09-11-image.png" /></p>
<p>动态页面</p>
<ul>
<li><p>公共网关接口 (CGI, Common Gateway Interface)：后端程序到 Web
服务器的接口</p></li>
<li><p>PHP <code>&lt;?php echo $name; ?&gt;</code>; JSP;
ASP.NET</p></li>
<li><p>JS; VBScript</p></li>
</ul>
<p>HTTP</p>
<ul>
<li><p>HTTP1.1 持续连接（一次连接多次请求、流水请求）</p></li>
<li><p>ASCII 协议</p></li>
</ul>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-20-26-33-image.png" /></p>
<p>每个响应都有状态码</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-20-28-27-image.png" /></p>
<p>消息头 (Cookie; Set-Cookie ...)</p>
<p>缓存</p>
<ul>
<li><p>Check expiry</p></li>
<li><p>Conditional GET (If-Modified-Since; Etag; If-None-Match)</p></li>
<li><p>Not modified / Responce</p></li>
</ul>
<p>移动 Web (XHTML)</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-20-36-50-image.png" /></p>
<h3 id="流媒体">流媒体</h3>
<p>量化 CD: 44100 / 16 bit / 1.4 Mbps stereo</p>
<p>编码 AAC 96k 128kbps；</p>
<ul>
<li><p>波形编码：FFT 后传未被截止的频率</p></li>
<li><p>感知编码：利用频率屏蔽</p></li>
</ul>
<p>JPEG</p>
<ol type="1">
<li><p>块准备（YCbCr 三个矩阵各切成 8x8）</p></li>
<li><p>离散余弦变换</p></li>
<li><p>量化（除权值）</p></li>
<li><p>差分量化</p></li>
<li><p>行程编码（蛇皮发送顺序）</p></li>
<li><p>静态输出编码（霍夫曼编码）</p></li>
</ol>
<p>MPEG</p>
<ul>
<li><p>I 帧内编码</p></li>
<li><p>P 前向（I）帧</p></li>
<li><p>B 前后向（IP）帧</p></li>
</ul>
<p>视频</p>
<ul>
<li><p>前向纠错（发校验，组播路由大家丢不一样）</p></li>
<li><p>交替传输（一个包只传奇数帧，掉个帧罢了）</p></li>
<li><p>缓冲</p></li>
</ul>
<p>实时会议 H.323（可以电话拨入）</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-21-19-03-image.png" /></p>
<p>建立 5
条逻辑信道：呼叫信令（Q.931）；呼叫控制（H.245）；“双工”数据（两条RTP）；数据控制（RTCP）</p>
<p>IP 语音 SIP</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-21-39-51-image.png" /></p>
<h3 id="content-delivery">Content Delivery</h3>
<p>Zipf 分布</p>
<p>服务器农场（DNS/负载均衡）</p>
<p>Web 代理（缓存）</p>
<p>CDN</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-21-50-34-image.png" /></p>
<p>P2P</p>
<p>Overlay networks</p>
<p>BitTorrent</p>
<p>Torrent（种子）：跟踪器的名称、块清单（和哈希）</p>
<p>Tracker：上传下载该内容的用户列表</p>
<p>DHT 分布式哈希表（Cord 方案）节点保留少量其他节点信息</p>
<p>逻辑上 Key 是 <code>hash(Torrent)</code>，Value 是 IP</p>
<p>标识符构成一个环，有可能代表实际节点</p>
<p><code>successor(k)</code> 是 k 之后第一个实际节点的标识符，key 和 k
在同一个空间做映射</p>
<p>朴素找：向 successor 发 query，沿着环走，找到了返回给请求者</p>
<p>指取表（倍增找）：每个节点一张，Key 是 0-(m-1)（m
是实际节点数）；标识符 k 的第 i 项是
<code>start=(k+(1&lt;&lt;i))%(1&lt;&lt;m)</code> 和
<code>successor(start[i])</code> 的 IP</p>
<hr />
<h2 id="网安">网安</h2>
<h3 id="密码学">密码学</h3>
<p>密码分析学：唯密文/已知明文（有一些明文密文对）/选择明文（可以由明文生成密文）</p>
<p>密码编码学：努力在选择明文保持安全</p>
<p><span class="math display">\[
D_K(E_K(P))=P
\]</span></p>
<p>Kerckhoff
原则：保密性仅取决于对密钥的保密，而算法是公开的。密钥作为算法参数</p>
<p>置换密码：做置换</p>
<p>替代密码：按行排，然后按列按列顺序写</p>
<p>一次性密钥：xor</p>
<p>量子密钥</p>
<p>密码学原则：冗余度、新鲜度</p>
<h3 id="对称密钥">对称密钥</h3>
<p>加密解密是一个密钥</p>
<p>DES</p>
<p><img
src="/images/ComputerNetworkCourse/2022-02-17-22-55-37-image.png" /></p>
<p>三重 DES，K1 加密 K2 解密 K1 加密</p>
<p>AES</p>
<p>密码长度和块长度 128-128 / 128-256</p>
<p>生成 11 个轮密钥干牛b事情</p>
<h3 id="公钥算法">公钥算法</h3>
<ul>
<li><p><span class="math inline">\(D(E(P))=P\)</span></p></li>
<li><p>从 E 推导 D 极其困难</p></li>
<li><p>E 不会被选择明文破解</p></li>
</ul>
<p>加密公钥，解密私钥</p>
<p>RSA</p>
<ul>
<li><p>选大素数 <span class="math inline">\(p\)</span>，<span
class="math inline">\(q\)</span></p></li>
<li><p>计算 <span class="math inline">\(n=pq\)</span>，<span
class="math inline">\(z=(p-1)(q-1)\)</span></p></li>
<li><p>找一个与 <span class="math inline">\(z\)</span> 互质的 <span
class="math inline">\(d\)</span></p></li>
<li><p>找到 <span class="math inline">\(e\)</span> 使 <span
class="math inline">\(ed=1\mod z\)</span></p></li>
</ul>
<p>加密：<span class="math inline">\(C=P^e\mod n\)</span>，解密 <span
class="math inline">\(P=C^d\mod n\)</span></p>
<h3 id="数字签名">数字签名</h3>
<ul>
<li><p>接收方可验证</p></li>
<li><p>发送方无法否认</p></li>
<li><p>接收方无法编造</p></li>
</ul>
<p>对称密钥：Big Brother</p>
<p>非对称：要求 <span
class="math inline">\(E(D(P))=P\)</span>；主要问题是 Alice
可以公开私钥</p>
<h3 id="消息摘要">消息摘要</h3>
<p>认证但不需要保密</p>
<p>SHA</p>
<p>MD5（8 行了）</p>
<h3 id="证书">证书</h3>
<p>安全地分发公钥</p>
<p>证书证明某个公钥属于某人，这个证书附带一个签名块（证书的 SHA
被私钥签名）</p>
<p>X.509 证书</p>
<p>PKI 信任链</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>概率统计与随机过程复习整理</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="概率论">概率论</h2>
<h3 id="不等式合集">不等式合集</h3>
<h4 id="柯西-施瓦茨不等式">柯西-施瓦茨不等式</h4>
<p>由协方差性质推导 <span class="math display">\[
E\left((XY)^2\right)\leq E(X^2)E(Y^2)
\]</span></p>
<h4 id="马尔可夫不等式">马尔可夫不等式</h4>
<p><span class="math inline">\(r\)</span> 阶矩存在，则 <span
class="math inline">\(\forall \varepsilon &gt;0\)</span> <span
class="math display">\[
P\{|X|\geq \varepsilon\}\leq \frac{(|X|^r)}{\varepsilon^r}
\]</span></p>
<h4 id="切比雪夫不等式">切比雪夫不等式</h4>
<p><span class="math display">\[
\begin{align}
P\{|X-E(X)|\geq \varepsilon\}&amp;\leq\frac{D(X)}{\varepsilon^2}
\nonumber\newline
P\{|X-E(X)|&lt; \varepsilon\}&amp;\geq
1-\frac{D(X)}{\varepsilon^2}\nonumber
\end{align}
\]</span></p>
<h3 id="事件">事件</h3>
<p>随机现象的观察（<strong>随机试验</strong>） <span
class="math inline">\(E\)</span> 的<strong>样本空间</strong>为 <span
class="math inline">\(\Omega=\{\omega\}\)</span>，<strong>随机事件</strong>
<span class="math inline">\(A\subset
\Omega\)</span>。<strong>必然事件</strong> <span
class="math inline">\(\Omega\)</span>，<strong>不可能事件</strong> <span
class="math inline">\(\varnothing\)</span></p>
<p>事件 <span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span> 的和 <span class="math inline">\(A\cup
B = A+B\)</span> 表示其中至少一件事情发生</p>
<p>事件 <span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span> 的积 <span class="math inline">\(A\cap
B = AB\)</span> 表示均发生</p>
<p><strong>互斥</strong> <span
class="math inline">\(AB=\varnothing\)</span></p>
<p><span class="math inline">\(A\)</span> 的<strong>对立</strong> <span
class="math inline">\(\overline A\)</span></p>
<p>事件 <span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span> 的差 <span
class="math inline">\(A-B=A\overline B\)</span> 表示 <span
class="math inline">\(A\)</span> 发生而 <span
class="math inline">\(B\)</span> 不发生</p>
<p>交换律、结合律、分配律、对偶律、吸收律、德摩根律</p>
<h3 id="事件的概率">事件的概率</h3>
<ul>
<li>古典概型 <span class="math inline">\(P(A)=\frac{\text{ sum
of}A\text{ results}}{\text{ total results}}\)</span></li>
<li>几何概型 <span
class="math inline">\(P(A)=\frac{S_A}{S_{\Omega}}\)</span></li>
<li>频数 <span
class="math inline">\(f_n(A)=\frac{n_A}{n}\)</span>，统计概率 <span
class="math inline">\(P(A)=p\sim\lim\limits_{n\to \infty}
f_n(A)\)</span></li>
</ul>
<h4 id="概率的性质">概率的性质</h4>
<p>基本性质</p>
<ul>
<li><span class="math inline">\(P(A)\geq 0\)</span></li>
<li><span class="math inline">\(P(\Omega)=1\)</span></li>
<li>设 <span class="math inline">\(A_i\)</span> 两两互斥，<span
class="math inline">\(P\left(\bigcup_i A_i\right)=\sum_i
P(A_i)\)</span></li>
</ul>
<p>不可能事件性质 <span
class="math inline">\(P(\varnothing)=0\)</span></p>
<p>可减性 <span class="math inline">\(A\subset B \Rightarrow
P(B-A)=P(B)-P(A)\)</span></p>
<p>取反性 <span class="math inline">\(P\left(\overline
A\right)=1-P(A)\)</span></p>
<p>容斥原理 <span class="math inline">\(P(\bigcup_i
A_i)=\sum_{S\subset\{A_i\}}(-1)^{|S|-1}P(\bigcap_{s\in S}s)\)</span></p>
<p>概率的连续性</p>
<h4 id="条件概率">条件概率</h4>
<p><span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span></p>
<p>若 <span class="math inline">\(B_1,B_2,\cdots\)</span>
构成互斥完备事件组且 <span
class="math inline">\(P(B_i)&gt;0\)</span></p>
<p><strong>全概率公式</strong> <span class="math display">\[
P(A)=\sum_j P(B_j)P(A|B_j)
\]</span> <strong>贝叶斯公式</strong> <span class="math display">\[
P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum_j
P(B_j)P(A|B_j)}=\frac{P(B_i)P(A|B_i)}{P(A)}
\]</span></p>
<h4 id="独立事件">独立事件</h4>
<p><span class="math inline">\(A,B\)</span> 独立即 <span
class="math inline">\(P(AB)=P(A)P(B)\)</span></p>
<p><span class="math inline">\(A,B \text{ are independent}
\Longleftrightarrow A,\overline B \text{ are independent}
\Longleftrightarrow \overline A,B \text{ are independent}
\Longleftrightarrow \overline A,\overline B \text{ are
independent}\)</span></p>
<p>事件集中事件相互独立，即对所有子集，满足积的概率等于概率的积</p>
<h3 id="随机变量">随机变量</h3>
<p>随机变量 <span class="math inline">\(X\)</span> 为随机试验 <span
class="math inline">\(E\)</span> 中随机事件 <span
class="math inline">\(\omega\)</span> 的单值实函数</p>
<p><strong>分布函数</strong> <span class="math inline">\(F(x)=P(\{X\leq
x\})\)</span>，（以后记作 <span class="math inline">\(P\{X\leq
x\}\)</span>）</p>
<p>连续型随机变量<strong>概率密度</strong> <span
class="math inline">\(F(x)=\int_{-\infty}^x f(x)\mathrm d x\)</span></p>
<h4 id="多维随机变量">多维随机变量</h4>
<p>二维连续型随机变量 <span class="math inline">\((X,Y)\)</span></p>
<p>联合分布函数 <span
class="math inline">\(F(x,y)\)</span>，联合概率密度函数 <span
class="math inline">\(f(x,y)\)</span></p>
<p><strong>边缘概率密度</strong> <span
class="math inline">\(f_X(x)=\int_{-\infty}^{+\infty}f(x, y)\mathrm d
y\)</span></p>
<p><strong>条件概率密度</strong> <span
class="math inline">\(f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)}\)</span></p>
<p>随机变量独立 $F(x,y)=F_X(x)F_Y(y) f(x,y)=f_X(x)f_Y(y) X,Y $</p>
<p>相互独立随机变量的函数相互独立</p>
<h4 id="随机变量的函数">随机变量的函数</h4>
<p><span class="math inline">\(y=g(x)\)</span> 严格单调可导时，<span
class="math inline">\(Y=g(X)\)</span> 的概率密度</p>
<p><span class="math display">\[
f_Y(y) =
\begin{cases}
f_X(g^{-1}(y))\left| \frac{\mathrm d g^{-1}(y)}{\mathrm d y} \right|
&amp;, y\in \mathscr R(g) \newline
0 &amp;, \text{ else}
\end{cases}
\]</span></p>
<p>随机变量和概率密度 <span
class="math inline">\(Z=X+Y\)</span>（卷积公式） <span
class="math display">\[
f_Z(z)=\int_{-\infty}^{\infty}f_{XY}(x,z-x)\mathrm dx
\xlongequal{X \text{  and } Y \text{  are independent}}
\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)\mathrm dx
\]</span> 随机变量商概率密度 <span class="math inline">\(Z=X/Y\)</span>
<span class="math display">\[
f_Z(z)=
\int_{-\infty}^{\infty} |y|f_{XY}(yz, y)\mathrm d y
\xlongequal{X \text{  and } Y \text{  are independent}}
\int_{-\infty}^{\infty} |y|f_X(yz)f_Y(y)\mathrm d y
\]</span> 随机变量取最大最小值概率分布 <span
class="math inline">\(M=\max_i\{X_i\}\)</span>，<span
class="math inline">\(N=\min_i\{X_i\}\)</span></p>
<p><span class="math display">\[
\begin{align}
F_M(z)=\prod_i F_{X_i}(z) \nonumber\newline
F_N(z)=1-\prod_i (1-F_{X_i}(z))\nonumber
\end{align}
\]</span></p>
<h4 id="随机变量数字特征">随机变量数字特征</h4>
<h5 id="期望">期望</h5>
<p><span class="math display">\[
\begin{align}
E(X)&amp;=\int_{-\infty}^{+\infty} xf(x)\mathrm d x \nonumber\newline
E(g(X)) &amp;= \int_{-\infty}^{+\infty} g(x)f(x)\mathrm d x
\nonumber\newline
E(g(X,Y)) &amp;= \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}
g(x,y)f(x,y)\mathrm d x\mathrm d y \nonumber\newline
\end{align}
\]</span></p>
<ul>
<li><p>期望是线性的</p></li>
<li><p>若随机变量 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 独立，<span
class="math inline">\(E(XY)=E(X)E(Y)\)</span></p></li>
</ul>
<h5 id="方差">方差</h5>
<p><span class="math display">\[
D(X)=E\left((X-E(X))^2\right)=E(X^2)-E^2(X)
\]</span></p>
<ul>
<li><span class="math inline">\(D(C)=0\)</span></li>
<li><span class="math inline">\(D(CX)=C^2D(X)\)</span></li>
<li><span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\pm
2\mathrm{Cov}(X,Y)\)</span></li>
</ul>
<h5 id="协方差">协方差</h5>
<p><span class="math display">\[
\mathrm{Cov}(X,Y)=E\left((X-E(X))(Y-E(Y))\right) = E(XY)-E(X)E(Y)
\]</span></p>
<ul>
<li><span
class="math inline">\(\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)\)</span></li>
<li><span
class="math inline">\(\mathrm{Cov}(X_1+X_2,Y)=\mathrm{Cov}(X_1,Y)+\mathrm{Cov}(X_2,Y)\)</span></li>
</ul>
<h5 id="相关系数">相关系数</h5>
<p><span class="math display">\[
\rho(X,Y)=\frac{\mathrm{Cov}(X,Y)}{\sqrt{D(x)}\sqrt{D(Y)}}
\]</span></p>
<h5 id="矩">矩</h5>
<p><span class="math inline">\(n\)</span> 阶原点矩 <span
class="math inline">\(\alpha_n=E(X^n)\)</span></p>
<p><span class="math inline">\(n\)</span> 阶中心矩 <span
class="math inline">\(\mu_n=E\left((X-E(X))^n\right)\)</span></p>
<p><span class="math inline">\(X,Y\)</span> 的 <span
class="math inline">\(k+l\)</span> 阶混合原点矩、混合中心矩</p>
<h3
id="各分布随机变量的形式与特征及关系">各分布随机变量的形式与特征及关系</h3>
<h4 id="离散型随机变量">离散型随机变量</h4>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 41%" />
<col style="width: 14%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span> 的分布</th>
<th>分布律 <span class="math inline">\(P\{x=k\}\)</span></th>
<th>期望 <span class="math inline">\(E(X)\)</span></th>
<th>方差 <span class="math inline">\(D(X)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>两点分布 <span class="math inline">\(B(n,p)\)</span></td>
<td><span class="math inline">\(C_n^kp^k(1-p)^{n-k}\)</span></td>
<td><span class="math inline">\(np\)</span></td>
<td><span class="math inline">\(np(1-p)\)</span></td>
</tr>
<tr class="even">
<td>泊松分布 <span class="math inline">\(P(\lambda)\)</span></td>
<td><span
class="math inline">\(\frac{\lambda^k}{k!}\exp(-\lambda)\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
</tr>
<tr class="odd">
<td>几何分布 <span class="math inline">\(G(p)\)</span></td>
<td><span class="math inline">\((1-p)^{k-1}p\)</span></td>
<td><span class="math inline">\(\frac{1}{p}\)</span></td>
<td><span class="math inline">\(\frac{1-p}{p^2}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="连续型随机变量">连续型随机变量</h4>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 36%" />
<col style="width: 15%" />
<col style="width: 13%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span> 的分布</th>
<th>概率密度 <span class="math inline">\(f(x)\)</span></th>
<th>分布函数 <span class="math inline">\(F(x)\)</span></th>
<th>期望 <span class="math inline">\(E(X)\)</span></th>
<th>方差 <span class="math inline">\(D(X)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>正态分布 <span class="math inline">\(N(\mu,\sigma^2)\)</span></td>
<td><span
class="math inline">\(\frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\)</span></td>
<td><span class="math inline">\(\Phi(x)\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\sigma^2\)</span></td>
</tr>
<tr class="even">
<td>均匀分布 <span class="math inline">\(U(a,b)\)</span></td>
<td><span class="math inline">\(\frac{1}{b-a}\)</span></td>
<td><span class="math inline">\(\frac{x-a}{b-a}\)</span></td>
<td><span class="math inline">\(\frac{a+b}{2}\)</span></td>
<td><span class="math inline">\(\frac{(b-a)^2}{12}\)</span></td>
</tr>
<tr class="odd">
<td>指数分布 <span class="math inline">\(\exp(\lambda)\)</span></td>
<td><span class="math inline">\(\lambda\mathrm e^{-\lambda
x}\)</span></td>
<td><span class="math inline">\(1-\mathrm e^{-\lambda x}\)</span></td>
<td><span class="math inline">\(\frac{1}{\lambda}\)</span></td>
<td><span class="math inline">\(\frac{1}{\lambda^2}\)</span></td>
</tr>
<tr class="even">
<td>卡方分布 <span class="math inline">\(\chi^2(n)\)</span></td>
<td>(Holy crap)</td>
<td>(Nope)</td>
<td><span class="math inline">\(n\)</span></td>
<td><span class="math inline">\(2n\)</span></td>
</tr>
<tr class="odd">
<td>t 分布 <span class="math inline">\(t(n)\)</span></td>
<td>(Don't do it)</td>
<td>(Gone)</td>
<td><span class="math inline">\(0\)</span></td>
<td>(?)</td>
</tr>
<tr class="even">
<td>F 分布 <span class="math inline">\(F(n_1,n_2)\)</span></td>
<td>(Well...)</td>
<td>(Sank)</td>
<td>(U guess)</td>
<td>(lol)</td>
</tr>
<tr class="odd">
<td>伽马分布 <span
class="math inline">\(\Gamma(\alpha,\beta)\)</span></td>
<td>(LMAO)</td>
<td>(Blown)</td>
<td><span class="math inline">\(\frac{\alpha}{\beta}\)</span></td>
<td><span class="math inline">\(\frac{\alpha}{\beta^2}\)</span></td>
</tr>
</tbody>
</table>
<h5 id="正态分布">正态分布</h5>
<p><span class="math inline">\(X_i\)</span> 独立分布于 <span
class="math inline">\(N(\mu_i,\sigma_i^2)\)</span>，<span
class="math inline">\(Z=\sum_{i}a_iX_i \sim N(\sum_ia_i\mu_i,
\sum_ia_i^2\sigma_i^2)\)</span></p>
<h5 id="卡方分布">卡方分布</h5>
<p><span class="math inline">\(\chi^2(2)\sim
\exp(\frac{1}{2})\)</span></p>
<p><span class="math inline">\(Z_1\sim\chi^2(n_1)\)</span>，<span
class="math inline">\(Z_2 \sim \chi^2(n_2)\)</span>，<span
class="math inline">\(Z_1+Z_2\sim \chi^2(n_1+n_2)\)</span></p>
<p><span class="math inline">\(X_1,X_2,\cdots, X_n\)</span> 独立同分布于
<span class="math inline">\(N(0,1)\)</span>，<span
class="math inline">\(\sum_{i=1}^n X_i^2 \sim \chi^2(n)\)</span></p>
<p><span class="math inline">\(X_1,X_2,\cdots, X_n\)</span> 独立同分布于
<span class="math inline">\(N(\mu,\sigma^2)\)</span>，<span
class="math inline">\(\frac{1}{\sigma^2}\sum_{i=1}^n (X_i-\mu)^2 \sim
\chi^2(n)\)</span></p>
<h5 id="t-分布">t 分布</h5>
<p><span class="math inline">\(\lim_{n\to\infty}t(n)\to
N(0,1)\)</span></p>
<p><span class="math inline">\(X\sim N(0,1)\)</span>，<span
class="math inline">\(Y\sim \chi^2(n)\)</span>，<span
class="math inline">\(T=\frac{X}{\sqrt{Y/n}}\sim t(n)\)</span></p>
<h5 id="f-分布">F 分布</h5>
<p><span class="math inline">\(X\sim \chi^2(n_1)\)</span>，<span
class="math inline">\(Y\sim \chi^2(n_2)\)</span>，<span
class="math inline">\(F=\frac{X/n_1}{Y/n_2}\sim F(n_1, n_2)\)</span></p>
<h4 id="二维连续分布">二维连续分布</h4>
<h5 id="二维正态分布">二维正态分布</h5>
<p><span
class="math inline">\(N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\)</span></p>
<p>其中 <span class="math inline">\(\rho\)</span> 为 <span
class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>
的相关系数，<span class="math inline">\(X\sim
N(\mu_1,\sigma_1^2)\)</span>，<span class="math inline">\(Y\sim
N(\mu_2,\sigma_2^2)\)</span></p>
<h5 id="二维均匀分布">二维均匀分布</h5>
<p><em>Soo EZ</em></p>
<h3 id="大数定律">大数定律</h3>
<h4 id="伯努利大数定律">伯努利大数定律</h4>
<p>对于伯努利试验</p>
<p><span class="math display">\[
\lim_{n\to\infty}\left\{\left|\frac{\eta_n}{n}-p\right|&lt;\varepsilon\right\}=1
\]</span> 切比雪夫大数定律在伯努利试验下的特殊情况</p>
<h4 id="切比雪夫大数定律">切比雪夫大数定律</h4>
<p>两两不相关序列且方差一致有界，<span class="math inline">\(\forall\
\varepsilon &gt;0\)</span></p>
<p><span class="math display">\[
\lim_{n\to\infty}P\left\{\left|
\frac{1}{n}\sum_{i=1}^{n}X_i
-
\frac{1}{n}\sum_{i=1}^{n}E(X_i)
\right|\geq\varepsilon\right\}=0
\]</span></p>
<h4 id="独立同分布大数定律">独立同分布大数定律</h4>
<p>切比雪夫大数定律在独立同分布下的特殊情况</p>
<h4 id="辛钦大数定律">辛钦大数定律</h4>
<p><span class="math inline">\(\{X_n\}\)</span> 独立同分布且期望 <span
class="math inline">\(\mu\)</span> 存在有界（不要求方差存在），则 <span
class="math inline">\(\overline{X_n}\stackrel{P}{\longrightarrow}
\mu\)</span></p>
<h4 id="中心极限定理">中心极限定理</h4>
<p><span class="math inline">\(\{X_n\}\)</span> 独立同分布，期望 <span
class="math inline">\(\mu\)</span>、方差 <span
class="math inline">\(\sigma^2\)</span> 存在</p>
<p><span class="math display">\[
\lim_{n\to\infty}P\left\{
\frac{\sum_{i=1}^n X_i-n\mu}{\sqrt{n}\sigma}
\leq x\right\}
=
\Phi(x)
\]</span></p>
<h2 id="数理统计">数理统计</h2>
<h3 id="统计量">统计量</h3>
<p>设样本 <span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>
为总体 <span class="math inline">\(X\)</span> 的样本</p>
<h4 id="样本均值">样本均值</h4>
<p><span class="math display">\[
\overline X=\frac{1}{n}\sum_{i=1}^{n}X_i
\]</span></p>
<p>若总体具有二阶矩，<span class="math inline">\(E(\overline
X)=\mu\)</span>，<span class="math inline">\(D(\overline
X)=\frac{\sigma^2}{n}\)</span></p>
<p>是 <span class="math inline">\(\mu\)</span> 的无偏估计量</p>
<p><span class="math inline">\(\overline X^2\)</span> 是 <span
class="math inline">\(\mu^2\)</span> 的渐进无偏估计量</p>
<h4 id="样本方差">样本方差</h4>
<p><span class="math display">\[
S^2=\frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline X)^2 =
\frac{1}{n-1}\left[\sum_{i=1}^n X_i^2-n\overline X ^2\right]
\]</span></p>
<p>若总体具有二阶矩，<span
class="math inline">\(E(S^2)=\sigma^2\)</span></p>
<p>是 <span class="math inline">\(\sigma^2\)</span> 的无偏估计量</p>
<h4 id="样本标准差">样本标准差</h4>
<p><span class="math display">\[
S=\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline X)^2}
\]</span></p>
<h4 id="样本-k-阶原点矩">样本 k 阶原点矩</h4>
<p><span class="math display">\[
A_k=\frac{1}{n}\sum_{i=1}^{n}X_i^k
\]</span></p>
<p>是 <span class="math inline">\(\alpha_k\)</span> 的无偏估计量</p>
<h4 id="样本-k-阶中心矩">样本 k 阶中心矩</h4>
<p><span class="math display">\[
B_k=\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline X)^k
\]</span></p>
<p><span class="math inline">\(B_2\)</span> 是 <span
class="math inline">\(\sigma^2\)</span> 的渐进无偏估计量</p>
<h4 id="次序统计量">次序统计量</h4>
<p><span class="math display">\[
X_{(1)},X_{(2)},\cdots ,X_{(n)}
\]</span></p>
<h4 id="样本极差">样本极差</h4>
<p><span class="math display">\[
X_{(n)}-X_{(1)}
\]</span></p>
<h3 id="正态总体抽样">正态总体抽样</h3>
<p>设 <span class="math inline">\((X_1,X_2,\cdots, X_n)\)</span>
是来自正态总体 <span class="math inline">\(N(\mu,\sigma^2)\)</span>
的样本</p>
<ul>
<li><span class="math inline">\(\overline X\sim
N\left(\mu,\frac{\sigma^2}{n}\right)\)</span></li>
<li><span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim
\chi^2(n-1)\)</span></li>
<li><span class="math inline">\(\overline X\)</span> 与 <span
class="math inline">\(X^2\)</span> 独立</li>
<li><span class="math inline">\(T=\frac{\sqrt n (\overline
X-\mu)}{S}\sim t(n-1)\)</span></li>
</ul>
<p>设 <span class="math inline">\((X_1,X_2,\cdots, X_n)\)</span>
是来自正态总体 <span class="math inline">\(N(\mu_1,\sigma_1^2)\)</span>
的样本， <span class="math inline">\((Y_1,Y_2,\cdots, Y_n)\)</span>
是来自正态总体 <span class="math inline">\(N(\mu_2,\sigma_2^2)\)</span>
的样本 <span class="math display">\[
F=\frac{S_{1n_1}^2/\sigma_1^2}{S_{2n_2}^2/\sigma_2^2}\sim F(n_1-1,n_2-1)
\]</span> 且 <span class="math display">\[
T=\frac{(\overline X-\overline Y)-(\mu_1-\mu_2)}{S_W\sqrt{\frac{1}{n_1}
+ \frac{1}{n_2}}}
\sim
t(n_1+n_2-2)
\]</span> 其中 <span class="math display">\[
S_W=\frac{(n_1-1)S_{1n_1}^2+(n_2-1)S_{2n_2}^2}{n_1+n_2-2}
\]</span></p>
<h3 id="点估计">点估计</h3>
<h4 id="矩估计">矩估计</h4>
<p>有 <span class="math inline">\(k\)</span> 个未知参数时，求 <span
class="math inline">\(k\)</span> 阶原点矩 <span
class="math inline">\(\alpha_k\)</span> 和样本 <span
class="math inline">\(k\)</span> 阶原点矩 <span
class="math inline">\(A_k\)</span>；矩法方程 <span
class="math inline">\(A_k=\alpha_k\)</span></p>
<h4 id="极大似然估计">极大似然估计</h4>
<p>观测值 <span
class="math inline">\((x_1,x_2,\cdots,x_n)\)</span>，似然函数 <span
class="math inline">\(L(\theta_1,\theta_2,\cdots,\theta_l)=\prod_{i=1}^n
f(x_i;\theta_1,\theta_2,\cdots,\theta_l)\)</span></p>
<p>取对数求导求使似然函数最大的参数</p>
<h3 id="估计量性质">估计量性质</h3>
<h4 id="无偏性">无偏性</h4>
<p><span class="math display">\[
E(\hat \theta)=\theta
\]</span></p>
<p>渐进无偏性 <span
class="math inline">\(\lim_{n\to\infty}E(\hat\theta)=\theta\)</span></p>
<h4 id="有效性">有效性</h4>
<p><span class="math display">\[
D(\hat\theta_1)\leq D(\hat\theta_2)
\]</span></p>
<p>则 <span class="math inline">\(\theta_1\)</span> 较 <span
class="math inline">\(\hat\theta_2\)</span> 有效</p>
<h4 id="相合性">相合性</h4>
<p>相和估计量</p>
<p><span class="math display">\[
\hat\theta\stackrel{P}{\longrightarrow}\theta
\]</span> 或 <span class="math inline">\(\forall\ \varepsilon
&gt;0\)</span>，<span
class="math inline">\(\lim_{n\to\infty}P\{|\hat\theta -
\theta|&lt;\varepsilon\} = 0\)</span></p>
<p>均方相和估计量</p>
<p><span class="math display">\[
\hat\theta\stackrel{L^2}{\longrightarrow}\theta
\]</span> 或 <span
class="math inline">\(\lim_{n\to\infty}E^2(\hat\theta-\theta) =
0\)</span></p>
<p>相合估计量的函数是参数的函数的相合估计</p>
<h3 id="置信区间">置信区间</h3>
<h4 id="分位数">分位数</h4>
<p>上侧 <span class="math inline">\(\alpha\)</span> 分位数 <span
class="math inline">\(x_\alpha\)</span> <span class="math display">\[
P\{X&gt;x_\alpha\}=1-F(x_\alpha)=\alpha
\]</span></p>
<h4 id="置信区间-1">置信区间</h4>
<figure>
<img src="/images/ProbAndStatCourse/interval.jpg" alt="置信区间" />
<figcaption aria-hidden="true">置信区间</figcaption>
</figure>
<h4 id="置信上下界">置信上下界</h4>
<p><em>（明明是同一张表……）</em></p>
<figure>
<img src="/images/ProbAndStatCourse/limits.jpg" alt="置信上下界" />
<figcaption aria-hidden="true">置信上下界</figcaption>
</figure>
<h3 id="假设检验">假设检验</h3>
<p>原假设 <span class="math inline">\(H_0\)</span>，备择假设 <span
class="math inline">\(H_1\)</span></p>
<p>拒绝域：拒绝 <span class="math inline">\(H_0\)</span>
的范围；接受域：接受 <span class="math inline">\(H_0\)</span> 的范围</p>
<p>I 类错误概率 <span class="math inline">\(\alpha(\mu)=P\{\text{
rejects}H_0|H_0\text{ is true}\}\)</span></p>
<p>II 类错误概率 <span class="math inline">\(\beta(\mu)=P\{\text{
accepts}H_0|H_0\text{ is false}\}\)</span></p>
<p>显著性检验：犯第一类错误概率小于显著性水平 <span
class="math inline">\(\alpha\)</span></p>
<figure>
<img src="/images/ProbAndStatCourse/test.jpg" alt="假设检验" />
<figcaption aria-hidden="true">假设检验</figcaption>
</figure>
<h4 id="方差未知且不等的均值检验">方差未知且不等的均值检验</h4>
<p>一般先检验 <span
class="math inline">\(\sigma_1^2=\sigma_2^2\)</span>，题就有得做了</p>
<p><del>否则自行思考，然后发现没法做，继续睡觉</del></p>
<p>或者在大样本条件 <span class="math inline">\(n_1\gg 1\)</span>，<span
class="math inline">\(n_2 \gg 1\)</span> 下</p>
<p>统计量 <span class="math display">\[
U=\frac{(\overline X-\overline
Y)-c}{\sqrt{\dfrac{S_{1n_1}^2}{n_1}+\dfrac{S_{2n_2}^2}{n_2}}}
\longrightarrow
U(0,1)
\]</span></p>
<h4 id="下均值已知的方差检验">下均值已知的方差检验</h4>
<p>样本 <span class="math inline">\(X_i\)</span>，<span
class="math inline">\(Y_i\)</span> 来自总体已知均值分别为 <span
class="math inline">\(\mu_1\)</span>，<span
class="math inline">\(\mu_2\)</span> 的分布</p>
<p><span class="math inline">\(H_0\)</span>：<span
class="math inline">\(\frac{\sigma_1^2}{\sigma_2^2}=c\)</span>，有统计量
<span class="math display">\[
F=\frac{\frac{1}{n_1}\sum(X_i-\mu_1)^2}{c\frac{1}{n_2}\sum(Y_i-\mu_2)^2}
\sim F(n_1,n_2)
\]</span></p>
<h2 id="随机过程">随机过程</h2>
<h3 id="随机过程-1">随机过程</h3>
<p>称随机变量族</p>
<p><span class="math display">\[
\{X(t,\omega),t\in T,\omega\in \Omega\}
\]</span> 为<strong>随机过程</strong></p>
<p>固定 <span class="math inline">\(\omega\)</span> 时随机过程 <span
class="math inline">\(X(\ \cdot\ ,\omega)\)</span>
称为<strong>样本函数</strong></p>
<p><span class="math inline">\(T\in \mathbb{R}\)</span>
称为<strong>指标集</strong>（参数集）</p>
<p><span class="math inline">\(\mathscr R(X)\)</span>
称为<strong>状态集</strong></p>
<h3 id="有限维分布族">有限维分布族</h3>
<p>固定一个随机过程的一组 <span class="math inline">\(t\)</span>
得到一个随机变量族，分布函数 <span class="math display">\[
F_X(x_1,x_2,\cdots;t_1,t_2,\cdots,t_n)=P\left(\bigcap_i\{X(t_i)\leq
x_i\}\right)
\]</span> 称为<strong>有限维分布族</strong></p>
<h3 id="随机过程数字特征">随机过程数字特征</h3>
<h4 id="均值函数">均值函数</h4>
<p><span class="math display">\[
m_X(t)=E(X(t))
\]</span></p>
<h4 id="方差函数">方差函数</h4>
<p><span class="math display">\[
D_X(t)=D(X(t))
\]</span></p>
<h4 id="自协方差函数">自协方差函数</h4>
<p><span class="math display">\[
C_X(t_1,t_2)=\mathrm{Cov}(X(t_1),X(t_2))
\]</span></p>
<h4 id="自相关函数">自相关函数</h4>
<p><span class="math display">\[
R_X(t_1,t_2)=E(X(t_1)X(t_2))
\]</span></p>
<h4 id="互协方差函数">互协方差函数</h4>
<p><span class="math display">\[
C_{XY}(t_1,t_2)=\mathrm{Cov}(X(t_1),Y(t_2))
\]</span></p>
<h4 id="互相关函数">互相关函数</h4>
<p><span class="math display">\[
R_{XY}(t_1,t_2)=E(X(t_1)Y(t_2))
\]</span></p>
<h3 id="随机过程分类">随机过程分类</h3>
<h4 id="二阶矩过程">二阶矩过程</h4>
<p>均值和方差对于任意参数均存在</p>
<h5 id="正态过程高斯过程">正态过程（高斯过程）</h5>
<p>任意有限维分布均为多维正态分布 <span class="math display">\[
f(\boldsymbol x;\boldsymbol t)=(2\pi)^{-\frac{n}{2}}|\boldsymbol
C|^{-\frac{1}{2}}
\exp\left(-\frac{1}{2}(\boldsymbol x-\boldsymbol m)^\mathrm T\boldsymbol
C^{-1}(\boldsymbol x-\boldsymbol m)\right)
\]</span> 其中</p>
<p><span class="math display">\[
\begin{align}
\boldsymbol m&amp;=(m_X(t_1),m_X(t_2),\cdots,m_X(t_n))^{\mathrm T}
\nonumber
\\
\boldsymbol C&amp;=
\begin{bmatrix}
C_X(t_1,t_1) &amp; C_X(t_1,t_2) &amp; \cdots &amp; C_X(t_1,t_n) \newline
C_X(t_2,t_1) &amp; C_X(t_2,t_2) &amp; \cdots &amp; C_X(t_2,t_n) \newline
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline
C_X(t_n,t_1) &amp; C_X(t_n,t_2) &amp; \cdots &amp; C_X(t_n,t_n) \newline
\end{bmatrix} \nonumber
\end{align}
\]</span></p>
<h5 id="正交增量过程">正交增量过程</h5>
<p>若 <span class="math inline">\(T=\{t|t&gt;0\}\)</span>，<span
class="math inline">\(X(0)=0\)</span>，<span
class="math inline">\(s&lt;t\)</span></p>
<p>有 <span class="math inline">\(R_X(s,t)=E(X^2(s))\)</span></p>
<p>相关函数只与开始时刻有关</p>
<h4 id="独立增量过程">独立增量过程</h4>
<p>对与任意时间列，增量两两不相关</p>
<h5 id="平稳独立增量过程">平稳独立增量过程</h5>
<p>增量的概率分布与此增量开始时刻无关</p>
<h4 id="马尔可夫过程">马尔可夫过程</h4>
<p>某一时刻将来的分布与之前时刻的分布无关</p>
<h4 id="计数过程">计数过程</h4>
<p>计数过程 <span class="math inline">\(N(t)\)</span> 表示时间 <span
class="math inline">\([0,t)\)</span> 内随机事件 <span
class="math inline">\(A\)</span> 发生的次数</p>
<ul>
<li><span class="math inline">\(N(t)\in \mathbb{N}\)</span></li>
<li><span class="math inline">\(\forall\ 0&lt;s&lt;t\ ,\ N(s)\leq
N(t)\)</span></li>
</ul>
<h5 id="泊松过程">泊松过程</h5>
<p>满足如下条件的计数过程 <span class="math inline">\(N(t)\)</span></p>
<ol type="1">
<li><span class="math inline">\(N(0)=0\)</span></li>
<li>独立增量</li>
<li><span
class="math inline">\(P\{N(t+s)-N(s)=k\}=P\{N(t)=k\}\)</span>（增量平稳性）</li>
<li><em>出现的概率与时间成<del>伪</del>线性</em>：<span
class="math inline">\(P\{N(t+\Delta t)-N(t)=1\}=\lambda\Delta t-\mathrm
o(\Delta t)\)</span></li>
<li><em>同一时刻不会冒出两个来</em>：<span
class="math inline">\(P\{N(t+\Delta t)-N(t)\geq 2\}=\mathrm o(\Delta
t)\)</span></li>
</ol>
<p>称为强度为 <span class="math inline">\(\lambda\)</span>
的泊松过程</p>
<p><strong><em>泊松分布性质</em></strong> <span class="math display">\[
P\{N(t)=k\}=\frac{(\lambda t)^k}{k!}\mathrm e^{-\lambda t}
\]</span> <strong><em>到达时间性质</em></strong></p>
<p><span class="math inline">\(S_n\)</span> 表示第 <span
class="math inline">\(n\)</span> 件事发生的时刻</p>
<p><span class="math display">\[
f_{S_n}(t)=
\begin{cases}
\frac{\lambda(\lambda t)^{n-1}}{(n-1)!}\mathrm e^{-\lambda t} &amp;,\
t&gt;0 \newline
0 &amp;,\ t\leq 0
\end{cases}
\]</span></p>
<p>特别的，<span class="math inline">\(S_1\sim
\exp(\lambda)\)</span>，且时间间隔序列 <span
class="math inline">\(T_i\)</span> 独立同分布于 <span
class="math inline">\(\exp(\lambda)\)</span>，这也是计数过程是齐次泊松过程的充要条件</p>
<h4 id="布朗运动维纳过程">布朗运动/维纳过程</h4>
<p>定义 <span class="math inline">\({W(t),t&gt;0}\)</span> 满足</p>
<ol type="1">
<li><span class="math inline">\(W(0)=0\)</span></li>
<li>是独立增量过程</li>
<li><span class="math inline">\(W(t)-W(s)\sim
N(0,\sigma^2|t-s|)\)</span></li>
</ol>
<p>性质：</p>
<ul>
<li>是平稳独立增量过程</li>
<li>是正态过程</li>
<li><span class="math inline">\(m_W(t)=0\)</span>，<span
class="math inline">\(C_W(s,t)=R_W(s,t)=\sigma^2\min\{s,t\}\)</span></li>
</ul>
<h3 id="均方意义下连续">均方意义下连续</h3>
<p><span class="math display">\[
\lim_{\Delta t\to 0}E((X(t_0+t)-X(t_0))^2)=0
\]</span></p>
<p>记作</p>
<p><span class="math display">\[
\mathop{\mathrm{l.i.m.}}\limits_{\Delta t\to 0} X(t+\Delta t)=X(t)
\]</span></p>
<h3 id="平稳过程">平稳过程</h3>
<h4 id="严平稳过程">严平稳过程</h4>
<p>任何有限维分布函数不随时间推移（在参数集上平移）改变</p>
<h4 id="宽平稳过程">宽平稳过程</h4>
<p>均值函数是常数；自相关函数 <span
class="math inline">\(R_X(t_1,t_2)\)</span> 只是时间差 <span
class="math inline">\(\tau=t_2-t_1\)</span> 的函数 <span
class="math inline">\(R_X(\tau)\)</span></p>
<p>即一阶矩与二阶矩不随时间推移改变</p>
<h5 id="白噪声序列">白噪声序列</h5>
<p>自相关函数仅在 <span class="math inline">\(\tau=0\)</span> 为 <span
class="math inline">\(\sigma^2\)</span>，否则为零</p>
<h5 id="宽平稳过程的性质">宽平稳过程的性质</h5>
<ul>
<li><span class="math inline">\(R_X(\tau)=R_X(-\tau)\)</span></li>
<li><span class="math inline">\(|R_X(\tau)|\leq R_X(0)\)</span>，<span
class="math inline">\(|C_X(\tau)|\leq
C_X(0)\)</span>（由柯西不等式推导）</li>
<li><span class="math inline">\(R_X(\tau)\)</span> 非负定</li>
</ul>
<h4 id="平稳相关">平稳相关</h4>
<p><span class="math inline">\(X\)</span>，<span
class="math inline">\(Y\)</span> 是两个平稳过程，若 <span
class="math inline">\(R_{XY}(t,t+\tau)=E(X(t)Y(t+\tau))=R_{XY}(\tau)\)</span>，则称其平稳相关</p>
<p>互协方差函数、互相关函数性质与自协方差函数、自相关函数类似</p>
<h4 id="各态历经性">各态历经性</h4>
<p><em>必须是平稳过程哦</em></p>
<h5 id="时间均值">时间均值</h5>
<p><span class="math display">\[
\overline{X(t)}=\lim_{T\to+\infty}\frac{1}{2T}\int_{-T}^T X(t)\mathrm dt
\]</span></p>
<p>它是一个随机变量，那么有期望和方差如下</p>
<p><span class="math display">\[
\begin{align}
E(\overline{X(t)})&amp;=m_X \nonumber\newline
D(\overline{X(t)})&amp;=\lim_{T\to+\infty}\frac{1}{T}\int_{0}^{2T}
\left(1-\frac{\tau}{2T}\right)(R_X(\tau)-m_X^2)\mathrm d\tau \nonumber
\end{align}
\]</span></p>
<h5 id="时间相关函数">时间相关函数</h5>
<p><span class="math display">\[
\overline{X(t)X(t+\tau)}=\lim_{T\to+\infty}\frac{1}{2T}\int_{-T}^T
X(t)X(t+\tau)\mathrm dt
\]</span></p>
<p>它是一个随机过程，且参数仅为 <span
class="math inline">\(\tau\)</span>，可写作 <span
class="math inline">\(\overline{Y_{\tau}(t)}\)</span>，<strong><em>说明时间相关函数是状态集表示时间均值的随机过程！</em></strong></p>
<p>而且当 <span class="math inline">\(\tau\)</span> 固定时，<span
class="math inline">\(Y_{\tau}(t)\)</span>
是一个平稳过程，有自相关函数与均值<del>函数</del>如下（注意平稳过程的均值函数是常数）</p>
<p><span class="math display">\[
\begin{align}
R_{Y_{\tau}}(\tau_1)=R_\tau(\tau_1)=E(X(t)X(t+\tau)X(t+\tau_1)X(t+\tau_1+\tau))
\nonumber\newline
m_{Y_{\tau}}=R_X(\tau)\nonumber
\end{align}
\]</span></p>
<p>那么随机过程 <span
class="math inline">\(Y(\tau)=\overline{Y_{\tau}(t)}\)</span>
的均值函数和方差函数如下</p>
<p><span class="math display">\[
\begin{align}
m_Y(\tau)&amp;=E(Y(\tau))=R_X(\tau) \nonumber\newline
D_Y(\tau)&amp;=D(Y(\tau))=\lim_{T\to+\infty}\frac{1}{T}\int_{0}^{2T}
\left(1-\frac{\tau_1}{2T}\right)(R_\tau(\tau_1)-R_X^2(\tau))\mathrm
d\tau_1\nonumber
\end{align}
\]</span></p>
<h5 id="均值各态历经性">均值各态历经性</h5>
<p>定义 <span class="math display">\[
P\left\{\overline{X(t)} = E(X(t)) = m_X\right\}=1
\]</span> 充要条件 <span
class="math inline">\(D\left(\overline{X(t)}\right)=0\)</span></p>
<p>充分条件 <span
class="math inline">\(\lim_{\tau\to\infty}R_X(\tau)=m_X^2\)</span>，即无穷远不相关</p>
<h5 id="自相关函数各态历经性">自相关函数各态历经性</h5>
<p>定义 <span class="math display">\[
P\left\{\overline{X(t)X(t+\tau)} = E(X(t)X(t+\tau)) =
R_X(\tau)\right\}=1
\]</span> 充要条件 <span class="math inline">\(D_Y(\tau)\equiv
0\)</span>（但注意 <span class="math inline">\(Y(\tau)\)</span>
不是平稳过程，<span class="math inline">\(m_Y(\tau)\)</span>
也不是常数）</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉与模式识别</title>
    <url>/2022/06/17/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言考试前"><del>前言（考试前）</del></h2>
<p>开始复习 CVPR 的时候 CVPR
大佬，你交校友孙剑博士去世了，RIP。以后无论水平高低出身贵贱，都得先养好身体。</p>
<p>这门课的老师是苏远歧老师，由于之前在 UPenn
带同一门课所以基本可以算高端课程的减负版（但是相比之下还是作业很多<del>笑死</del>），想要上课学本事的非常建议选！</p>
<h2 id="前言考试后"><del>前言（考试后）</del></h2>
<p><strong>快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑快跑vvvvvv</strong></p>
<h2 id="前言出分了">前言（出分了）</h2>
<p>竟然意外地不错。</p>
<p>看来老师 Norm 了（笑）。</p>
<h2 id="符号版式说明">符号版式说明</h2>
<p>考虑到排版规范和编写便利性、可读性，后文的符号版式说明如下</p>
<ol type="1">
<li>矩阵是斜体大写字母 <span class="math inline">\(A,B,C,R,H_{3\times
3},P,I_3,\cdots\)</span></li>
<li>集合也是斜体大写字母，但是用的不多，上下文判断吧</li>
<li>向量是粗体小写字母 <span class="math inline">\(\boldsymbol
{x},\boldsymbol {v},\boldsymbol {d},\cdots\)</span></li>
<li>标量是斜体小写字母 <span
class="math inline">\(a,b,c,x,y,z,u,v,w,\cdots\)</span></li>
<li>向量展开可以写成如 <span class="math inline">\((x,y,z,1)^T\)</span>
的元组形式，也可以写成矩阵形式 <span
class="math inline">\(\begin{bmatrix}x &amp;y &amp;
z\end{bmatrix}^T\)</span></li>
<li>矩阵乘法写成 <span class="math inline">\(AB\)</span>、<span
class="math inline">\(A\boldsymbol x\)</span>、<span
class="math inline">\(\boldsymbol{y}^T\boldsymbol{x}\)</span>
等，向量点乘写作 <span class="math inline">\(\boldsymbol{y}\cdot
\boldsymbol{x}\)</span></li>
<li><span
class="math inline">\(A^{-T}=(A^{-1})^T\)</span>，即逆的转置</li>
</ol>
<h2 id="数学知识">数学知识</h2>
<p>三维向量的叉积 <span class="math inline">\(\boldsymbol v=\boldsymbol
{v_1}\times \boldsymbol {v_2}\)</span>
垂直（点乘为零）于两个向量，长度为正弦，方向符合右手法则；设 <span
class="math inline">\(\boldsymbol{\hat\imath},\boldsymbol{\hat\jmath},\boldsymbol{\hat
k}\)</span> 为正交基、计算如下： <span class="math display">\[
\begin{aligned}
\boldsymbol v=\boldsymbol {v_1}\times \boldsymbol {v_2}
&amp; =
(x,y,z)^T\times(u,v,w)^T \\
&amp; =
\begin{vmatrix}
\boldsymbol{\hat\imath} &amp; \boldsymbol{\hat\jmath}
&amp;\boldsymbol{\hat k} \\
x &amp; y &amp; z \\
u &amp; v &amp; w
\end{vmatrix} \\
&amp; =
[v_\times]\boldsymbol{v_2}\\
&amp; =
\begin{bmatrix}
0 &amp; -z &amp; y \\
z &amp; 0 &amp; -x \\
-y &amp; x &amp; 0
\end{bmatrix}
\boldsymbol {v_2}
\end{aligned}
\]</span> 其中 <span class="math inline">\([v_\times]\)</span> 为 <span
class="math inline">\(\boldsymbol {v_1}\)</span>
的叉积矩阵，是反对称矩阵，它把叉积运算转换为矩阵乘法运算方便推导</p>
<p>QR 分解即 <span class="math inline">\(A=QR\)</span>，将矩阵 <span
class="math inline">\(A\)</span> 分解为上三角矩阵 <span
class="math inline">\(R\)</span> 和正交矩阵 <span
class="math inline">\(Q\)</span>（<span
class="math inline">\(Q^T=Q^{-1}\)</span>）</p>
<p>矩阵导数参照表（<span class="math inline">\(\boldsymbol x\)</span>
为列向量，且其导数与其同形状）：</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(L\)</span></th>
<th><span class="math inline">\(\dfrac{\partial L}{\partial \boldsymbol
x}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\boldsymbol x^T A \boldsymbol
x\)</span></td>
<td><span class="math inline">\(\boldsymbol x^T(A+A^T)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\boldsymbol a^T\boldsymbol
x\)</span></td>
<td><span class="math inline">\(\boldsymbol a\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\boldsymbol x^T \boldsymbol
a\)</span></td>
<td><span class="math inline">\(\boldsymbol a^T\)</span></td>
</tr>
</tbody>
</table>
<p>SVD 分解（奇异值分解）即 <span
class="math inline">\(A=USV^T\)</span>，设 <span
class="math inline">\(A_{m\times n}\)</span> 的秩为 <span
class="math inline">\(r\)</span>，有 <span
class="math inline">\(U_{m\times m}\)</span> 为正交矩阵，<span
class="math inline">\(S_{m\times n}\)</span> 为有 <span
class="math inline">\(r\)</span> 个非零值（奇异值 <span
class="math inline">\(\sigma_i\)</span>）的对角矩阵，<span
class="math inline">\(V_{n\times n}\)</span> 为正交矩阵</p>
<p>最小二乘问题 <span class="math inline">\(\|A\boldsymbol
x\|^2\)</span></p>
<ul>
<li>伪逆解法：<span class="math inline">\(\boldsymbol
x=(A^TA)^{-1}A^T\boldsymbol b\)</span></li>
<li>SVD 解法：设 <span class="math inline">\(A\)</span> 的 SVD 分解
<span class="math inline">\(A=USV^T\)</span>，则 <span
class="math inline">\(V\)</span> 的最后一列“最可能”是一个零解</li>
</ul>
<h2 id="基础知识">基础知识</h2>
<p>由于考试不考默写，所以懂就行了，比如图像是正则化网格点上的离散函数
<span class="math inline">\(I(x,y)\)</span>
啦，分辨率、位深、图像种类啦，认识就行。</p>
<h2 id="相机模型和应用">相机模型和应用</h2>
<h3 id="小孔成像模型和摄像机内参">小孔成像模型和摄像机内参</h3>
<p><strong>光心</strong>（<strong>摄像机中心</strong>）是小孔，作为原点；<strong>投影平面</strong>（成像平面）在原点的
<span class="math inline">\(Z\)</span>
轴正方向（<strong>主方向</strong>）处，垂直于 <span
class="math inline">\(Z\)</span>
轴（<strong>主轴</strong>）；<strong>主平面</strong>过光心平行于投影平面，<strong>主点</strong>是是主轴和投影平面的交点</p>
<ul>
<li>摄像机坐标到像平面坐标 <span
class="math inline">\((x,y,z)\to(u_{CCD},v_{CCD})=(x\cdot f_m/z, y\cdot
f_m/z)\)</span></li>
<li>像平面坐标到像素坐标 <span
class="math inline">\((u_{CCD},v_{CCD})\to(u_{img}, v_{img})=(x\cdot
f_x/z+p_x, y\cdot f_y/z+p_y)\)</span></li>
</ul>
<p>对于像素坐标中像素计量的焦距 <span
class="math inline">\(f_x\)</span>，有 <span
class="math inline">\(f_x=f_m\cdot w_{img}/w_{CCD}\)</span>；<span
class="math inline">\(f_y\)</span> 同理</p>
<p>齐次坐标 <span
class="math inline">\(\lambda(x,y,1),\lambda&gt;0\)</span>：投影方向的射线，透视空间中的点</p>
<p>摄像机坐标（测度空间）到像素齐次坐标（透视空间）的透视投影变换 <span
class="math display">\[
\lambda \begin{bmatrix} u_{img} \\ v_{img} \\ 1 \end{bmatrix}
=
\begin{bmatrix}
f_x &amp; &amp; p_x \\
&amp; f_y &amp; p_y \\
&amp; &amp; 1
\end{bmatrix}
\begin{bmatrix}x \\ y \\ z\end{bmatrix}
\triangleq
K\boldsymbol x
\]</span> 其中 <span class="math inline">\(K\)</span> 为内参矩阵</p>
<p>径向畸变模型：假设归一化的像平面坐标 <span
class="math inline">\(\boldsymbol{\bar u_{undistorted}}=K^{-1}
u\)</span>（即测度空间坐标）到主点到距离 <span
class="math inline">\(\rho=\|\boldsymbol {\bar
u_{undistorted}}\|\)</span>，那么畸变后的对应坐标满足 <span
class="math display">\[
\begin{cases}
\boldsymbol{\bar u_{distorted}} = L(\rho) \boldsymbol{\bar
u_{undistorted}} \\
L(\rho) = 1 + k_1 \rho^2 + k_2 \rho^4 + \cdots
\end{cases}
\]</span></p>
<h3 id="世界坐标和摄像机外参">世界坐标和摄像机外参</h3>
<p>世界坐标 <span class="math inline">\(\boldsymbol
{x_W}=(x,y,z)^T\)</span> 到摄像机坐标 <span
class="math inline">\(\boldsymbol{x_C}=(u,v,w)^T\)</span> 的旋转矩阵
<span class="math inline">\({^CR_W}\)</span> 定义如下 <span
class="math display">\[
\boldsymbol{x_C}=\begin{bmatrix}
{r_x}_1 &amp; {r_x}_2 &amp; {r_x}_3 \\
{r_y}_1 &amp; {r_y}_2 &amp; {r_y}_3 \\
{r_z}_1 &amp; {r_z}_2 &amp; {r_z}_3 \\
\end{bmatrix}
\boldsymbol {x_W}
=\begin{bmatrix}
\boldsymbol{r_x} \\
\boldsymbol{r_y} \\
\boldsymbol{r_z} \\
\end{bmatrix}
\boldsymbol {x_W}
\triangleq
{^CR_W}\boldsymbol {x_W}
\]</span> 旋转矩阵只有三个自由度 <span class="math inline">\({^CR_W}\in
SO(3)\)</span>；旋转矩阵是正交矩阵，<span
class="math inline">\({^CR_W}^T{^CR_W}=I_3\)</span>；旋转矩阵的每一行是世界坐标看摄像机坐标的坐标轴方向，每一列是摄像机坐标看世界坐标的坐标轴方向</p>
<p>摄像机在世界坐标内的平移 <span
class="math inline">\(\boldsymbol{^Ct}\)</span>：摄像机坐标看世界坐标原点到摄像坐标原点的位移
<span class="math display">\[
\boldsymbol{x_C}=
{^CR_W}\boldsymbol {x_W}+\boldsymbol{^Ct}=
\begin{bmatrix}
{r_x}_1 &amp; {r_x}_2 &amp; {r_x}_3 &amp; t_x \\
{r_y}_1 &amp; {r_y}_2 &amp; {r_y}_3 &amp; t_y \\
{r_z}_1 &amp; {r_z}_2 &amp; {r_z}_3 &amp; t_z \\
\end{bmatrix}
\begin{bmatrix}
\boldsymbol {x_W} \\
1
\end{bmatrix}
=
\begin{bmatrix}
{^CR_W} &amp; \boldsymbol{^Ct}
\end{bmatrix}
\begin{bmatrix}
\boldsymbol {x_W} \\
1
\end{bmatrix}
\]</span> 透视投影矩阵 <span
class="math inline">\(P=K\begin{bmatrix}{^CR_W} &amp;
\boldsymbol{^Ct}\end{bmatrix}\)</span></p>
<h3 id="摄像机标定">摄像机标定</h3>
<blockquote>
<p>摄像机标定的任务是通过图像，获得摄像机的内参和对应各图像的外参</p>
</blockquote>
<h4 id="齐次几何">齐次几何</h4>
<p>二维空间中，齐次坐标点表示为 <span class="math inline">\(\boldsymbol
p = (u,v,1)^T\)</span></p>
<ul>
<li>二维空间中的直线齐次坐标表示 <span class="math inline">\(\boldsymbol
l^T\boldsymbol p=0\)</span>，其中 <span
class="math inline">\(\boldsymbol l = (a,b,c)^T\)</span>，<span
class="math inline">\(\boldsymbol l \in SO(2)\)</span> 是齐次的</li>
<li>过两点 <span class="math inline">\(\boldsymbol {p_1}\)</span>，<span
class="math inline">\(\boldsymbol {p_2}\)</span> 的直线有 <span
class="math inline">\(\boldsymbol l=\boldsymbol {p_1}\times \boldsymbol
{p_2}\)</span>（因为 <span class="math inline">\(\boldsymbol {p_1}\times
\boldsymbol {p_2}\perp \boldsymbol {p_1}\wedge \boldsymbol {p_1}\times
\boldsymbol {p_2}\perp \boldsymbol {p_2}\)</span>）</li>
<li>两直线 <span class="math inline">\(\boldsymbol {l_1}\)</span>，<span
class="math inline">\(\boldsymbol {l_2}\)</span> 的交点是 <span
class="math inline">\(\boldsymbol l=\boldsymbol {l_1}\times \boldsymbol
{l_2}\)</span></li>
</ul>
<p>三维空间中，齐次坐标点表示为 <span class="math inline">\(\boldsymbol
p = \lambda(x,y,z,1)^T=(x&#39;,y&#39;,z&#39;,w)^T\)</span></p>
<ul>
<li>三维空间的线 <span class="math inline">\(\boldsymbol p=\boldsymbol
{p_1}+k(\boldsymbol {p_2}-\boldsymbol {p_1})\)</span></li>
<li>三维空间的平面 <span class="math inline">\(\boldsymbol\pi \cdot
\boldsymbol p=0\)</span>，其中 <span
class="math inline">\(\boldsymbol\pi=(a,b,c,d)^T\)</span>，法向量为
<span class="math inline">\((a,b,c)^T\)</span></li>
<li>三维齐次坐标无穷远点表示为 <span class="math inline">\(x&#39;\neq0
\vee y&#39;\neq 0 \vee z&#39;\neq 0\)</span> 且 <span
class="math inline">\(w=0\)</span>，相当于平行线交点</li>
</ul>
<h4 id="消失点解旋转矩阵">消失点解旋转矩阵</h4>
<p>对世界坐标系中三个特殊无穷远点（三个轴方向的无穷远点），可以列三个方程解出旋转矩阵</p>
<p>设透视投影矩阵 <span class="math display">\[
P=K\begin{bmatrix}{^CR_W} &amp;
\boldsymbol{^Ct}\end{bmatrix}=\begin{bmatrix}
p_{11} &amp; p_{12} &amp; p_{13} &amp; p_{14} \\
p_{21} &amp; p_{22} &amp; p_{23} &amp; p_{24} \\
p_{31} &amp; p_{32} &amp; p_{33} &amp; p_{34} \\
\end{bmatrix}
\]</span></p>
<p>假设三个特殊无穷远点经透视投影后的透视空间坐标为 <span
class="math inline">\(\boldsymbol{p_{X\infty}}\)</span>，<span
class="math inline">\(\boldsymbol{p_{Y\infty}}\)</span>，<span
class="math inline">\(\boldsymbol{p_{Z\infty}}\)</span> <span
class="math display">\[
\begin{aligned}
\boldsymbol{p_{X\infty}}&amp;=
\lambda\begin{bmatrix}{u_x}\\{v_x}\\1\end{bmatrix}
=
\begin{bmatrix}
p_{11} &amp; p_{12} &amp; p_{13} &amp; p_{14} \\
p_{21} &amp; p_{22} &amp; p_{23} &amp; p_{24} \\
p_{31} &amp; p_{32} &amp; p_{33} &amp; p_{34} \\
\end{bmatrix}
\begin{bmatrix}
\infty\\
0\\
0\\
1
\end{bmatrix}
\\
&amp;\Longrightarrow
\begin{cases}
u_x=\displaystyle\lim_{X\to\infty}\dfrac{p_{11}X+p_{14}}{p_{31}X+p_{34}}=\dfrac{p_{11}}
{p_{31}}\\
v_x=\displaystyle\lim_{X\to\infty}\dfrac{p_{21}X+p_{24}}{p_{31}X+p_{34}}=\dfrac{p_{21}}
{p_{31}}\\
\end{cases}
\\
&amp;\Longrightarrow
\lambda\begin{bmatrix}{u_x}\\{v_x}\\1\end{bmatrix}=\begin{bmatrix}p_{11}\\p_{21}\\p_{31}\end{bmatrix}
\end{aligned}
\]</span> 则通过三个消失点解得 <span
class="math inline">\(p_{11},p_{21},p_{31},p_{12},p_{22},p_{32},p_{13},p_{23},p_{33}\)</span>，再结合已知的内参矩阵解得旋转矩阵</p>
<h4 id="单应矩阵">单应矩阵</h4>
<p>世界坐标的一个平面，可表示为平面上的点满足 <span
class="math display">\[
\boldsymbol v=v_1\boldsymbol b_1+v_2\boldsymbol b_2+\boldsymbol
c=\begin{bmatrix}\boldsymbol b_1 &amp;\boldsymbol b_2 &amp;\boldsymbol
c\end{bmatrix}
\begin{bmatrix}
v_1\\ v_2\\ 1
\end{bmatrix}
\]</span> 假设在世界坐标系里 <span class="math inline">\(\boldsymbol
{b_1}=\boldsymbol {\hat\imath}\)</span>，<span
class="math inline">\(\boldsymbol {b_1}=\boldsymbol
{\hat\jmath}\)</span>，<span class="math inline">\(\boldsymbol
c=\boldsymbol 0\)</span> 那么上述式子可以表示世界坐标的 XY 平面</p>
<p>将世界坐标平面投影到像素空间的单应矩阵 <span
class="math inline">\(H\in SO(8)\)</span>，<span
class="math inline">\((u_x,u_y,1)^T=H(v_x,v_y,1)^T\)</span> <span
class="math display">\[
H=
K\begin{bmatrix}R\boldsymbol b_1 &amp; R\boldsymbol b_2 &amp;
R\boldsymbol c+\boldsymbol{t}\end{bmatrix}
=
\begin{bmatrix}
h_{11} &amp; h_{12} &amp; h_{13} \\
h_{21} &amp; h_{22} &amp; h_{23} \\
h_{31} &amp; h_{32} &amp; h_{33} \\
\end{bmatrix}
\]</span> 对于一张图像，有图像上的像素点 <span
class="math inline">\(u_x,u_y\)</span>，设定的平面点 <span
class="math inline">\(v_x,v_y\)</span> 可列出 <span
class="math display">\[
\begin{aligned}
&amp;\begin{cases}
u_x = \dfrac{h_{11}v_x+h_{12}v_y+h_{13}}{h_{31}v_x+h_{32}v_y+h_{33}}\\
u_y = \dfrac{h_{21}v_x+h_{22}v_y+h_{23}}{h_{31}v_x+h_{32}v_y+h_{33}}\\
\end{cases}
\\
&amp;\Longrightarrow
\\
&amp;\begin{bmatrix}
v_x &amp; v_y &amp; 1 &amp; &amp; &amp; -v_xu_x &amp; -v_yu_x &amp;
-u_x\\
&amp; &amp; &amp; v_x v_y &amp; 1 &amp; -v_xu_y &amp; -v_yu_y &amp;
-u_y\\
\end{bmatrix}
\begin{bmatrix}
h_{11} \\ h_{12} \\ h_{13} \\
h_{21} \\ h_{22} \\ h_{23} \\
h_{31} \\ h_{32} \\ h_{33} \\
\end{bmatrix}
=0
\end{aligned}
\]</span> 四个点即可解出 Homography（假设其中一个值为一即可），且若
<span class="math inline">\(\boldsymbol v\)</span> 位于 XY 平面（Z
分量为零），有 <span class="math display">\[
H=K\begin{bmatrix}
{r_x}_1 &amp; {r_x}_2 &amp; t_x \\
{r_y}_1 &amp; {r_y}_2 &amp; t_y \\
{r_z}_1 &amp; {r_z}_2 &amp; t_z \\
\end{bmatrix}
\]</span> 对 <span class="math inline">\(H\)</span> 进行 Givens
分解可得到一个上三角矩阵 <span class="math inline">\(K\)</span>
和正交旋转矩阵 <span class="math inline">\(R\)</span> 的估计</p>
<h4 id="张正友标定">张正友标定</h4>
<p>此节的 <span class="math inline">\(h_1,h_2,h_3,r_1,r_2,t\)</span>
都是向量，忽略了粗体</p>
<p>以标定版为世界坐标，已知单应矩阵 <span
class="math inline">\(H=\begin{bmatrix}h_1 &amp; h_2 &amp;
h_3\end{bmatrix}\)</span>，且有 <span
class="math inline">\(H=K\begin{bmatrix}r_1 &amp;r_2 &amp;
t\end{bmatrix}\)</span>，有 <span class="math display">\[
K^{-1}\begin{bmatrix}h_1 &amp; h_2 &amp;
h_3\end{bmatrix}=\begin{bmatrix}r_1 &amp; r_2 &amp; t\end{bmatrix}
\Longrightarrow
\begin{cases}
r_1=K^{-1} h_1\\
r_2=K^{-1}h_2\\
t=K^{-1}h_3
\end{cases}
\]</span> 由于 <span class="math inline">\(r_1,r_2\)</span> 是旋转矩，有
<span class="math inline">\(r_1^Tr_2=0\)</span>，<span
class="math inline">\(\|r_1\|=\|r_2\|\)</span>，得 <span
class="math display">\[
\begin{cases}
h_1^TK^{-T}K^{-1}h_2=0\\
h_1^TK^{-T}K^{-1}h_1=h_1^TK^{-T}K^{-1}h_1
\end{cases}
\]</span> <span class="math inline">\(K^{-T}K^{-1}\)</span> 未知，记为
<span class="math display">\[
B=
\begin{bmatrix}
b_1 &amp; &amp; b_2 \\
&amp; b_1 &amp; b_3 \\
b_2 &amp; b_3 &amp; b_4
\end{bmatrix}
=K^{-T}K^{-1} =
\begin{bmatrix}
1/f &amp; &amp; \\
&amp; 1/f &amp; \\
-p_x/f &amp; -p_y/f &amp; 1
\end{bmatrix}
\begin{bmatrix}
1/f &amp; &amp;  -p_x/f\\
&amp; 1/f &amp; -p_y/f \\
&amp;  &amp; 1
\end{bmatrix}
\]</span> 将满足的条件 <span class="math inline">\(h_1^TBh_2=0\)</span>
展开并区分未知量，可以列出 <span class="math display">\[
\begin{bmatrix}
h_{11}h_{12}+h_{21}h_{22} &amp; h_{11}h_{32}+ h_{31}h_{12} &amp;
h_{21}h_{32}+h_{31}h_{22} &amp; h_{31}h_{32}\\
\end{bmatrix}
\begin{bmatrix}
b_1 \\ b_2 \\ b_3 \\ b_4
\end{bmatrix}=0
\]</span> 将满足的条件 <span
class="math inline">\(h_1^TBh_1=h_2^TBh_2\)</span>
展开并区分未知量，可以列出 <span class="math display">\[
\begin{bmatrix}
h_{11}^2-h_{12}^2+h_{21}^2-h_{22}^2 &amp; 2(h_{11}h_{31}-h_{12}h_{32})
&amp; 2(h_{21}h_{31}-h_{22}h_{32}) &amp; h_{31}^2-h_{32}^2
\end{bmatrix}
\begin{bmatrix}
b_1 \\ b_2 \\ b_3 \\ b_4
\end{bmatrix}=0
\]</span> 每幅图像可以得到上述两个方程，两幅图像即可求得 <span
class="math inline">\(B\)</span>，进而得到内参矩阵 <span
class="math inline">\(K\)</span>；获得内参后可求得 <span
class="math inline">\(r_1,r_2,t\)</span>，用 <span
class="math inline">\(\|K^{-1}h_1\|\)</span>
除，归一化得旋转矩阵和平移向量</p>
<h3 id="三角化">三角化</h3>
<blockquote>
<p>三角化点任务是通过两个或多个已经标定的摄像机，求三维空间中一个点的坐标</p>
</blockquote>
给定透视投影矩阵 <span class="math inline">\(P_{Alice}\)</span>，<span
class="math inline">\(P_{Bob}\)</span>，给定世界坐标中一点 <span
class="math inline">\(\boldsymbol x\)</span>，给定该点的两个投影 <span
class="math inline">\(\boldsymbol u\)</span>，<span
class="math inline">\(\boldsymbol v\)</span>，有 $$
<span class="math display">\[\begin{bmatrix}
u_x \\ u_y \\ 1
\end{bmatrix}\]</span>
=P_{Bob}
<span class="math display">\[\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}\]</span>
=
<span class="math display">\[\begin{bmatrix}
\boldsymbol p_{Bob}^{1T} \\
\boldsymbol p_{Bob}^{2T} \\
\boldsymbol p_{Bob}^{3T} \\
\end{bmatrix}
\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}
\Longrightarrow\]</span>
<span class="math display">\[\begin{bmatrix}
\boldsymbol p_{Bob}^{1T} - u_x \boldsymbol p_{Bob}^{3T} \\
\boldsymbol p_{Bob}^{2T} - u_y \boldsymbol p_{Bob}^{3T} \\
\end{bmatrix}
\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}\]</span>
<p>= $$ 再用 Alice 的透视投影矩阵即可获得点的世界坐标</p>
<h3 id="单视测量">单视测量</h3>
<blockquote>
<p>单视测量的任务是通过一张图片和先验知识，获得图像中的线段对应的实际距离</p>
</blockquote>
<p><strong>交比</strong>是透视投影前后不变的性质：对一条线段上的四个顺序点
<span class="math inline">\(A,B,C,D\)</span>，有 <span
class="math display">\[
\frac{\overline{AC}}{\overline{BC}}\cdot
\frac{\overline{BD}}{\overline{AD}}
\]</span> 在透视投影变换后不变</p>
<p>单视测量的基本流程是：找参照长度，找消失点，连平行线，找另一个消失点，连线得到四个点，用无穷远和参照长度代入计算</p>
<h3 id="双视几何">双视几何</h3>
<blockquote>
<p>双视几何的任务是获得两个拍摄者的相对位置（又叫对极几何）</p>
</blockquote>
<p>Bob 的光心 <span class="math inline">\(\boldsymbol {c_{Bob}}\)</span>
在 Alice 图像平面的投影 <span class="math inline">\(\boldsymbol
{e_{Alice}}\)</span> 称为 Alice
的<strong>极点</strong>（Epipole）。给定世界坐标的一个点 <span
class="math inline">\(\boldsymbol x\)</span>，对应 Bob 图像中的一个点
<span class="math inline">\(\boldsymbol u\)</span>，在 Alice
的图像中对应一条线称为<strong>极线</strong> <span
class="math inline">\(\boldsymbol {l_u}\)</span>；同理有 Alice
图像中的点 <span class="math inline">\(\boldsymbol v\)</span> 和 Bob
的极线 <span class="math inline">\(\boldsymbol{l_{v}}\)</span></p>
<p><img src="EpipolarGeo.png" alt="EpipolarGeo.png" style="zoom: 33%;" /></p>
<p>设世界坐标和 Bob 的相机坐标相同，Bob 的透视投影矩阵 <span
class="math inline">\(P_B=K\begin{bmatrix}I_{3\times3} &amp; \boldsymbol
0\end{bmatrix}\)</span>，Alice 的透视投影矩阵 <span
class="math inline">\(P_A=K\begin{bmatrix}R &amp; \boldsymbol
t\end{bmatrix}\)</span>，则</p>
<ol type="1">
<li>Bob 的光心世界坐标 <span class="math inline">\(\boldsymbol
{c_{Bob}}=\boldsymbol 0\)</span></li>
<li>Alice 的光心世界坐标 <span class="math inline">\(\boldsymbol
{c_{Alice}}=-R^T\boldsymbol t\)</span></li>
<li>Alice 的极点 <span class="math inline">\(\boldsymbol
{e_{Alice}}=KP_A\begin{bmatrix}\boldsymbol{c_{Bob}} \\
1\end{bmatrix}=\boldsymbol Kt\)</span>（在 Alice 相机坐标）</li>
<li>Bob 的极点 <span class="math inline">\(\boldsymbol
{e_{Bob}}=KP_B\begin{bmatrix}\boldsymbol{c_{Alice}} \\
1\end{bmatrix}=-KR^T\boldsymbol t\)</span>（在 Bob 相机坐标）</li>
</ol>
<p><strong>基础矩阵</strong> <span class="math inline">\(F\)</span> 满足
<span class="math inline">\(\boldsymbol v^TF\boldsymbol
u=0\)</span>；下面推导基础矩阵如何用上述未知外参表示</p>
<ul>
<li>世界坐标上，Bob 的极点方向射线 <span class="math inline">\(\lambda
K^{-1}\boldsymbol {e_{Bob}}=\lambda_1R^T \boldsymbol t\)</span></li>
<li>在世界坐标上，Alice 的 <span class="math inline">\(\boldsymbol
v\)</span> 方向射线 <span class="math inline">\(-R^T\boldsymbol
t+\lambda_2R^TK^{-1}\boldsymbol v\)</span></li>
</ul>
<p>上述的两条射线位于同一个平面<strong>极平面</strong>，那么极平面的法线
<span class="math inline">\(\boldsymbol n\)</span> 满足 <span
class="math display">\[
\begin{aligned}
\boldsymbol n
&amp;=
(R^T \boldsymbol t)\times(-R^T\boldsymbol
t+\lambda_2R^TK^{-1}\boldsymbol v)
\\
&amp;=
\lambda_2 (R^T \boldsymbol t)\times( R^TK^{-1}\boldsymbol v)
\\
&amp;\equiv (R^T \boldsymbol t)\times (R^TK^{-1}\boldsymbol v)
\\&amp;=
R^T (\boldsymbol t\times K^{-1}\boldsymbol v)
\\&amp;=
R^T [t_\times] K^{-1}\boldsymbol v
\end{aligned}
\]</span> Bob 的极线 <span
class="math inline">\(\boldsymbol{l_v}=K^{-T}\boldsymbol n=K^{-T}R^T
[t_\times] K^{-1}\boldsymbol v\)</span></p>
<p>由于对极几何约束，<span class="math inline">\(\boldsymbol u\)</span>
在 Bob 的极线上，那么 <span class="math display">\[
\begin{aligned}
&amp;\boldsymbol u^T\boldsymbol {l_v}=0
\\&amp;\Longrightarrow
\boldsymbol u^TK^{-T}(R^T [t_\times] )K^{-1}\boldsymbol v = 0
\\&amp;\Longrightarrow
\boldsymbol v^TK^{-T}(-[t_\times]R)K^{-1}\boldsymbol u = 0
\\&amp;\Longrightarrow
\boldsymbol v^TK^{-T}[t_\times]RK^{-1}\boldsymbol u = 0
\\&amp;\Longrightarrow
F=K^{-T}[t_\times]RK^{-1}
\end{aligned}
\]</span> 由于 <span class="math inline">\(\boldsymbol v^TF\boldsymbol
u=0\)</span>，则在两个图像中找出八个点对，即可列出关于 <span
class="math inline">\(F\)</span> 的八个方程，求解得基础矩阵的值</p>
<p>基础矩阵的性质：</p>
<ul>
<li>基础矩阵的转置对应了 Alice，Bob 互换</li>
<li>极线方程 <span class="math inline">\(\boldsymbol {l_u}=F\boldsymbol
u\)</span>，<span class="math inline">\(\boldsymbol {l_v}=F^T\boldsymbol
v\)</span></li>
<li>极点方程 <span class="math inline">\(F\boldsymbol
{e_{Bob}}=0\)</span>，<span class="math inline">\(F^T\boldsymbol
{e_{Alice}}=0\)</span></li>
</ul>
<p><strong>本质矩阵</strong>即世界坐标上两个投影点的关系矩阵，<span
class="math inline">\(E=[t_\times]R=K^TFK\)</span></p>
<p>下面通过本质矩阵求 <span
class="math inline">\(R,t\)</span>。对反对称矩阵分解可得 <span
class="math display">\[
[t_{\times}]=U\begin{bmatrix}
0 &amp; 1 &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}U^T
\]</span> 其中 <span class="math inline">\(U\)</span> 是正交矩阵，定义
<span class="math inline">\(R=UWV^T\)</span> 那么 <span
class="math display">\[
E=U\begin{bmatrix}
0 &amp; 1 &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}U^TUWV^T
=
U\begin{bmatrix}
0 &amp; 1 &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}WV^T
\]</span> 又有 <span class="math inline">\(E\)</span> 的 SVD 分解（因为
<span class="math inline">\(R\in SO(3)\)</span>，<span
class="math inline">\(\mathrm
{rank}(R)=2\)</span>，且易证线性变换尺度不变） <span
class="math display">\[
E=U\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}V^T
\]</span> 那么 <span class="math inline">\(W\)</span> 有两种可能取值
<span class="math display">\[
W=
\begin{cases}
\begin{bmatrix}
0 &amp; 1 &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\\
\begin{bmatrix}
0 &amp; -1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\end{cases}
\]</span> 终于，因为可以对 <span class="math inline">\(E\)</span> 使用
SVD 分解获得 <span class="math inline">\(U\)</span> 和 <span
class="math inline">\(V\)</span>，那么将 <span
class="math inline">\(W\)</span> 的两种值代入即可获得 <span
class="math inline">\(R\)</span> 的两种可能值</p>
<p>设 <span class="math inline">\(U=\begin{bmatrix}\boldsymbol {u_1}
&amp;\boldsymbol {u_2} &amp;\boldsymbol {u_3}\end{bmatrix}\)</span>，有
<span class="math inline">\(\boldsymbol t=\pm \boldsymbol
{u_{3}}\)</span>（证明似乎很复杂）</p>
<p>那么，<span class="math inline">\(R\)</span> 和 <span
class="math inline">\(\boldsymbol t\)</span>
均有两个取值，共四个取值都需要被验证一下，其中三个都无法使图像内包含同一个点的投影</p>
<h2 id="数字图像处理">数字图像处理</h2>
<h3 id="几何变换">几何变换</h3>
<p>给定输入图像 <span class="math inline">\(I\)</span> 上的点 <span
class="math inline">\((x,y)\)</span>，输出图像 <span
class="math inline">\(O\)</span> 的对应点 <span
class="math inline">\((x&#39;,y&#39;)\)</span>，有 <span
class="math inline">\(I(x,y)=O(x&#39;,y&#39;)\)</span>，几何变换 <span
class="math inline">\(G:R^2\to R^2\)</span> 是它们之间的映射 <span
class="math inline">\(G(x,y)=(x&#39;,y&#39;)\)</span></p>
<p>原图像绕 <span class="math inline">\((x_0,y_0)\)</span> 逆时针旋转
<span class="math inline">\(\theta\)</span> 角度 <span
class="math display">\[
\begin{bmatrix}
x&#39;\\y&#39;
\end{bmatrix}
=\begin{bmatrix}
\cos \theta &amp; -\sin\theta \\
\sin\theta &amp; \cos\theta
\end{bmatrix}
\left(
\begin{bmatrix}
x\\y
\end{bmatrix}
-\begin{bmatrix}
x_0\\y_0
\end{bmatrix}
\right)
+\begin{bmatrix}
x_0\\y_0
\end{bmatrix}
\]</span> 离散点上实施变换的方法：</p>
<ul>
<li>前向变换（不好）：遍历输入图像的点，应用映射，绘制对应输出图像的点</li>
<li>后向变换（好）：遍历输出图像的点，应用逆映射，得到原图像中的像素值</li>
</ul>
<p>后向变换的插值：最近邻、双线性、双三次</p>
<p>双线性插值：找四个近邻点画框，分为四个方形，每个角落的权值为对面方形的面积</p>
<p>通过对应点对求解仿射变换 <span class="math inline">\(\boldsymbol
u=A_{2\times 2}\boldsymbol v+\boldsymbol
b\)</span>：共六个参数，三个点对最小二乘即可</p>
<h3 id="灰度变换">灰度变换</h3>
<p><span class="math inline">\(O(x,y)=T(I(x,y))\)</span>，其中 <span
class="math inline">\(T\)</span>
为灰度变换，和位置无关；常用查找表实现</p>
<p>给定连续的灰度变换函数 <span
class="math inline">\(t=T(s)\)</span>，针对灰度区间 <span
class="math inline">\([s_1,s_2]\)</span></p>
<ul>
<li>如果 <span
class="math inline">\(|T(s_2)-T(s_1)|&gt;|s_2-s_2|\)</span>，则该区间的灰度等级被扩展</li>
<li>如果 <span
class="math inline">\(|T(s_2)-T(s_1)|&lt;|s_2-s_2|\)</span>，则该区间的灰度等级被压缩</li>
</ul>
<p>幂律变换 <span class="math inline">\(t=s^{\gamma}\)</span>（<span
class="math inline">\(s\in[0,1]\)</span>），<span
class="math inline">\(\gamma\)</span>
大于一时变暗，小于一时类似对数变换；CRT 显示器自带一个 <span
class="math inline">\(\gamma\approx 2.2\)</span>
的幂律变换，所以要应用一个 <span
class="math inline">\(\gamma=1/2.2\)</span> 的伽马校正</p>
<p>灰度直方图 <span class="math inline">\(p_s=\dfrac{n_s}{\sum_s
n_s}\)</span>，其中 <span class="math inline">\(n_s\)</span> 是值为
<span class="math inline">\(s\)</span> 的像素出现的频次</p>
<p>直方图均衡：</p>
<ol type="1">
<li>求 CDF <span class="math inline">\(c_s=\sum_{i=0}^{s}
p_i\)</span></li>
<li>灰度变换函数 <span class="math inline">\(t=T(s)=Round((\max
-\min)\times c_s+\min)\)</span></li>
</ol>
<h3 id="空间滤波">空间滤波</h3>
<p>模版运算：给定输入图像 <span class="math inline">\(I(x,y)\)</span>
定义在 <span class="math inline">\(X\times Y\)</span> 大小的空间，<span
class="math inline">\(f(x,y)\)</span> 定义在 <span
class="math inline">\((2m+1)\times (2n+1)\)</span> 大小的空间 <span
class="math display">\[
O(x,y)=\sum_{a=-m} ^{m}\sum_{b=-n}^n I(x+a,y+b)f(a,b)
\]</span> 输出尺寸：</p>
<ul>
<li>全尺寸 <span class="math inline">\((X+2m)\times(Y+2n)\)</span></li>
<li>同等尺寸 <span class="math inline">\(X\times Y\)</span></li>
<li>有效尺寸 <span
class="math inline">\((X-2m)\times(Y-2n)\)</span></li>
</ul>
<p>常用 Padding：0、拷贝、反射、循环</p>
<p>数学上的二维卷积即模版上下左右翻转</p>
<p>模版运算的性质</p>
<ul>
<li>可加性 <span class="math inline">\(f\otimes (h_1+h_2)=f\otimes h_1 +
f\otimes h_2\)</span></li>
<li>线性 <span class="math inline">\(f\otimes (kh)=k(f\otimes
h)\)</span></li>
<li>可交换性 <span class="math inline">\(f\otimes h = h\otimes
f\)</span>，注意输出尺寸</li>
</ul>
<p>高斯模板 <span
class="math inline">\(\exp\left(-\dfrac{x^2+y^2}{2\sigma^2}\right)\)</span></p>
<p>Sobel 算子 <span
class="math inline">\(\begin{bmatrix}-1&amp;0&amp;1\end{bmatrix}\)</span>
和 <span
class="math inline">\(\begin{bmatrix}-1&amp;0&amp;1\end{bmatrix}^T\)</span></p>
<h3 id="频域变换">频域变换</h3>
<h4 id="dft">DFT</h4>
<p>离散傅里叶变换 DFT 的形式 <span class="math display">\[
F(x,y)=\sum_{u=1}^X\sum_{v=1}^Y I(u,v)
\exp\left(-2\pi \jmath \frac{(u-1)(x-1)}{X}\right)
\exp\left(-2\pi \jmath \frac{(v-1)(y-1)}{Y}\right)
\]</span> 逆变换的形式 <span class="math display">\[
I(u,v)=
\frac{1}{XY}
\sum_{x=1}^X\sum_{y=1}^Y F(x,y)
\exp\left(-2\pi \jmath \frac{(u-1)(x-1)}{X}\right)
\exp\left(-2\pi \jmath \frac{(v-1)(y-1)}{Y}\right)
\]</span> DFT
一般把变换完的图像，四个象限各自内外反转，来把低频放在中间</p>
<h4 id="dct">DCT</h4>
<p>离散余弦变换 DCT 的形式 <span class="math display">\[
F(u,v)=
\alpha_u\alpha_v
\sum_{x=1}^{X-1}\sum_{y=1}^{Y-1} I(x,y)
\cos\left(\frac{\pi(2x+1)u}{2X}\right)
\cos\left(\frac{\pi(2y+1)v}{2Y}\right)
\]</span> 逆变换的形式 <span class="math display">\[
I(u,v)=
\sum_{x=1}^{X-1}\sum_{y=1}^{Y-1} \alpha_u\alpha_v F(x,y)
\cos\left(-\frac{\pi(2x+1)u}{2X}\right)
\cos\left(-\frac{\pi(2y+1)v}{2Y}\right)
\]</span> 其中 <span class="math display">\[
\begin{aligned}
\alpha_u&amp;=\begin{cases}
1/\sqrt{X}, &amp;u=0 \\
\sqrt{2}/\sqrt{X}, &amp; 1\le u\le X-1
\end{cases}
\\
\alpha_v&amp;=\begin{cases}
1/\sqrt{Y}, &amp;v=0 \\
\sqrt{2}/\sqrt{Y}, &amp; 1\le v\le Y-1
\end{cases}
\end{aligned}
\]</span> DCT 的解释：每个像素是一个权重图像逐点乘整个图像</p>
<p>DCT 计算分离：可以先对 Y 轴 DCT 再对 X 轴 DCT</p>
<p>矩阵计算 DCT：</p>
<ul>
<li>构造矩阵 <span class="math inline">\(A\)</span> 满足 <span
class="math inline">\(A_{ij}=\alpha_i\cos(\pi(2j+1)i/(2Y))\)</span></li>
<li>构造矩阵 <span class="math inline">\(A&#39;\)</span> 满足 <span
class="math inline">\(A_{ij}=\alpha_j\cos(\pi(2i+1)j/(2X))\)</span></li>
<li>那么有 <span class="math inline">\(F=AIA&#39;\)</span>（当 <span
class="math inline">\(X=Y\)</span> 时有 <span
class="math inline">\(A&#39;=A^T\)</span>）</li>
</ul>
<h3 id="morphing">Morphing</h3>
<p>即分块线性变换加交叉溶解</p>
<p>重心坐标（Barycentric Coordinates）：<span
class="math inline">\(X=\alpha A+\beta B+\gamma C\)</span>，且 <span
class="math inline">\(\alpha + \beta + \gamma =1\)</span></p>
<h3 id="seam-carving">Seam Carving</h3>
<p>即切掉较为同质的一行或一列，做到保持物体比例的图像大小变换</p>
<p>能量矩阵即对原图像作两个方向的梯度模板运算，再求 L2 范数</p>
<p>在能量矩阵上建图，上一行的点到下一行的三个点的边权为能量矩阵值的差，DP
求最短路</p>
<h3 id="梯度融合">梯度融合</h3>
<p>即将一部分图像粘贴到另一张图像，并且保持边缘梯度一致的方法</p>
<h3 id="光流法">光流法</h3>
<blockquote>
<p>对于两张图片，它们间进行了尺度不大的几何变换，想要求对应点</p>
</blockquote>
<p>给定两张图片 <span class="math inline">\(I\)</span> 和 <span
class="math inline">\(J\)</span>，设点 <span
class="math inline">\(\boldsymbol x\)</span> 在 <span
class="math inline">\(I\)</span> 的定义域内，求 <span
class="math inline">\(J\)</span> 中 <span
class="math inline">\(\boldsymbol x\)</span> 的对应点 <span
class="math inline">\(\boldsymbol x+\boldsymbol d\)</span> 使 <span
class="math inline">\(I(\boldsymbol x)\sim J(\boldsymbol x + \boldsymbol
d)\)</span></p>
<p>设 <span class="math inline">\(E(\boldsymbol d)=\|J(\boldsymbol x +
\boldsymbol d)-I(\boldsymbol x)\|^2\)</span>，求 <span
class="math inline">\(\arg\min E(\boldsymbol d)\)</span>；泰勒展开得
<span class="math display">\[
E(\boldsymbol d)\approx\left\|
J(\boldsymbol x) + \frac{\partial J(\boldsymbol x) }{\partial
\boldsymbol x}\boldsymbol d
-I(\boldsymbol x)
\right\|
\]</span> 这里梯度向量是行向量；设右部为零以列方程，移项得 <span
class="math display">\[
\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}\boldsymbol d
=
I(\boldsymbol x)
-J(\boldsymbol x)
\]</span> 左右同乘 <span class="math inline">\(\boldsymbol x\)</span>
处梯度向量的转置得 <span class="math display">\[
\left({\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}}^T
\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}\right)
\boldsymbol d
=
{\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}}^T
(I(\boldsymbol x)
-J(\boldsymbol x))
\]</span>
虽然可以求解，但是极易尺度过小导致左右均为零，所以要在一个窗口（点集合
<span class="math inline">\(W\)</span>）上列方程求解，注意到 <span
class="math inline">\(\boldsymbol d\)</span> 在窗口内共享 <span
class="math display">\[
\sum_{\boldsymbol x\in W}
\left({\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}}^T
\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}\right)
\boldsymbol d
=
\sum_{\boldsymbol x\in W}
{\frac{\partial J(\boldsymbol x) }{\partial \boldsymbol x}}^T
(I(\boldsymbol x)
-J(\boldsymbol x))
\]</span> 求得偏移量 <span class="math inline">\(\boldsymbol d\)</span>
后，对图像做变换，然后继续迭代，累加所有的偏移量直到两图像差异小于阈值</p>
<h2 id="机器学习">机器学习</h2>
<p>和别的课程重复的部分就不整理了，包括：感知机；梯度下降；BP；CNN
的概念；YOLO/SSD 等。</p>
<h3 id="cnn">CNN</h3>
<p><em>这一小节不符合符号规范，但是在深度学习的上下文中可以理解</em></p>
<p>假设输入特征张量 <span class="math inline">\(x\)</span> 的尺寸 <span
class="math inline">\((N,C_{in},W_{in},H_{in})\)</span>，输出张量 <span
class="math inline">\(y\)</span> 的尺寸 <span
class="math inline">\((N,C_{out},W_{out},H_{out})\)</span>，卷积核 <span
class="math inline">\(h\)</span> 的尺寸 <span
class="math inline">\((C_{in}, C_{out},W_{k},H_{k})\)</span></p>
<p>假设卷积操作的 Padding 为 Same，Stride 为 1，卷积 <span
class="math inline">\(y=x\otimes h\)</span>
的运算如下（卷积核以偏移量作索引） <span class="math display">\[
y_{c_o,x,y}=
\sum_{c_i=0}^{C_{in}}
\sum_{w=-\lfloor W/2\rfloor}^{\lfloor W/2\rfloor}
\sum_{h=-\lfloor H/2\rfloor}^{\lfloor H/2\rfloor}
x_{c_i,x+w,y+h}h_{c_i,c_o,w,h}
\]</span> 假设损失函数 <span class="math inline">\(L\)</span> 对 <span
class="math inline">\(y\)</span> 对导数为 <span
class="math inline">\(\delta_y\)</span>，那么反向传播 <span
class="math display">\[
\begin{cases}
\delta_x=\delta_y\otimes ROT_{180\degree}(h) \\
\dfrac{\partial L}{\partial h} = \delta_y\otimes ROT_{180\degree}(x)
\end{cases}
\]</span> 注意到，<span class="math inline">\(ROT_{180\degree}\)</span>
表示将二维图像旋转 180 度，也是索引取反。并且若正向的 Padding 是
Full，反向的 Padding 为 None，反之亦然。</p>
<h3 id="特征提取">特征提取</h3>
<h4 id="canny-边缘检测">Canny 边缘检测</h4>
<blockquote>
<p>将图像转换为图像的方式，生成的图像中的亮点说明原图像的对应点属于边缘</p>
</blockquote>
<ol type="1">
<li>高斯滤波；</li>
<li>计算边缘强度（两个方向梯度的 L2 范数）；</li>
<li>计算边缘方向（两个方向的梯度）；</li>
<li>极大值抑制；</li>
<li>连接边缘（Hystersis）：确定两个边缘强度的阈值，从强点开始沿着切线方向搜索加入所有的中强点。</li>
</ol>
<h4 id="harris-角点检测">Harris 角点检测</h4>
<blockquote>
<p>量化当前矩形框与周边的差异，并通过特征值判断是角点还是边</p>
</blockquote>
<p>对于矩形框中一个点 <span class="math inline">\((x+m,y+n)\)</span>
和加一个任意偏置 <span class="math inline">\((u,v)\)</span> 得到的新点
<span class="math inline">\((x+m+u,y+n+v)\)</span>，它们的差异是 <span
class="math inline">\([I(x+m+u,y+n+v)-I(x+m,y+n)]^2\)</span>；对其加权求和可得这个矩形框的任意方向差异度量
<span class="math display">\[
\sum_{m,n}w(m,n)[I(x+m+u,y+n+v)-I(x+m,y+n)]^2
\]</span> 其中 <span class="math inline">\(w(m,n)\)</span>
可以是一个高斯函数来强调矩形框中心的权重。接下来提出一种不用再对 <span
class="math inline">\(u,v\)</span> 求和的方法。首先关于 <span
class="math inline">\(u,v\)</span> 进行一阶 Taylor 近似 <span
class="math display">\[
\begin{aligned}
&amp;\sum_{m,n}w(m,n)\left[\frac{\partial I(x+m,y+n)}{\partial
x}u+\frac{\partial I(x+m,y+n)}{\partial y}v\right]^2
\\\triangleq &amp;
\sum_{m,n}w(m,n)\left[I_x(x+m,y+n)u+I_y(x+m,y+n)v\right]^2
\\= &amp;
\sum_{m,n}w(m,n)
\begin{bmatrix}u &amp; v\end{bmatrix}
\begin{bmatrix}
I_x^2(x+m,y+n) &amp; I_xI_y(x+m,y+n) \\
I_xI_y(x+m,y+n) &amp; I_y^2(x+m,y+n)
\end{bmatrix}
\begin{bmatrix}u \\ v\end{bmatrix}
\\\triangleq &amp;
\sum_{m,n}w(m,n)
\begin{bmatrix}u &amp; v\end{bmatrix}
H(x+m,y+n)
\begin{bmatrix}u \\ v\end{bmatrix}
\end{aligned}
\]</span> Hessian 矩阵 <span class="math inline">\(H\)</span>
是一个二次型矩阵，可以求其两个实特征值 <span
class="math inline">\(\lambda_1\)</span>，<span
class="math inline">\(\lambda_2\)</span>；我们关注两个特征值的大小，如果两个都很大，说明两个方向都有很大的变化系数，那么是角点；如果其中一个大，那么是边缘；如果都不大，说明不是角点也不是边缘。</p>
<p>实际上操作的时候可以先滤波，就不用考虑矩形框里求和了，直接对每个点求特征值就行。</p>
<h4 id="sift-特征">SIFT 特征</h4>
<blockquote>
<p>Scale-invariant feature detection</p>
</blockquote>
<h5 id="基础概念">基础概念</h5>
<p>LoG（Laplacian of Gaussian）即高斯核的拉普拉斯函数 <span
class="math display">\[
LoG(x,y)=
\Delta G
=
\frac{\partial G^2}{\partial x^2}+\frac{\partial G^2}{\partial y^2}=
\frac{1}{\pi\sigma^4}
\left(\frac{x^2+y^2}{2\sigma^2}-1\right)
\exp\left(-\frac{x^2+y^2}{2\sigma^2}\right)
\]</span> 归一化的 LoG <span class="math inline">\(\tilde \Delta
G=\sigma LoG\)</span></p>
<p>DoG（Diffierence of Gaussian）是不同方差（<span
class="math inline">\(\sigma\)</span> 和 <span
class="math inline">\(k\sigma\)</span>）的高斯核的差，是 LoG 的高效替代
<span class="math display">\[
\begin{aligned}
\sigma\Delta G=\frac{\partial G}{\partial \sigma}
&amp;\approx
\frac{G(x,y,k\sigma)-G(x,y,\sigma)}{(k-1)\sigma}
\\
&amp;\Longrightarrow
\\
DoG(x,y)&amp;=G(x,y,k\sigma)-G(x,y,\sigma)
=
(k-1)\sigma^2 \Delta G
\end{aligned}
\]</span> ##### 步骤</p>
<p>第一步：求尺度空间的极大值</p>
<p>给定输入图像 <span
class="math inline">\(I\)</span>，先分别使用六个方差（<span
class="math inline">\(\sigma,k\sigma,\cdots,k^5\sigma\)</span>）的高斯函数对其滤波得到六张图像（等价于用
<span class="math inline">\(k^n\sqrt{k^n-1}\sigma\)</span>
做五次），对其作差得到五张 DoG图像。对 <span
class="math inline">\(I\)</span> 两倍下采样一次作同样的一组
DoG，还可以下采样更多次，得到高斯金字塔。</p>
<p>若一个点在其 DoG 的八邻域以及相邻尺度的 DoG 的八邻域这 27
个点中是极大值，那么它是一个关键点。</p>
<p>第二步：关键点筛选和插值</p>
<p>首先对 DoG 插值，来更精细地定位关键点，然后类似 Harris 作 Hessian
矩阵过滤边缘，最后做阈值筛选出特征点。</p>
<p>第三步：确定方向</p>
<p>在特征点的邻域内求所有的梯度幅值和方向进行投票，投票出 36
个离散方向中的前几个作为特征的方向。</p>
<p>第四步：求描述子</p>
<p>依据特征点的方向，取 <span class="math inline">\(16\times 16\)</span>
邻域分为 <span class="math inline">\(4\times 4\)</span> 的块，对于每块做
8 个离散方向的梯度方向直方图，则最后得到一个 128 维的描述子。</p>
<h4 id="hog-特征">HOG 特征</h4>
<blockquote>
<p>Histogram of Oriented Gradient</p>
</blockquote>
<p>给定一个图像，拆成 <span class="math inline">\(8\times8\)</span>
的格子（Cell），每个格子统计一个九个离散方向的梯度直方图</p>
<p>对于每四个邻近格子，称为一块（Block），块内做归一化</p>
<p>对于一个 <span class="math inline">\(64\times 128\)</span>
大小的图像，滑动提取块后，将会有 <span class="math inline">\(7\times
15\)</span> 个块。每个块贡献各自的梯度直方图，形成一个维数 <span
class="math inline">\(36×7\times 15=3780\)</span> 的描述子</p>
<h3 id="特征差异度量">特征差异度量</h3>
<p>当使用 Harris 或 SIFT 等方法得到两个特征点 <span
class="math inline">\((x,y)\)</span>，<span
class="math inline">\((x&#39;,y&#39;)\)</span>
对应的图像块时，可以度量这两个图像块的差异</p>
<p>SAD（Sum of Absolute Difference） <span class="math display">\[
SAD=\sum_{n=-N}^N\sum_{m=-M}^M|I_1(x+m,y+n)-I_2(x&#39;+m,y&#39;+n)|
\]</span> MSE（Mean Squared Error） <span class="math display">\[
MSE=\frac{\sum_{n=-N}^N\sum_{m=-M}^M[I_1(x+m,y+n)-I_2(x&#39;+m,y&#39;+n)]^2}
{(2N+1)(2M+1)}
\]</span> NCC（Normalized Cross Correlation） <span
class="math display">\[
NCC=\frac{\sum_{n=-N}^N\sum_{m=-M}^M[I_1(x+m,y+n)-\mu_1][I_2(x&#39;+m,y&#39;+n)-\mu_2]}
{[(2N+1)(2M+1)-1]\sigma_1\sigma_2}
\]</span></p>
<h3 id="hough-投票">Hough 投票</h3>
<blockquote>
<p>对栅格图像中直线、圆等简单几何体（参数不多）进行矢量化的一种方法</p>
</blockquote>
<p>以直线为例：对于每个点，穷举一些通过它的直线，计算这些直线通过的别的点，进行投票</p>
<h3 id="ransac">RANSAC</h3>
<blockquote>
<p>Random Sample Consensus，是一种通过数据点拟合模型的方法</p>
</blockquote>
<p>步骤</p>
<ol type="1">
<li>随机采样：取一些足够计算出模型参数的样本</li>
<li>构建模型：计算模型参数</li>
<li>过滤：使用构建的模型和阈值，筛选出符合模型的样本</li>
<li>内点计数：统计各模型符合的样本数，找出最好的模型</li>
</ol>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路需记公式集锦</title>
    <url>/2021/10/13/zh-CN/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E9%9C%80%E8%AE%B0%E5%85%AC%E5%BC%8F%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p>这个文档用来在考前清扫公式与部分定义，并不能有效地帮助理解，但是很有用</p>
<p>2021.1.7</p>
<h2 id="数学基础">数学基础</h2>
<h3 id="积化和差与和差化积">积化和差与和差化积</h3>
<p>请不要尝试记住 8 个公式，反之启发式地从以下二式推导 <span
class="math display">\[
\begin{align}
\cos(\alpha + \beta) &amp;+ \cos(\alpha - \beta)
\nonumber \newline
&amp;= \cos(\alpha)\cos(\beta)-\sin(\alpha)\sin(\beta) +
\cos(\alpha)\cos(\beta) + \sin(\alpha)\sin(\beta)
\nonumber \newline
&amp;= 2\cos(\alpha)\cos(\beta)
\nonumber \newline
\sin(\alpha+\beta) &amp;+ \sin(\alpha - \beta)
\nonumber \newline
&amp;= \sin(\alpha)\cos(\beta) + \sin(\beta)\cos(\alpha) +
\sin(\alpha)\cos(\beta) - \sin(\beta)\cos(\alpha)
\nonumber \newline
&amp;= 2\sin(\alpha)\cos(\beta)
\nonumber
\end{align}
\]</span></p>
<h3 id="周期量与复数">周期量与复数</h3>
<p>设周期量</p>
<p><span class="math display">\[
f(t) = A_m\cos\left(\frac{2\pi}{T}t+\phi\right)
= A_m\cos\left(2\pi f t+\phi\right)
= A_m\cos\left(\omega t+\phi\right)
\]</span></p>
<p>其中 <span class="math inline">\(A_m\)</span> 为最大值，<span
class="math inline">\(\omega\)</span> 为角频率，<span
class="math inline">\(\phi\)</span> 为初相角（<span
class="math inline">\(|\phi|\leq \pi\)</span>）</p>
<p>平均值 <span class="math inline">\(f_{avg} \triangleq
\frac{1}{T}\int_{t_0}^{t_0+T}|f|\mathrm dt=\frac{2}{\pi}A_m\)</span></p>
<p>有效值 <span class="math inline">\(f_{eff} \triangleq
\sqrt{\frac{1}{T}\int_{t_0}^{t_0+T}f^2\mathrm
dt}=\frac{\sqrt{2}}{2}A_m\)</span></p>
<p>周期量的复数形式 <span class="math inline">\(f(t) =
\frac{1}{2}A_m\left[\mathrm e^{\mathrm i(\omega t + \phi)} + \mathrm
e^{-\mathrm i(\omega t + \phi)}\right]\)</span></p>
<p>欧拉公式 <span class="math inline">\(\mathrm e^{\mathrm ix}=\cos x +
\mathrm i\sin x\)</span></p>
<p>极坐标形式 <span class="math inline">\(r\mathrm e^{\mathrm i \theta}
= r\angle\theta\)</span></p>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p><span class="math display">\[
f(t)=\frac{a_0}{2}+\sum_{n=1}^{\infty}\left[a_n\cos(n\omega
t)+b_n\sin(n\omega t)\right]
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\begin{align}
a_n&amp;=\frac{2}{T}\int_{t_0}^{t_0+T}f(t)\cos(n\omega t)\mathrm d t
&amp;,n\in \mathbb{Z}_+ \nonumber
\\
b_n&amp;=\frac{2}{T}\int_{t_0}^{t_0+T}f(t)\sin(n\omega t)\mathrm d t
&amp;,n\in \mathbb{Z}_+ \nonumber
\end{align}
\]</span></p>
<h3 id="二阶常系数齐次线性微分方程">二阶常系数齐次线性微分方程</h3>
<p>形式</p>
<p><span class="math display">\[
\frac{\mathrm d^2y}{\mathrm d x^2} + p\frac{\mathrm dy}{\mathrm d
x}+qy=0
\]</span></p>
<p>特征方程</p>
<p><span class="math display">\[
\lambda^2 +p\lambda + q = 0
\]</span></p>
<p>特征根 <span
class="math inline">\(\lambda_1,\lambda_2\)</span>，齐次方程通解如下</p>
<ul>
<li><p>当 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>
为一对实根： <span class="math display">\[
y(x)=C_1e^{\lambda_1 x}+C_2e^{\lambda_2 x}
\]</span></p></li>
<li><p>当 <span class="math inline">\(\lambda_1 = \lambda_2 =
\lambda\)</span>： <span class="math display">\[
y(x)=(C_1+C_2x)e^{\lambda x}
\]</span></p></li>
<li><p>当 <span class="math inline">\(\lambda = \alpha \pm \mathrm
i\beta\)</span>： <span class="math display">\[
y(x)=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x)
\]</span></p></li>
</ul>
<h2 id="等效">等效</h2>
<h3 id="y-δ-变换t-π-变换">Y-Δ 变换（T-π 变换）</h3>
<p><span class="math display">\[
\begin{align}
\text{ Y impedences} &amp;= \frac{\text{ product of adjacent} \Delta
\text{ impedences}}{\text{ sum of}\Delta \text{
impedences}}\nonumber\newline
\Delta \text{ impedences} &amp;= \frac{\text{ sum of products of Y
impedences}}{\text{ non-adjacent Y impedence}}\nonumber
\end{align}
\]</span></p>
<figure>
<img src="/images/CircuitCourse/YDelta.png" alt="Y-Delta 变换示意图" />
<figcaption aria-hidden="true">Y-Delta 变换示意图</figcaption>
</figure>
<p><span class="math display">\[
\begin{align}
R_1&amp;=\frac{R_bR_c}{R_a+R_b+R_c} \nonumber\newline
R_a&amp;=\frac{R_1R_2 +R_2R_3+R_1R_3}{R_1}\nonumber
\end{align}
\]</span></p>
<h3 id="最大功率传输定理">最大功率传输定理</h3>
<p>设负载阻抗 <span class="math inline">\(Z_L\)</span>
连接于二端口等效戴维宁电路 <span class="math inline">\(\dot U_S,
Z_S\)</span>。当 <span class="math inline">\(Z_L = Z_S^*\)</span>
时，有负载最大功率：</p>
<p><span class="math display">\[
P_{L max} = \frac{U_s^2}{4R_S}
\]</span></p>
<h2 id="电路的图">电路的图</h2>
<h3 id="最大独立方程数">最大独立方程数</h3>
<p>对结点数量 <span class="math inline">\(n\)</span>，支路数量 <span
class="math inline">\(b\)</span>，的连通图有：</p>
<p>回路电流法方程数 <span class="math inline">\(=\)</span> 独立 KVL
方程数 <span class="math inline">\(= b - (n-1)\)</span></p>
<p>结点电压法方程数 <span class="math inline">\(=\)</span> 独立 KCL
方程数 <span class="math inline">\(= n-1\)</span></p>
<h3 id="特勒根定理-2">特勒根定理 2</h3>
<p>如果两个电路的图 <span class="math inline">\(G = \hat
G\)</span>，设各支路关联参考方向电流分别为 <span
class="math inline">\((i_1, i_2, \cdots, i_b)\)</span>, <span
class="math inline">\((\hat i_1, \hat i_2, \cdots, \hat
i_b)\)</span>，电压分别为 <span class="math inline">\((u_1, u_2, \cdots,
u_b)\)</span>, <span class="math inline">\((\hat u_1, \hat u_2, \cdots,
\hat u_b)\)</span>，则有：</p>
<p><span class="math display">\[
\begin{cases}
&amp; \sum\limits_{k = 1}^b u_k \hat i_k = 0 \newline
&amp; \sum\limits_{k = 1}^b \hat u_k i_k = 0
\end{cases}
\]</span></p>
<p>由特勒根定理 2 可推出特勒根定理
1（对同一个图）、互易定理（对一对激励响应互换图）。</p>
<p>特勒根定理 2 特例：当存在纯电阻 <span
class="math inline">\(n\)</span> 端口网络 <span
class="math inline">\(N\subset
G\)</span>，其中端口关联参考方向方向电流分别为 <span
class="math inline">\((i_1, i_2, \cdots, i_n)\)</span>, <span
class="math inline">\((\hat i_1, \hat i_2, \cdots, \hat
i_n)\)</span>，电压分别为 <span class="math inline">\((u_1, u_2, \cdots,
u_n)\)</span>, <span class="math inline">\((\hat u_1, \hat u_2, \cdots,
\hat u_n)\)</span>，则有：</p>
<p><span class="math display">\[
\sum\limits_{k = 1}^n u_k \hat i_k = \sum\limits_{k = 1}^n \hat u_k i_k
\]</span></p>
<h2 id="元件性质">元件性质</h2>
<p>关联参考方向电压 <span class="math inline">\(u(t)\)</span>，电流
<span class="math inline">\(i(t)\)</span>，储能 <span
class="math inline">\(W(t)\)</span>。</p>
<h3 id="电容">电容</h3>
<p>一极板上电荷量 <span class="math inline">\(q\)</span> <span
class="math display">\[
\begin{align}
q &amp;= Cu \nonumber\newline
i &amp;= \frac{\mathrm dq}{\mathrm d t} = C \frac{\mathrm du}{\mathrm d
t} \nonumber\newline
u(t) &amp;= u(t_0) + \frac{1}{C}\int_{t_0}^{t} i(\xi) \mathrm d \xi
\nonumber\\
W(t) &amp;= \frac{1}{2}C u^2(t) \nonumber
\end{align}
\]</span> <span class="math inline">\(C_1, C_2\)</span> 串联：<span
class="math inline">\(C_{eq} =
\frac{C_1C_2}{C_1+C_2}\)</span>，并联：<span
class="math inline">\(C_{eq} = C_1 + C_2\)</span></p>
<p>阻抗 <span class="math inline">\(Z_C = \frac{1}{\mathrm j\omega
C}\)</span></p>
<h3 id="电感">电感</h3>
<p>电感磁链 <span class="math inline">\(\Psi\)</span></p>
<p><span class="math display">\[
\begin{align}
\Psi &amp;= Li \nonumber\newline
u &amp;= \frac{\mathrm d\Psi}{\mathrm d t} = L \frac{\mathrm di}{\mathrm
d t} \nonumber\newline
i(t) &amp;= i(t_0) + \frac{1}{L}\int_{t_0}^{t} u(\xi) \mathrm d
\xi\nonumber\\
W(t) &amp;= \frac{1}{2}L i^2(t)\nonumber
\end{align}
\]</span> <span class="math inline">\(L_1, L_2\)</span>串联：<span
class="math inline">\(L_{eq} = L_1 + L_2\)</span>，并联：<span
class="math inline">\(L_{eq} = \frac{L_1L_2}{L_1+L_2}\)</span></p>
<p>阻抗 <span class="math inline">\(Z_L = \mathrm j\omega L\)</span></p>
<h3 id="变压器">变压器</h3>
<p>耦合因数 <span class="math inline">\(k=\frac{M}{\sqrt{L_1L_2}} \leq
1\)</span></p>
<p>理想变压器：<span class="math inline">\(L_1,L_2 \to
\infty\)</span>，<span class="math inline">\(k = 1\)</span>，<span
class="math inline">\(n = \frac{N_1}{N_2} =
\frac{\sqrt{L_1}}{\sqrt{L_2}}\)</span></p>
<p>阻抗变换：<span class="math inline">\(Z_{11&#39;}=n^2
Z_L\)</span></p>
<h2 id="一阶电路">一阶电路</h2>
<p>RC 一阶电路，时间常数 <span class="math inline">\(\tau \triangleq
RC\)</span></p>
<p>RL 一阶电路，时间常数 <span class="math inline">\(\tau \triangleq
\frac{L}{R}\)</span></p>
<p>全响应：<span class="math inline">\(f(t) =
f(\infty)+[f(0_+)-f(\infty)]e^{-\frac{t}{\tau}}\)</span></p>
<h2 id="二阶电路">二阶电路</h2>
<h3 id="rlc-串联电路的零输入响应">RLC 串联电路的零输入响应</h3>
<p>微分方程：</p>
<p><span class="math display">\[
LC\frac{\mathrm d^2u_C}{\mathrm d t^2} + RC\frac{\mathrm du_C}{\mathrm d
t}+u_C=0
\]</span></p>
<p>特征根：</p>
<p><span class="math display">\[
p = -\frac{R}{2L}\pm \sqrt{\left(\frac{R}{2L}\right)^2-\frac{1}{LC}}
\]</span></p>
<p>形式解：</p>
<p><span class="math display">\[
\begin{cases}
&amp; u_C \text{ Over damping} &amp; , R &gt; 2\sqrt{\frac{L}{C}};
\newline
&amp; u_C \text{ Critical damping} &amp; , R = 2\sqrt{\frac{L}{C}};
\newline
&amp; u_C \text{ Underdamping} &amp; , R &lt; 2\sqrt{\frac{L}{C}}.
\end{cases}
\]</span></p>
<h3 id="利用阶跃响应求冲激响应">利用阶跃响应求冲激响应</h3>
<p>设线性电路阶跃响应 <span
class="math inline">\(s(t)\)</span>，冲激响应 <span
class="math inline">\(h(t)\)</span>，有 <span class="math inline">\(h(t)
= \frac{\mathrm d s(t)}{\mathrm d t}\)</span></p>
<h3 id="利用阶跃函数求复合阶跃响应">利用阶跃函数求复合阶跃响应</h3>
<p>求复合形式、分别求解、叠加。（卷积求解的特例）</p>
<h3 id="利用卷积求任意激励响应">利用卷积求任意激励响应</h3>
<p>设激励函数 <span class="math inline">\(e(t)\)</span>，响应 <span
class="math inline">\(r(t)\)</span>，冲激响应 <span
class="math inline">\(h(t)\)</span></p>
<p><span class="math display">\[
r(t) = e(t)*h(t) = \int_0^t e(\xi)h(t - \xi) \mathrm d\xi
\]</span></p>
<h2 id="正弦稳态电路与相量法">正弦稳态电路与相量法</h2>
<p>阻抗角 <span class="math inline">\(\phi_Z = \phi_u -
\phi_i\)</span></p>
<h3 id="功率">功率</h3>
<ul>
<li><p>有功功率 <span class="math inline">\(P \triangleq
UI\cos\phi_Z\)</span>，单位 W（瓦）；</p></li>
<li><p>无功功率 <span class="math inline">\(Q\triangleq
UI\sin\phi_Z\)</span>，单位 var（乏）；</p></li>
<li><p>视在功率 <span class="math inline">\(S\triangleq
UI\)</span>，单位 <span class="math inline">\(\mathrm V\cdot \mathrm
A\)</span>（伏安）；</p></li>
<li><p>复功率 <span class="math inline">\(\bar S \triangleq \dot U \dot
I^*=UI\angle\phi_z=P+\mathrm jQ = I^2Z=U^2Y^*\)</span>，单位 <span
class="math inline">\(\mathrm V\cdot \mathrm
A\)</span>（伏安）。</p></li>
</ul>
<p>功率因数 <span class="math inline">\(\lambda=\cos\phi_Z =
\frac{P}{S}\)</span></p>
<h3 id="谐振">谐振</h3>
<p>电流电压同相位</p>
<h4 id="rlc-串联电路谐振">RLC 串联电路谐振</h4>
<ul>
<li>谐振角频率 <span class="math inline">\(\omega_0 =
\frac{1}{\sqrt{LC}}\)</span></li>
<li>品质因数 <span class="math inline">\(Q\triangleq \frac{\omega_0
L}{R} = \frac{1}{R}\sqrt{\frac{L}{C}} = \frac{U_C(\mathrm j
\omega_0)}{U_S(\mathrm j\omega_0)}\)</span></li>
<li>带宽 <span class="math inline">\(BW\)</span>：<span
class="math inline">\(|H_R(\mathrm j\eta)|\geq
\frac{1}{\sqrt{2}}\)</span>，<span class="math inline">\(BW = \Delta
\omega = \frac{\omega_0}{Q}\)</span></li>
</ul>
<h4 id="glc-并联电路谐振">GLC 并联电路谐振</h4>
<ul>
<li>谐振角频率 <span class="math inline">\(\omega_0 =
\frac{1}{\sqrt{LC}}\)</span></li>
<li>品质因数 <span class="math inline">\(Q\triangleq \frac{\omega_0
C}{G} = \frac{1}{G}\sqrt{\frac{C}{L}} = \frac{I_L(\mathrm j
\omega_0)}{I_S(\mathrm j\omega_0)}\)</span></li>
<li>带宽 <span class="math inline">\(BW\)</span>：<span
class="math inline">\(|H_R(\mathrm j\eta)|\geq
\frac{1}{\sqrt{2}}\)</span>，<span class="math inline">\(BW = \Delta
\omega = \frac{\omega_0}{Q}\)</span></li>
</ul>
<h3 id="三相电路">三相电路</h3>
<p>三相：ABC 依次滞后 <span
class="math inline">\(\frac{2}{3}\pi\)</span></p>
<p>线电流：<span class="math inline">\(\dot I_A,\dot I_B,\dot I_C,\dot
I_N\)</span> 为输电线电流</p>
<p>线电压：<span class="math inline">\(\dot U_{AB},\dot U_{BC},\dot
U_{CA}\)</span> 为线间电压</p>
<p>相电流：<span class="math inline">\(\dot I_{AB},\dot I_{BC},\dot
I_{CA}\)</span> 为线间电流</p>
<p>相电压：<span class="math inline">\(\dot U_A,\dot U_B,\dot
U_C\)</span> 为线到中性线电压</p>
<p>二瓦计法：<span class="math inline">\(P=\mathrm{Re}[\dot U_{AC}\dot
I_A^* + \dot U_{BC}\dot I_B^*]\)</span></p>
<h3 id="非正弦周期电流电路">非正弦周期电流电路</h3>
<p>设 <span class="math inline">\(i(t) = I_0 + \sum\limits_{k=1}^\infty
\sqrt{2}I_{k}\cos(k\omega_1 t+\phi_{ik})\)</span>，<span
class="math inline">\(u(t) = U_0 + \sum\limits_{k=1}^\infty
\sqrt{2}U_{k}\cos(k\omega_1 t+\phi_{uk})\)</span>，<span
class="math inline">\(\phi_k = \phi_{uk} - \phi_{ik}\)</span></p>
<p>有效值：</p>
<ul>
<li>电流 <span class="math inline">\(I = \sqrt{I_0^2 +
\sum\limits_{k=1}^\infty I_{k}^2}\)</span></li>
<li>电压 <span class="math inline">\(U = \sqrt{U_0^2 +
\sum\limits_{k=1}^\infty U_{k}^2}\)</span></li>
<li>功率 <span class="math inline">\(P = U_0I_0 +
\sum\limits_{k=1}^\infty U_kI_k \cos\phi_k\)</span></li>
</ul>
<h2 id="二端口网络">二端口网络</h2>
<figure>
<img src="/images/CircuitCourse/TwoPort.jpg" alt="二端口示意图" />
<figcaption aria-hidden="true">二端口示意图</figcaption>
</figure>
<p>Y 参数：短路导纳参数</p>
<p><span class="math display">\[
\begin{bmatrix}
\dot I_1 \newline
\dot I_2
\end{bmatrix}
=\mathbf Y
\begin{bmatrix}
\dot U_1 \newline
\dot U_2
\end{bmatrix}
=
\begin{bmatrix}
Y_{11} &amp; Y_{12} \newline
Y_{21} &amp; Y_{22}
\end{bmatrix}
\begin{bmatrix}
\dot U_1 \newline
\dot U_2
\end{bmatrix}
\]</span></p>
<p>Z 参数：开路阻抗参数</p>
<p><span class="math display">\[
\begin{bmatrix}
\dot U_1 \newline
\dot U_2
\end{bmatrix}
=\mathbf Z
\begin{bmatrix}
\dot I_1 \newline
\dot I_2
\end{bmatrix}
=
\begin{bmatrix}
Z_{11} &amp; Z_{12} \newline
Z_{21} &amp; Z_{22}
\end{bmatrix}
\begin{bmatrix}
\dot I_1 \newline
\dot I_2
\end{bmatrix}
\]</span></p>
<p>T 参数：传输参数</p>
<p><span class="math display">\[
\begin{bmatrix}
\dot U_1 \newline
\dot I_1
\end{bmatrix}
=\mathbf T
\begin{bmatrix}
\dot U_2 \newline
-\dot I_2
\end{bmatrix}
=
\begin{bmatrix}
A &amp; B \newline
C &amp; D
\end{bmatrix}
\begin{bmatrix}
\dot U_2 \newline
-\dot I_2
\end{bmatrix}
\]</span></p>
<p>H 参数：混合参数</p>
<p><span class="math display">\[
\begin{bmatrix}
\dot U_1 \newline
\dot I_2
\end{bmatrix}
=\mathbf H
\begin{bmatrix}
\dot I_1 \newline
\dot U_2
\end{bmatrix}
=
\begin{bmatrix}
H_{11} &amp; H_{12} \newline
H_{21} &amp; H_{22}
\end{bmatrix}
\begin{bmatrix}
\dot I_1 \newline
\dot U_2
\end{bmatrix}
\]</span></p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT 和我的概率统计词汇中英对照</title>
    <url>/2023/05/29/zh-CN/ChatGPT-%E5%92%8C%E6%88%91%E7%9A%84%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E8%AF%8D%E6%B1%87%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7/</url>
    <content><![CDATA[<p>我需要一个概率论词汇中英对照表。事情的起因，是为了帮助我一位需要参加北大光华夏令营笔试的好朋友。因为笔试只考概率论，但是题目很有可能是英文的。夏令营通知给的参考文献是
DeGroot, M. H. &amp; Schervish, M. J. (2012). Probability and statistics
(fourth edition)，这本书只有第三版有中文版。书后面有个
Index，给出了这本书里比较重要的名词、概念和人名，以及其对应的参考页码。这个
Index 有一千多词，我第一个想法是使用 ChatGPT 的 API 把它们翻译一遍。</p>
<p>我找到了 pdf 电子版并复制了
Index，然后用正则表达式修复了一下格式和复制错误等问题，把它弄成了纯文本形式。给点例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allison, D. B., 400</span><br><span class="line">Alternative hypothesis, 531</span><br><span class="line">Anagnostopoulos, P., xii</span><br><span class="line">Analysis of variance, 754</span><br><span class="line">    one-way layout, 755</span><br><span class="line">    residuals, 760</span><br><span class="line">    two-way layout, 763</span><br><span class="line">        with replications, 773</span><br><span class="line">...</span><br><span class="line">Bergin, P., xii</span><br><span class="line">Bernoulli distribution, 97, 276</span><br><span class="line">    conjugate prior for, 394-395</span><br><span class="line">    m.g.f., 276</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>接下来就是按行处理。Index
给出的一些概念是有层级关系的，用缩进表示。那么按行处理文本的时候弄一个栈存一下当前词的上下文即可。所有的概念全名就是把它和先前层次的名词都连起来，虽然会有点语序问题。处理完了可以得到结构化的数据
<code>data</code>，是一个全名为 key 的字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">term_stack = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (line.startswith(<span class="string">&quot;    &quot;</span>)):</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        line = line[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    simp_name = re.sub(<span class="string">r&quot;,\s*([-\d]+|[-ivx]+)&quot;</span>, <span class="string">&quot;&quot;</span>, line).strip()</span><br><span class="line">    page_matches = re.findall(<span class="string">r&quot;\b([-\d]+|[-ivx]+)\b&quot;</span>, line)</span><br><span class="line">    page_refs = [page <span class="keyword">for</span> page <span class="keyword">in</span> page_matches] <span class="keyword">if</span> page_matches <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line">    full_name = <span class="string">&quot; &quot;</span>.join(term_stack[:depth] + [simp_name])</span><br><span class="line">    <span class="keyword">del</span> term_stack[depth:]</span><br><span class="line">    term_stack.append(simp_name)</span><br><span class="line"></span><br><span class="line">    entry = &#123;</span><br><span class="line">        <span class="string">&quot;suffix name&quot;</span>: simp_name,</span><br><span class="line">        <span class="string">&quot;pages&quot;</span>: page_refs,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[full_name] = entry</span><br></pre></td></tr></table></figure>
<p>这里拿 <code>\b([-\d]+|[-ivx]+)\b</code>
来匹配页码和页码范围，但是有可能匹配到正文中的连字符 <code>-</code>
可以寻思着改进一下。</p>
<p>结构化的数据有了接下来是重头戏，拿 ChatGPT 翻译这些概念。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line">openai.api_key = <span class="string">&quot;YOUR KEY HERE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_term</span>(<span class="params">term</span>):</span></span><br><span class="line">    <span class="keyword">global</span> usage</span><br><span class="line">    prompt = <span class="string">&quot;Give the corresponding Simplified Chinese term given by the user. The term must be in the area of Probability and Statistics. You should only give one word or phrase without any other supplementary text or Pinyin.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            completion = openai.ChatCompletion.create(</span><br><span class="line">                model = <span class="string">&quot;gpt-3.5-turbo&quot;</span>, </span><br><span class="line">                messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span> : term&#125;]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Completion failed, retrying...&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    usage += completion.usage.total_tokens</span><br><span class="line">    <span class="keyword">return</span> completion.choices[<span class="number">0</span>].message.content.strip()</span><br></pre></td></tr></table></figure>
<p>直接使用 OpenAI 的 Python 库。我本来是问了一下 ChatGPT 怎么用
API，但是 ChatGPT 只会用 <code>text-davinci</code> completion
模型，并不知晓 <code>gpt-3.5-turbo</code>
模型的存在。所以还是看了一眼官方文档。这个
<code>openai.ChatCompletion.create</code> API
是会抛异常的，包括网络不通、API
额度超限、服务器过载等等问题，所以需要简单实现个重试机制。</p>
<p>这个脚本花了快一个小时才跑完 1000 余个概念，基本是在等 API
response，而且十几个 request
就得有一次超负荷或者断连得重试。跑出来的结果也一般。我都明确告诉它了不要附汉语拼音它有时候还是要加上。也有不少人名它不认识并告诉我这不是概率统计的内容所以拒不翻译，这个倒不怪它。下面是一些奇葩回应大赏。</p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 46%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>词汇或概念</th>
<th>ChatGPT 的翻译</th>
<th>参考页码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anagnostopoulos, P.</td>
<td>Anagnostopoulos, P. (Greek name) does not correspond to a term in
the area of Probability and Statistics. Please provide a valid
term.</td>
<td>xii</td>
</tr>
<tr class="even">
<td>Absolute error loss</td>
<td>绝对误差损失 (jué duì wù chā sǔn shī)</td>
<td>411</td>
</tr>
<tr class="odd">
<td>[Bayes test] relation to t test</td>
<td>贝叶斯t检验 (Bayes t检验)</td>
<td>612</td>
</tr>
<tr class="even">
<td>Binomial approximation to hypergeometric distribution</td>
<td>二项式近似分布 (Er Xiang Shi Jin Fen Bu)</td>
<td>284</td>
</tr>
<tr class="odd">
<td>[Binomial distribution] relation to negative binomial
distribution</td>
<td>二项分布与负二项分布的关系:
负二项分布可被视为一系列相互独立的二项分布试验中，直到 r
次失败所需的试验次数的概率分布。</td>
<td>345</td>
</tr>
<tr class="even">
<td>Bush, G. W.</td>
<td>布什，G.W. (Note: This is not a term in Probability and Statistics.
It is the name of a person.)</td>
<td>786</td>
</tr>
<tr class="odd">
<td>Bootstrap confidence interval</td>
<td>自助法置信区间</td>
<td></td>
</tr>
</tbody>
</table>
<p>最后看了看这些 Index Term 和 ChatGPT
给的翻译，觉得重复率高、人名多还没用。给一个像这样的一千多个词的表并没有什么帮助，它也给不出什么信息。</p>
<p>几个月前，大家还觉得 ChatGPT
是什么新鲜的、能够大大提升人类生产力、提升学生的学习效率的超智能
AI。短短几周过去了，我已然觉得这个世界好像没有因为这样一个能理解并生产简单文字的
AI
而改变太多。希望以后能把这几千行直接塞给大模型，让他帮我总结经验。</p>
<p>于是乎，玩了几个小时后，还是回到了手工总结单词的重复劳作上。我想把我自己总结的结果贴在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Part 1. Abbreviations						</span><br><span class="line">Abbr.	Full Term			Zh-CN Term		</span><br><span class="line">m.g.f.	Moment-generating function			矩母函数		</span><br><span class="line">p.f.	Probability function			概率分布函数		</span><br><span class="line">p.d.f.	Probability density function			概率密度函数		</span><br><span class="line">c.d.f.	Cumulative distribution function			累计概率密度函数		</span><br><span class="line">M.L.R.	Multivariate Linear Regression 			多元线性回归		</span><br><span class="line">M.L.E.	Maximum likelihood estimation			极大似然估计		</span><br><span class="line">i.e.	id est			即（又称为）		</span><br><span class="line">e.g.	exempli gratia			举例子		</span><br><span class="line">s.t.	Subject to			使得		</span><br><span class="line">iff	if and only if			当且仅当		</span><br><span class="line">inf/glb	infimum/greatest lower bound			极小值/最大下界		</span><br><span class="line">sup/lub	supremum/least upper bound			极大值/最小上界		</span><br><span class="line">min	minimum			最小值		</span><br><span class="line">max	maximum			最大值		</span><br><span class="line">M.A.E.	Mean absolute error			平均绝对误差		</span><br><span class="line">M.S.E.	Mean squared error			均方误差		</span><br><span class="line">int	interior			内部		</span><br><span class="line">lcm	least common multiple			最小公倍数		</span><br><span class="line">gcd	greatest common divisor			最大公约数		</span><br><span class="line">mod	modulo			取模运算		</span><br><span class="line">QED	Quod erat demonstrandum			证毕		</span><br><span class="line">LHS/RHS	Left/Right hand side			（公式的）左/右侧部分		</span><br><span class="line">tr	trace			（矩阵的）迹		</span><br><span class="line">UMP test	Uniformly most powerful test			一致最强检验		</span><br><span class="line">						</span><br><span class="line">Part 2. Probability and Statistics Terms						</span><br><span class="line">En-US Term				Zh-CN Term		</span><br><span class="line">Set				集合		</span><br><span class="line">Countable				可数		</span><br><span class="line">Absolute				绝对的		</span><br><span class="line">Error				误差		</span><br><span class="line">Efficient estimation				有效估计		</span><br><span class="line">Unbiased estimation				无偏估计		</span><br><span class="line">Inadmissible estimation				（国内课本似乎没有这个概念）		</span><br><span class="line">Consistent estimation				一致估计		</span><br><span class="line">Robust estimation				稳健估计		</span><br><span class="line">Least-squares estimation				最小二乘估计		</span><br><span class="line">Estimator				估计量		</span><br><span class="line">Predictor				预测量		</span><br><span class="line">Aggregated				汇总		</span><br><span class="line">Alias				别名		</span><br><span class="line">Genotype				基因型		</span><br><span class="line">Allele				等位基因		</span><br><span class="line">Assumptions				假设（模型假设）		</span><br><span class="line">Hypothesis				假设（假设检验）		</span><br><span class="line">Null Hypothesis				零假设		</span><br><span class="line">One-sided Hypothesis				单侧假设		</span><br><span class="line">Reject Hypothesis				拒绝假设		</span><br><span class="line">Interquartile range				四分位距		</span><br><span class="line">Lower/Upper quartile				上/下四分位点		</span><br><span class="line">Percentile				百分位点		</span><br><span class="line">Quantile				分位数		</span><br><span class="line">Median				中位数		</span><br><span class="line">Expectation				期望		</span><br><span class="line">Mode				众数		</span><br><span class="line">Mean				均值		</span><br><span class="line">Conditional mean				条件均值		</span><br><span class="line">Grand mean				总均值		</span><br><span class="line">Trimmed mean				修剪平均数		</span><br><span class="line">Harmonic mean				调和平均数		</span><br><span class="line">Variance				方差		</span><br><span class="line">Residual				残差		</span><br><span class="line">Central Moment				中心矩		</span><br><span class="line">One-way layout ANOVA				单因素方差分析		</span><br><span class="line">Antithetic variates				对偶变量		</span><br><span class="line">Multiplication rule				乘法原理		</span><br><span class="line">Additivity				可加性		</span><br><span class="line">Asymptotic				渐进的		</span><br><span class="line">Distribution				分布		</span><br><span class="line">Augmented				增强的、增广		</span><br><span class="line">Auxiliary				辅助的		</span><br><span class="line">Benoulli				伯努利		</span><br><span class="line">Poisson				泊松		</span><br><span class="line">Cauchy				柯西		</span><br><span class="line">Bayes				贝叶斯		</span><br><span class="line">Liapounov				李雅普诺夫		</span><br><span class="line">Lindeberg and Le ́vy				林德伯格和莱维		</span><br><span class="line">Chebyshev				切比雪夫		</span><br><span class="line">Gram-Schmidt method				格拉姆-施密特正交化		</span><br><span class="line">Markov chain stationary distribution				马尔可夫链稳态分布		</span><br><span class="line">Pearson				皮尔逊		</span><br><span class="line">Theorem				定理		</span><br><span class="line">Axiom				公理		</span><br><span class="line">Law of large numbers				大数定理		</span><br><span class="line">Regression				回归		</span><br><span class="line">Bivariate				双变量		</span><br><span class="line">Multivariate				多变量		</span><br><span class="line">Process				过程		</span><br><span class="line">Inference				推理		</span><br><span class="line">Event				事件		</span><br><span class="line">Random variable				随机变量		</span><br><span class="line">Sample				采样		</span><br><span class="line">Test				检验		</span><br><span class="line">Trial				试验		</span><br><span class="line">Binomial				二项式的		</span><br><span class="line">multinomial				多项式的		</span><br><span class="line">Coefficient				系数		</span><br><span class="line">Parameter				参数		</span><br><span class="line">Nonparametric				非参数的		</span><br><span class="line">Factor				因素		</span><br><span class="line">Conjugate				共轭		</span><br><span class="line">Confidence interval				置信区间		</span><br><span class="line">Bootstrap methods				Bootstrap 方法		</span><br><span class="line">Central limit theorem				中心极限定理		</span><br><span class="line">Moment				矩		</span><br><span class="line">Classical interpretation of probability				古典概型		</span><br><span class="line">Combinations				组合		</span><br><span class="line">Complement				互补事件		</span><br><span class="line">Composite				复合的		</span><br><span class="line">Independent				独立的		</span><br><span class="line">Uniform				一致的、均匀的		</span><br><span class="line">Family				族		</span><br><span class="line">Contaminate				污染		</span><br><span class="line">Contingency table				列联表		</span><br><span class="line">Joint distribution				联合分布		</span><br><span class="line">Discrete				离散的		</span><br><span class="line">Continuous				连续的		</span><br><span class="line">Converge				收敛		</span><br><span class="line">Convex function				凸函数		</span><br><span class="line">Correlation				相关性		</span><br><span class="line">Pivotal				关键的		</span><br><span class="line">Critical				临界的		</span><br><span class="line">Dimension				维度		</span><br><span class="line">Exponential				指数的		</span><br><span class="line">Geometric				几何的		</span><br><span class="line">Posterior distribution				后验分布		</span><br><span class="line">Prior distribution				先验分布		</span><br><span class="line">Normal				正态		</span><br><span class="line">Distributive properties				分配律		</span><br><span class="line">Dominate				支配		</span><br><span class="line">Algorithm				算法		</span><br><span class="line">Empirical c.d.f.				经验分布函数		</span><br><span class="line">Equivalence				等价		</span><br><span class="line">Extrapolation				外推		</span><br><span class="line">Criterion				准则		</span><br><span class="line">Goodness-of-fit test				拟合优度检验		</span><br><span class="line">Histogram				直方图		</span><br><span class="line">Hyper-				超-（词缀）		</span><br><span class="line">Hypo-				次-（词缀）		</span><br><span class="line">Series				级数		</span><br><span class="line">Sufficient				充分		</span><br><span class="line">Level of significance				显著水平		</span><br><span class="line">Likelihood function				似然函数		</span><br><span class="line">Marginal distribution				边缘分布		</span><br><span class="line">Vector				向量		</span><br><span class="line">Normalize				归一化		</span><br><span class="line">Partition				划分		</span><br><span class="line">Sign				符号		</span><br><span class="line">Ranktest				秩和检验		</span><br><span class="line">Reliability				可靠性		</span><br><span class="line">Paradox				悖论		</span><br><span class="line">Skewness				偏度		</span><br><span class="line">Stochastic process				随机过程		</span><br><span class="line">Stratified				分层的		</span><br><span class="line">Trigamma function				三次对角函数		</span><br><span class="line">Utility function				效用函数		</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随想</tag>
        <tag>Tech</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
</search>
